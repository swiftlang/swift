//===--- ClangMacros.def - Macros emitted by PrintAsClang ----=--*- C++ -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// This file defines the database of macros emitted into compatibility headers
// generated by PrintAsClang.
//
//===----------------------------------------------------------------------===//

// CLANG_MACRO(NAME, ARGS, VALUE)
// A simple name/value macro that does not depend on a condition.
#ifndef CLANG_MACRO
#define CLANG_MACRO(NAME, ARGS, VALUE)
#endif

// CLANG_MACRO_BODY(NAME, BODY)
// A macro conditionalized on the name, but that defines a helper macro or
// other kind of additional definitions other than the macro itself.
#ifndef CLANG_MACRO_BODY
#define CLANG_MACRO_BODY(NAME, BODY)
#endif

// CLANG_MACRO_DEFINED(NAME)
// Used to signal that a macro is defined by another CLANG_MACRO_BODY call.
// This is included so that these macros can be included in the generated
// `compatibility_symbols` file.
#ifndef CLANG_MACRO_DEFINED
#define CLANG_MACRO_DEFINED(NAME)
#endif

// CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, ALTERNATIVE)
// A simple name/value macro that evaluates to the given value when the given
// condition is true, or to the alternative value when it is false.
#ifndef CLANG_MACRO_ALTERNATIVE
#define CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, ALTERNATIVE)
#endif

// CLANG_MACRO_CONDITIONAL(NAME, ARGS, CONDITION, VALUE)
// A simple name/value macro that only evaluates to the given value when the
// given condition is true. Otherwise the macro will evaluate to nothing.
#ifndef CLANG_MACRO_CONDITIONAL
#define CLANG_MACRO_CONDITIONAL(NAME, ARGS, CONDITION, VALUE) \
    CLANG_MACRO_ALTERNATIVE(NAME, ARGS, CONDITION, VALUE, )
#endif

// CLANG_MACRO_OBJC(NAME, ARGS, VALUE)
// A simple name/value macro that is only defined when being compiled as
// Objective-C.
#ifndef CLANG_MACRO_OBJC
#define CLANG_MACRO_OBJC(NAME, ARGS, VALUE)
#endif

// CLANG_MACRO_CXX(NAME, ARGS, VALUE, ALTERNATIVE)
// A simple name/value macro that evaluates to the given value when being
// compiled as C++, or as the alternative when not.
#ifndef CLANG_MACRO_CXX
#define CLANG_MACRO_CXX(NAME, ARGS, VALUE, ALTERNATIVE)
#endif

// CLANG_MACRO_CXX_BODY(NAME, BODY)
// A complex macro conditionalized on whether the source is being compiled as
// C++.
#ifndef CLANG_MACRO_CXX_BODY
#define CLANG_MACRO_CXX_BODY(NAME, BODY)
#endif

CLANG_MACRO_DEFINED("SWIFT_TYPEDEFS")
CLANG_MACRO_DEFINED("char8_t")
CLANG_MACRO_DEFINED("char16_t")
CLANG_MACRO_DEFINED("char32_t")

#define MAP_SIMD_TYPE(C_TYPE, SCALAR_TYPE, _) \
    CLANG_MACRO_DEFINED("swift_" #C_TYPE "2") \
    CLANG_MACRO_DEFINED("swift_" #C_TYPE "3") \
    CLANG_MACRO_DEFINED("swift_" #C_TYPE "4")
#include "swift/ClangImporter/SIMDMappedTypes.def"

CLANG_MACRO_BODY("SWIFT_PASTE", \
    "# define SWIFT_PASTE_HELPER(x, y) x##y\n" \
    "# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)")
CLANG_MACRO_DEFINED("SWIFT_PASTE_HELPER")

CLANG_MACRO("SWIFT_METATYPE", "(X)", "Class")

CLANG_MACRO_CONDITIONAL("SWIFT_CLASS_PROPERTY", \
                        "(...)", \
                        "__has_feature(objc_class_property)", \
                        "__VA_ARGS__")

CLANG_MACRO_CONDITIONAL("SWIFT_RUNTIME_NAME", \
                        "(X)", \
                        "__has_attribute(objc_runtime_name)", \
                        "__attribute__((objc_runtime_name(X)))")

CLANG_MACRO_CONDITIONAL("SWIFT_COMPILE_NAME", \
                        "(X)", \
                        "__has_attribute(swift_name)", \
                        "__attribute__((swift_name(X)))")

CLANG_MACRO_CONDITIONAL("SWIFT_METHOD_FAMILY", \
                        "(X)", \
                        "__has_attribute(objc_method_family)",
                        "__attribute__((objc_method_family(X)))")

CLANG_MACRO_CONDITIONAL("SWIFT_NOESCAPE", , \
                        "__has_attribute(noescape)", \
                        "__attribute__((noescape))")

CLANG_MACRO_CONDITIONAL("SWIFT_RELEASES_ARGUMENT", , \
                        "__has_attribute(ns_consumed)", \
                        "__attribute__((ns_consumed))")

CLANG_MACRO_CONDITIONAL("SWIFT_WARN_UNUSED_RESULT", , \
                        "__has_attribute(warn_unused_result)", \
                        "__attribute__((warn_unused_result))")

CLANG_MACRO_CONDITIONAL("SWIFT_NORETURN", , \
                        "__has_attribute(noreturn)", \
                        "__attribute__((noreturn))")

CLANG_MACRO("SWIFT_CLASS_EXTRA", , )
CLANG_MACRO("SWIFT_PROTOCOL_EXTRA", , )
CLANG_MACRO("SWIFT_ENUM_EXTRA", , )

CLANG_MACRO_BODY("SWIFT_CLASS", \
    "# if __has_attribute(objc_subclassing_restricted)\n" \
    "#  define SWIFT_CLASS(SWIFT_NAME) " \
        "SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) " \
        "SWIFT_CLASS_EXTRA\n" \
    "#  define SWIFT_CLASS_NAMED(SWIFT_NAME) " \
        "__attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) " \
        "SWIFT_CLASS_EXTRA\n" \
    "# else\n" \
    "#  define SWIFT_CLASS(SWIFT_NAME) " \
        "SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n" \
    "#  define SWIFT_CLASS_NAMED(SWIFT_NAME) " \
        "SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n" \
    "# endif")
CLANG_MACRO_DEFINED("SWIFT_CLASS_NAMED")

CLANG_MACRO_BODY("SWIFT_RESILIENT_CLASS", \
    "# if __has_attribute(objc_class_stub)\n" \
    "#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) " \
        "SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))\n" \
    "#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) " \
        "__attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)\n" \
    "# else\n" \
    "#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)\n" \
    "#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)\n" \
    "# endif")
CLANG_MACRO_DEFINED("SWIFT_RESILIENT_CLASS_NAMED")

CLANG_MACRO_BODY("SWIFT_PROTOCOL", \
    "# define SWIFT_PROTOCOL(SWIFT_NAME) " \
        "SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA\n" \
    "# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) " \
        "SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA")
CLANG_MACRO_DEFINED("SWIFT_PROTOCOL_NAMED")

CLANG_MACRO("SWIFT_EXTENSION", "(M)", "SWIFT_PASTE(M##_Swift_, __LINE__)")

CLANG_MACRO_CONDITIONAL("OBJC_DESIGNATED_INITIALIZER", , \
                        "__has_attribute(objc_designated_initializer)", \
                        "__attribute__((objc_designated_initializer))")

CLANG_MACRO_CONDITIONAL("SWIFT_ENUM_ATTR", "(_extensibility)", \
                        "__has_attribute(enum_extensibility)", \
                        "__attribute__((enum_extensibility(_extensibility)))")

CLANG_MACRO_BODY("SWIFT_ENUM", \
    "# define SWIFT_ENUM(_type, _name, _extensibility) " \
        "enum _name : _type _name; " \
        "enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type\n" \
    "# if __has_feature(generalized_swift_name)\n" \
    "#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) " \
        "enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); " \
        "enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) " \
            "SWIFT_ENUM_EXTRA _name : _type\n" \
    "# else\n" \
    "#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) " \
        "SWIFT_ENUM(_type, _name, _extensibility)\n" \
    "# endif")
CLANG_MACRO_DEFINED("SWIFT_ENUM_NAMED")

CLANG_MACRO("SWIFT_UNAVAILABLE", , "__attribute__((unavailable))")
CLANG_MACRO("SWIFT_UNAVAILABLE_MSG", "(msg)", "__attribute__((unavailable(msg)))")

CLANG_MACRO("SWIFT_AVAILABILITY", "(plat, ...)", "__attribute__((availability(plat, __VA_ARGS__)))")

CLANG_MACRO("SWIFT_WEAK_IMPORT", , "__attribute__((weak_import))")

CLANG_MACRO("SWIFT_DEPRECATED", , "__attribute__((deprecated))")
CLANG_MACRO("SWIFT_DEPRECATED_MSG", "(...)", "__attribute__((deprecated(__VA_ARGS__)))")

CLANG_MACRO_ALTERNATIVE("SWIFT_DEPRECATED_OBJC", "(Msg)", \
                        "__has_feature(attribute_diagnose_if_objc)", \
                        "__attribute__((diagnose_if(1, Msg, \"warning\")))", \
                        "SWIFT_DEPRECATED_MSG(Msg)")

CLANG_MACRO_OBJC("IBSegueAction", , )

CLANG_MACRO_BODY("SWIFT_EXTERN", \
    "# if defined(__cplusplus)\n" \
    "#  define SWIFT_EXTERN extern \"C\"\n" \
    "# else\n" \
    "#  define SWIFT_EXTERN extern\n"
    "# endif")

CLANG_MACRO("SWIFT_CALL", , "__attribute__((swiftcall))")

CLANG_MACRO("SWIFT_INDIRECT_RESULT", , "__attribute__((swift_indirect_result))")

CLANG_MACRO("SWIFT_CONTEXT", , "__attribute__((swift_context))")

CLANG_MACRO("SWIFT_ERROR_RESULT", , "__attribute__((swift_error_result))")

// The expansion of this depends on whether stdlib is built as a dynamic library, so do that print
// in PrintAsClang.cpp instead of here since it can't be done in a preprocessor macro
CLANG_MACRO_DEFINED("SWIFT_IMPORT_STDLIB_SYMBOL")

CLANG_MACRO_CXX("SWIFT_NOEXCEPT", , "noexcept", )

CLANG_MACRO_BODY("SWIFT_C_INLINE_THUNK", \
    "# if __has_attribute(always_inline)\n" \
    "# if __has_attribute(nodebug)\n" \
    "#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))\n" \
    "# else\n" \
    "#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))\n" \
    "# endif\n" \
    "# else\n" \
    "#  define SWIFT_C_INLINE_THUNK inline\n"\
    "# endif")

#undef CLANG_MACRO
#undef CLANG_MACRO_BODY
#undef CLANG_MACRO_DEFINED
#undef CLANG_MACRO_ALTERNATIVE
#undef CLANG_MACRO_CONDITIONAL
#undef CLANG_MACRO_OBJC
#undef CLANG_MACRO_CXX
#undef CLANG_MACRO_CXX_BODY
