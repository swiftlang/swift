//===--- ParseableInterfaceSupport.h - swiftinterface files -----*- C++ -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2018 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

#ifndef SWIFT_FRONTEND_PARSEABLEINTERFACESUPPORT_H
#define SWIFT_FRONTEND_PARSEABLEINTERFACESUPPORT_H

#include "swift/Basic/LLVM.h"
#include "swift/Serialization/SerializedModuleLoader.h"
#include "llvm/Support/Regex.h"

namespace swift {

class ModuleDecl;

/// Options for controlling the generation of the .swiftinterface output.
struct ParseableInterfaceOptions {
  /// Copy of all the command-line flags passed at .swiftinterface
  /// generation time, re-applied to CompilerInvocation when reading
  /// back .swiftinterface and reconstructing .swiftmodule.
  std::string ParseableInterfaceFlags;
};

llvm::Regex getSwiftInterfaceFormatVersionRegex();
llvm::Regex getSwiftInterfaceModuleFlagsRegex();

/// Emit a stable, parseable interface for \p M, which can be used by a client
/// source file to import this module, subject to options given by \p Opts.
///
/// Unlike a serialized module, the textual format generated by
/// emitModuleInterface is intended to be stable across compiler versions while
/// still describing the full ABI of the module in question.
///
/// The initial plan for this format can be found at
/// https://forums.swift.org/t/plan-for-module-stability/14551/
///
/// \return true if an error occurred
///
/// \sa swift::serialize
bool emitParseableInterface(raw_ostream &out,
                            ParseableInterfaceOptions const &Opts,
                            ModuleDecl *M);

/// Extract the specified-or-defaulted -module-cache-path that winds up in
/// the clang importer, for reuse as the .swiftmodule cache path when
/// building a ParseableInterfaceModuleLoader.
std::string
getModuleCachePathFromClang(const clang::CompilerInstance &Instance);

/// A ModuleLoader that runs a subordinate \c CompilerInvocation and \c
/// CompilerInstance to convert .swiftinterface files to .swiftmodule
/// files on the fly, caching the resulting .swiftmodules in the module cache
/// directory, and loading the serialized .swiftmodules from there.
class ParseableInterfaceModuleLoader : public SerializedModuleLoaderBase {
  explicit ParseableInterfaceModuleLoader(ASTContext &ctx, StringRef cacheDir,
                                          StringRef prebuiltCacheDir,
                                          DependencyTracker *tracker,
                                          ModuleLoadingMode loadMode)
    : SerializedModuleLoaderBase(ctx, tracker, loadMode),
      CacheDir(cacheDir), PrebuiltCacheDir(prebuiltCacheDir)
  {}

  std::string CacheDir;
  std::string PrebuiltCacheDir;

  /// Wire up the SubInvocation's InputsAndOutputs to contain both input and
  /// output filenames.
  ///
  /// This is a method rather than a helper function in the implementation file
  /// because it accesses non-public bits of FrontendInputsAndOutputs.
  static void configureSubInvocationInputsAndOutputs(
    CompilerInvocation &SubInvocation, StringRef InPath, StringRef OutPath);

  static bool buildSwiftModuleFromSwiftInterface(
    clang::vfs::FileSystem &FS, DiagnosticEngine &Diags, SourceLoc DiagLoc,
    CompilerInvocation &SubInvocation, StringRef InPath, StringRef OutPath,
    StringRef ModuleCachePath, DependencyTracker *OuterTracker);

  std::error_code findModuleFilesInDirectory(
      AccessPathElem ModuleID, StringRef DirPath, StringRef ModuleFilename,
      StringRef ModuleDocFilename,
      std::unique_ptr<llvm::MemoryBuffer> *ModuleBuffer,
      std::unique_ptr<llvm::MemoryBuffer> *ModuleDocBuffer) override;

public:
  static std::unique_ptr<ParseableInterfaceModuleLoader>
  create(ASTContext &ctx, StringRef cacheDir, StringRef prebuiltCacheDir,
         DependencyTracker *tracker, ModuleLoadingMode loadMode) {
    return std::unique_ptr<ParseableInterfaceModuleLoader>(
        new ParseableInterfaceModuleLoader(ctx, cacheDir, prebuiltCacheDir,
                                           tracker, loadMode));
  }

  /// Unconditionally build \p InPath (a swiftinterface file) to \p OutPath (as
  /// a swiftmodule file).
  ///
  /// A simplified version of the core logic in #openModuleFiles, mostly for
  /// testing purposes.
  static bool buildSwiftModuleFromSwiftInterface(ASTContext &Ctx,
                                                 StringRef CacheDir,
                                                 StringRef PrebuiltCacheDir,
                                                 StringRef ModuleName,
                                                 StringRef InPath,
                                                 StringRef OutPath);
};


} // end namespace swift

#endif
