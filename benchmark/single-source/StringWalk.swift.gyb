//===--- StringWalk.swift -------------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2021 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

% # Ignore the following warning. This _is_ the correct file to edit.
////////////////////////////////////////////////////////////////////////////////
// WARNING: This file is manually generated from .gyb template and should not
// be directly modified. Instead, make changes to StringWalk.swift.gyb and run
// scripts/generate_harness/generate_harness.py to regenerate this file.
////////////////////////////////////////////////////////////////////////////////

//
// Test String iteration performance over a variety of workloads, languages,
// and symbols.
//

import TestsUtils

//
// Helper functionality
//

@inline(never) func count_scalars(_ s: String.UnicodeScalarView) {
  var count = 0
  for _ in s {
    count += 1
  }
  blackHole(count)
}
@inline(never) func count_chars(_ s: String) {
  var count = 0
  for _ in s {
    count += 1
  }
  blackHole(count)
}
@inline(never) func count_scalars_rev(
  _ s: ReversedCollection<String.UnicodeScalarView>
) {
  var count = 0
  for _ in s {
    count += 1
  }
  blackHole(count)
}
@inline(never) func count_chars_rev(
  _ s: ReversedCollection<String>
) {
  var count = 0
  for _ in s {
    count += 1
  }
  blackHole(count)
}
@inline(never) func count_charsIndexed(_ s: String) {
  var idx = s.startIndex
  while idx != s.endIndex {
    blackHole(s[idx])
    s.formIndex(after: &idx)
  }
}

@inline(never) func count_charsIndexed_rev(
    _ s: ReversedCollection<String>
  ) {
  var idx = s.endIndex
  s.formIndex(before: &idx)
  while idx != s.startIndex {
    blackHole(s[idx])
    s.formIndex(before: &idx)
  }
}

//
// Workloads
//

var ascii: String? = nil
var emoji: String?  = nil
var utf16: String?  = nil
var japanese: String?  = nil
var chinese: String?  = nil
var korean: String?  = nil
var russian: String?  = nil
var punctuated: String?  = nil
var punctuatedJapanese: String?  = nil
var tweet: String? = nil

func initializeStrings() {
  ascii = String(
    repeating: "siebenhundertsiebenundsiebzigtausendsiebenhundertsiebenundsiebenzig",
    count: 50
  )

  emoji = String(
    repeating: "ğŸ‘ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ğŸ‡ºğŸ‡¸ğŸ‡¨ğŸ‡¦ğŸ‡²ğŸ‡½ğŸ‘ğŸ»ğŸ‘ğŸ¼ğŸ‘ğŸ½ğŸ‘ğŸ¾ğŸ‘ğŸ¿",
    count: 25
  )

  utf16 = emoji! + "the quick brown fox" + String(emoji!.reversed())

  japanese = String(
    repeating: "ä»Šå›ã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã§Swiftã«å¤§å¹…ãªæ”¹è‰¯ãŒæ–½ã•ã‚Œã€å®‰å®šã—ã¦ã„ã¦ã—ã‹ã‚‚ç›´æ„Ÿçš„ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹Appleãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å‘ã‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«ãªã‚Šã¾ã—ãŸã€‚",
    count: 50
  )

  chinese = String(
    repeating: "Swift æ˜¯é¢å‘ Apple å¹³å°çš„ç¼–ç¨‹è¯­è¨€ï¼ŒåŠŸèƒ½å¼ºå¤§ä¸”ç›´è§‚æ˜“ç”¨ï¼Œè€Œæœ¬æ¬¡æ›´æ–°å¯¹å…¶è¿›è¡Œäº†å…¨é¢ä¼˜åŒ–ã€‚",
    count: 50
  )

  korean = String(
    repeating: "ì´ë²ˆ ì—…ë°ì´íŠ¸ì—ì„œëŠ” ê°•ë ¥í•˜ë©´ì„œë„ ì§ê´€ì ì¸ Apple í”Œë«í¼ìš© í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì¸ Swiftë¥¼ ì™„ë²½íˆ ê°œì„ í•˜ì˜€ìŠµë‹ˆë‹¤.",
    count: 50
  )

  russian = String(
    repeating: "Ğ² Ñ‡Ğ°Ñ‰Ğ°Ñ… ÑĞ³Ğ° Ğ¶Ğ¸Ğ»-Ğ±Ñ‹Ğ» Ñ†Ğ¸Ñ‚Ñ€ÑƒÑ? Ğ´Ğ°, Ğ½Ğ¾ Ñ„Ğ°Ğ»ÑŒÑˆĞ¸Ğ²Ñ‹Ğ¹ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€",
    count: 50
  )

  punctuated = String(
    repeating: "\u{201c}Hello\u{2010}world\u{2026}\u{201d}",
    count: 100
  )
  punctuatedJapanese = String(
    repeating: "\u{300c}\u{300e}ä»Šæ—¥ã¯\u{3001}ä¸–ç•Œ\u{3002}\u{300f}\u{300d}",
    count: 100
  )
  // A workload that's mostly Latin characters, with occasional emoji
  // interspersed. Common for tweets.
  tweet = String(
    repeating: "Worst thing about working on String is that it breaks *everything*. Asserts, debuggers, and *especially* printf-style debugging ğŸ˜­",
    count: 40
  )
}
//
// Benchmarks
//

// Pre-commit benchmark: simple scalar walk
@inline(never)
public func run_StringWalk(_ n: Int) {
  let oldAscii = "siebenhundertsiebenundsiebzigtausendsiebenhundertsiebenundsiebenzig"
  for _ in 1...n*250 {
    count_scalars(oldAscii.unicodeScalars)
  }
}

// Extended String benchmarks:
let unicodeScalarsMultiplier = 5
let stringWalkWarmup = 5

% Names = ["ascii", "utf16", "tweet", "japanese", "chinese", "korean", "russian", "punctuated", "punctuatedJapanese"]
% Kinds = ["scalars", "chars", "charsIndexed"]
% Directions = ["", "Backwards"]

// An extended benchmark suite exercising finer-granularity behavior of our
// Strings.
public let benchmarks = [
  BenchmarkInfo(
    name: "StringWalk",
    runFunction: run_StringWalk,
    tags: [.validation, .api, .String],
    legacyFactor: 40),

% for Name in Names:
%   for Direction in Directions:
%     for Kind in Kinds:

  BenchmarkInfo(
    name: "StringWalk.${Name}.${Kind}${Direction}",
    runFunction: run_StringWalk_${Name}_${Kind}${Direction},
    tags: [.api, .String],
    setUpFunction: {
      initializeStrings()
      run_StringWalk_${Name}_${Kind}${Direction}(stringWalkWarmup)
    },
    legacyFactor: 1),

%     end # Kinds
%     end # Directions
  BenchmarkInfo(
    name: "CharIteration_${Name}_unicodeScalars",
    runFunction: run_CharIteration_${Name}_unicodeScalars,
    tags: [.validation, .api, .String],
    setUpFunction: initializeStrings,
    legacyFactor: 40),

  BenchmarkInfo(
    name: "CharIndexing_${Name}_unicodeScalars",
    runFunction: run_CharIndexing_${Name}_unicodeScalars,
    tags: [.validation, .api, .String],
    setUpFunction: initializeStrings,
    legacyFactor: 40),

  BenchmarkInfo(
    name: "CharIteration_${Name}_unicodeScalars_Backwards",
    runFunction: run_CharIteration_${Name}_unicodeScalars_Backwards,
    tags: [.validation, .api, .String],
    setUpFunction: initializeStrings,
    legacyFactor: 40),

  BenchmarkInfo(
    name: "CharIndexing_${Name}_unicodeScalars_Backwards",
    runFunction: run_CharIndexing_${Name}_unicodeScalars_Backwards,
    tags: [.validation, .api, .String],
    setUpFunction: initializeStrings,
    legacyFactor: 40),
% end # Names
]

% for Name in Names:
%   for (Kind, View, Scale) in zip(Kinds, [".unicodeScalars", "", ""], [400, 40, 40]):

@inline(never)
public func run_StringWalk_${Name}_${Kind}(_ n: Int) {
  for _ in 1...n*${Scale} {
    count_${Kind}(${Name}!${View})
  }
}

@inline(never)
public func run_StringWalk_${Name}_${Kind}Backwards(_ n: Int) {
  for _ in 1...n*${Scale} {
    count_${Kind}_rev(${Name}!${View}.reversed())
  }
}

%   end

let ${Name}Characters = Array(${Name}!)

@inline(never)
public func run_CharIteration_${Name}_unicodeScalars(_ n: Int) {
  var count = 0
  for _ in 1...unicodeScalarsMultiplier*n {
    for c in ${Name}Characters {
      for u in c.unicodeScalars {
        count |= Int(u.value)
      }
    }
  }
  blackHole(count)
}

@inline(never)
public func run_CharIteration_${Name}_unicodeScalars_Backwards(_ n: Int) {
  var count = 0
  for _ in 1...unicodeScalarsMultiplier*n {
    for c in ${Name}Characters {
      for u in c.unicodeScalars.reversed() {
        count |= Int(u.value)
      }
    }
  }
  blackHole(count)
}

@inline(never)
public func run_CharIndexing_${Name}_unicodeScalars(_ n: Int) {
  var count = 0
  for _ in 1...unicodeScalarsMultiplier*n {
    for c in ${Name}Characters {
      let s = c.unicodeScalars
      for i in s.indices {
        count |= Int(s[i].value)
      }
    }
  }
  blackHole(count)
}

@inline(never)
public func run_CharIndexing_${Name}_unicodeScalars_Backwards(_ n: Int) {
  var count = 0
  for _ in 1...unicodeScalarsMultiplier*n {
    for c in ${Name}Characters {
      let s = c.unicodeScalars
      for i in s.indices.reversed() {
        count |= Int(s[i].value)
      }
    }
  }
  blackHole(count)
}


% end

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
