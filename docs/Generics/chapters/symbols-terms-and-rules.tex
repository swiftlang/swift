\documentclass[../generics]{subfiles}

\begin{document}

\chapter{Symbols, Terms, and Rules}\label{symbols terms rules}

\IndexDefinition{rewrite system!in requirement machine}%
\index{finitely-presented monoid}%
\lettrine{O}{ur motivation} for encoding a finitely-presented monoid as a generic signature was theoretical---it gave us interesting test cases, and showed that there are limits to what we can accept. In comparison, the encoding of a generic signature as a finitely-presented monoid is an eminently practical matter---it solves generic signature queries. As with the derived requirements formalism in \SecRef{derived req}, we gradually reveal the full encoding. We begin with the core Swift generics model: \index{unbound type parameter}unbound type parameters, conformance requirements, and same-type requirements between type parameters. After we prove that the core model is correct, we will extend it to cover bound type parameters, and also layout, superclass, and concrete type requirements.

\paragraph{Core model.}
Let $G$ be a \index{generic signature}generic signature. We recall from \SecRef{protocol component} that if~\tP\ is some protocol, then $G\prec\tP$ means that $G$ \index{protocol dependency set}depends on~\tP. We now introduce a certain monoid presentation~$\AR$, called the \emph{requirement machine} for~$G$.

We take our ``chewy'' recursive inputs---\index{type parameter}type parameters, conformance requirements, and same-type requirements---and cook them until the ``connective tissue'' breaks down. This yields a finite alphabet~$A$ where each \index{symbol!in requirement machine}symbol is one of the three kinds below:
\begin{center}
\begin{tabular}{lll}
\toprule
$\ttgp{d}{i}$ & \index{generic parameter symbol}Generic parameter symbol& for some $d$, $i\in\NN$\\
\texttt{A} & \index{name symbol}Name symbol& for some identifier \texttt{A}\\
$\pP$ & \index{protocol symbol}Protocol symbol& for some \tP\ such that $G\prec\tP$\\
\bottomrule
\end{tabular}
\end{center}

To get~$R$, we define a ``$\Term$'' function to translate a type parameter of~$G$ into a \index{term!in requirement machine}term, and a ``$\Rule$'' function to translate each \index{explicit requirement}explicit requirement of~$G$ into a \index{rewrite rule!in requirement machine}rewrite rule:
\begin{center}
\begin{tabular}{l@{ $:=$ }l}
\toprule
$\Term(\ttgp{d}{i})$&$\ttgp{d}{i}$\\
$\Term(\texttt{U.A})$&$\Term(\tU)\cdot\texttt{A}$\\
\bottomrule
\end{tabular}
\qquad
\begin{tabular}{l@{ $:=$ }l}
\toprule
\index{conformance requirement!in requirement machine}$\Rule\, \TP$&$\Term(\tT)\cdot\pP\sim\Term(\tT)$\\
\index{same-type requirement!in requirement machine}$\Rule\, \TU$&$\Term(\tT)\sim\Term(\tU)$\\
\bottomrule
\end{tabular}
\end{center}
In addition, for each protocol \tP\ such that $G\prec\tP$, we define a ``$\TermP{P}$'' function to translate a \index{protocol generic signature!in requirement machine}type parameter of~$\GP$ into a term starting with $\pP$, and a ``$\RuleP{P}$'' function to translate each \index{associated requirement!in requirement machine}associated requirement of \tP\ into a rewrite rule, in a manner analogous to ``$\Rule$'':
\begin{center}
\begin{tabular}{l@{ $:=$ }l}
\toprule
$\TermP{P}(\tSelf)$&$\pP$\\
$\TermP{P}(\texttt{V.A})$&$\TermP{P}(\tV)\cdot\texttt{A}$\\
\bottomrule
\end{tabular}
\qquad
\begin{tabular}{l@{ $:=$ }l}
\toprule
\index{associated conformance requirement!in requirement machine}$\RuleP{P}\, \ConfReq{U}{Q}_\tP$&$\TermP{P}(\tU)\cdot\pQ\sim\TermP{P}(\tU)$\\
\index{associated same-type requirement!in requirement machine}$\RuleP{P}\, \SameReq{U}{V}_\tP$&$\TermP{P}(\tU)\sim\TermP{P}(\tV)$\\
\bottomrule
\end{tabular}
\end{center}
This completely describes a very remarkable object, where the \emph{derived requirements} of~$G$ are \emph{rewrite paths} in the requirement machine for~$G$.

\begin{example}\label{rqm first example}
Let $G$ be the generic signature below:
\begin{quote}
\begin{verbatim}
<τ_0_0, τ_0_1 where τ_0_0: Sequence, τ_0_1: Sequence,
                    τ_0_0.Element: Equatable,
                    τ_0_0.Element == τ_0_1.Element>
\end{verbatim}
\end{quote}
We met this signature in \ExRef{motivating derived reqs} and then studied it in \SecRef{derived req} and \SecRef{type params}. We will now construct its requirement machine.

Our generic signature depends on \texttt{Sequence} and \texttt{IteratorProtocol}. Both declare an associated type named ``\texttt{Element}'', and \texttt{Sequence} also declares an associated type named ``\texttt{Iterator}''. Our alphabet has six symbols---two of each kind:
\[ A := \{ \underbrace{\mathstrut\rT,\, \rU}_{\text{generic param}},\, \underbrace{\mathstrut\nElement,\, \nIterator}_{\text{name}},\, \underbrace{\mathstrut\pSequence,\, \pIterator}_{\text{protocol}} \} \]

Here are the requirements of $G$ and \texttt{Sequence} that will define our rewrite rules:
\begin{gather*}
\ConfReq{\rT}{Sequence}\\
\ConfReq{\rU}{Sequence}\\
\ConfReq{\rT.Element}{Equatable}\\
\SameReq{\rT.Element}{\rU.Element}\\[\medskipamount]
\AssocConfReq{Self.Iterator}{IteratorProtocol}{Sequence}\\
\AssocSameReq{Self.Element}{Self.Iterator.Element}{Sequence}
\end{gather*}
We build our set of rewrite rules~$R$ by applying ``$\Rule$'' or ``$\RuleP{P}$'' to each requirement:
\begin{gather*}
\ConfRule{\rT}{\pSequence} \tag{1} \\
\ConfRule{\rU}{\pSequence} \tag{2} \\
\ConfRule{\rT\cdot\nElement}{\protosym{Equatable}} \tag{3} \\
\SameRule{\rT\cdot\nElement}{\rU\cdot\nElement}\tag{4} \\[\medskipamount]
\ConfRule{\pSequence\cdot\nIterator}{\pIterator} \tag{5} \\
\SameRule{\pSequence\cdot\nElement}{\pSequence\cdot\nIterator\cdot\nElement} \tag{6}
\end{gather*}

Note that ``$\Term$'' is just a flattening of the linked list structure of a type parameter into an array; the resulting term is a generic parameter symbol followed by zero or more name symbols. To distinguish the two representations, we separate the components of a type parameter with ``\texttt{.}'' as before, while terms join their symbols with the requirement machine \index{$\cdot$}\index{binary operation!in requirement machine}monoid operation ``\;$\cdot$\;''. The protocol variants ``$\TermP{P}$'' and ``$\RuleP{P}$'' are needed to encode the original protocol of each associated requirement. This is why ``$\TermP{P}$'' replaces \IndexSelf\tSelf\ with the protocol symbol $\pP$ instead of the generic parameter symbol~\rT.

One more remark. Name symbols and protocol symbols exist in different namespaces, so even if we renamed \texttt{IteratorProtocol} to \texttt{Iterator}, the name symbol \texttt{Iterator} would remain distinct from the protocol symbol $\protosym{Iterator}$. On the other hand, two associated types with the same name in different protocols always define the \emph{same} name symbol.

Now, let's continue with our example and think about the \index{term equivalence relation!in requirement machine}equivalence relation these rewrite rules generate. Notice how there is a certain symmetry behind the appearance of protocol symbols. The conformance requirements (1), (2), (3) and (5) rewrite a term that \emph{ends} in a protocol symbol. The associated requirements (5) and (6) rewrite a term that \emph{begins} with a protocol symbol. (The associated conformance requirement (5) is both; its left-hand side begins and ends with a protocol symbol.)

We know that $G\vdash\SameReq{\rT.Iterator.Element}{\rU.Iterator.Element}$ from \ExRef{derived equiv example}, even though this requirement is not explicitly stated. Applied to this requirement, ``$\Rule$'' outputs this ordered pair of terms:
\[ (\rT\cdot\nIterator\cdot\nElement,\, \rU\cdot\nIterator\cdot\nElement) \]
Again, this is not an explicit requirement, so this is not one of the rules in~$R$. However, there is a rewrite path from the first term to the second; they're equivalent via $\sim_R$:
\begin{gather*}
(\rT\Rightarrow\rT\cdot\pSequence)\WR\nIterator\cdot\nElement\\
{} \circ \rT\WL(\pSequence\cdot\nIterator\cdot\nElement\Rightarrow\pSequence\cdot\nElement)\\
{} \circ (\rT\cdot\pSequence\Rightarrow\rT)\WR\nElement\\
{} \circ (\rT\cdot\nElement\Rightarrow\rU\cdot\nElement)\\
{} \circ (\rU\Rightarrow\rU\cdot\pSequence)\WR\nElement\\
{} \circ \rU\WL(\pSequence\cdot\nElement\Rightarrow\pSequence\cdot\nIterator\cdot\nElement)\\
{} \circ (\rU\cdot\pSequence\Rightarrow\rU)\WR\nIterator\cdot\nElement
\end{gather*}
We can also understand this by writing down the intermediate terms between every consecutive pair of rewrite steps. We use conformance requirements to insert and delete protocol symbols before and after invoking our associated same-type requirement:
\begin{gather*}
\rT\cdot\nIterator\cdot\nElement\\
{} \sim \rT\cdot\pSequence\cdot\nIterator\cdot\nElement\\
{} \sim \rT\cdot\pSequence\cdot\nElement\\
{} \sim \rT\cdot\nElement\\
{} \sim \rU\cdot\nElement\\
{} \sim \rU\cdot\pSequence\cdot\nElement\\
{} \sim \rU\cdot\pSequence\cdot\nIterator\cdot\nElement\\
{} \sim \rU\cdot\nIterator\cdot\nElement
\end{gather*}

Now let's try with $G\vdash\ConfReq{\rT.Iterator}{IteratorProtocol}$. We apply ``$\Rule$'' to get an ordered pair of terms:
\[
(\rT\cdot\nIterator\cdot\pIterator,\,\rT\cdot\nIterator)
\]
To prove this equivalence, we make use of the conformance requirement~(1), and then the associated conformance requirement~(5):
\begin{gather*}
(\rT\Rightarrow\rT\cdot\pSequence)\WR\nIterator\cdot\pIterator\\
{} \circ \rT\WL(\pSequence\cdot\nIterator\cdot\pIterator\!\Rightarrow\!\pSequence\cdot\nIterator)\\
{} \circ (\rT\cdot\pSequence\Rightarrow\rT)\WR\nIterator
\end{gather*}
Once again, we can show the intermediate terms in our path:
\begin{gather*}
\rT\cdot\nIterator\cdot\pIterator\\
{} \sim \rT\cdot\pSequence\cdot\nIterator\cdot\pIterator\\
{} \sim \rT\cdot\pSequence\cdot\nIterator\\
{} \sim \rT\cdot\nIterator
\end{gather*}
\end{example}

\section{Correctness}

We saw some examples of encoding derived requirements as word problems. We now make this precise. We prove two theorems, to establish that we can translate derivations into rewrite paths, and vice versa. We use the algebra of rewriting from \SecRef{rewrite graph}.

We begin with a preliminary result. In \SecRef{derived req}, we defined the \IndexStep{AssocConf}\textsc{AssocConf} and \IndexStep{AssocConf}\textsc{AssocSame} inference rules via formal substitution: if \tT\ is some type parameter of~$G$ known to conform to some protocol~\tP, and \texttt{Self.U} is some type parameter of~$\GP$, then \texttt{T.U} denotes the replacement of \tSelf\ with \tT\ in \texttt{Self.U}. We can relate this to the requirement machine \index{monoid operation!in requirement machine}monoid operation.

\begin{lemma}\label{type param composition lemma}
Let $G$ be a generic signature, and let $\AR$ be the requirement machine for~$G$. Further, suppose that:
\begin{enumerate}
\item \tT\ is some type parameter of~$G$,
\item \tP\ is some protocol, and $\Term(\tT)\cdot\pP\sim\Term(\tT)$,
\item \texttt{Self.U} is some type parameter of~$\GP$. 
\end{enumerate}
Then $\Term(\tT)\cdot\TermP{P}(\texttt{Self.U}) \sim \Term(\texttt{T.U})$.
\end{lemma}
\begin{proof}
Note that $\TermP{P}(\texttt{Self.U})=\pP\cdot u$ for some $u\in A^*$, by definition of ``$\TermP{P}$''. We also let $t := \Term(\texttt{T})$, so that $\Term(\texttt{T.U})=t\cdot u$. Now, if $p$ is a rewrite path from $t\cdot\pP$~to~$t$, then $p\WR u$ is a rewrite path from $t\cdot\pP\cdot u$~to~$t\cdot u$.
\end{proof}

\begin{example}
In \ExRef{rqm first example}, we can see the second rewrite path in a new way:
\begin{gather*}
\Term(\texttt{\rT.Iterator})\cdot\pIterator\\
{} \sim \Term(\rT) \cdot \TermP{Sequence}(\texttt{Self.Iterator}) \cdot \pIterator\\
{} \sim \Term(\rT) \cdot \TermP{Sequence}(\texttt{Self.Iterator})\\
{} \sim \Term(\texttt{\rT.Iterator})
\end{gather*}
\end{example}

This idea of ``cleaving'' a term in two will be key in the inductive step of the below proof, when we consider the \textsc{AssocConf} and \textsc{AssocSame} inference rules.

\newcommand{\Path}{\mathsf{path}\,}

\begin{theorem}\label{derivation to path swift}
Let $G$ be a generic signature, and let $\AR$ be the requirement machine for~$G$.
\begin{enumerate}
\item If $G\vdash\TP$ for some type parameter \tT\ and protocol \tP, then $\Term(\tT)\cdot\pP \sim \Term(\tT)$.
\item If $G\vdash\TU$ for some pair of type parameters \tT\ and \tU, then $\Term(\tT) \sim \Term(\tU)$.
\end{enumerate}
\end{theorem}

\begin{proof}
We use \index{structural induction}structural induction on \index{derived requirement}derived requirements (\SecRef{generic signature validity}) to define a ``$\mathsf{path}$'' mapping that assigns to each derived requirement $G\vdash D$ a rewrite path~$p$ such that $\Rule(D)=(\Src(p),\,\Dst(p))$. The conclusion then follows.

\BaseCase To handle the \index{elementary statement}elementary statements, and those inference rules that do not have any requirements among their assumptions, we construct a rewrite path directly.

A \IndexStep{Conf}\textsc{Conf} step invokes an explicit conformance requirement of~$G$:
\[\ConfStepDef\]
Note that $\Rule\,\TP=(\Term(\tT)\cdot\pP,\,\Term(\tT))\in R$. The path is a single rewrite step:
\[\Path \TP := (\Term(\tT)\cdot\pP \Rightarrow \Term(\tT))\]

A \IndexStep{Same}\textsc{Same} step invokes an explicit same-type requirement of~$G$:
\[\SameStepDef\]
Note that $\Rule\,\TU=(\Term(\tT),\,\Term(\tU))\in R$. The path is a single rewrite step:
\[\Path \TU := (\Term(\tT) \Rightarrow \Term(\tU))\]

A \IndexStep{Reflex}\textsc{Reflex} step derives a trivial same-type requirement from a valid type parameter:
\[\ReflexStepDef\]
We don't need the fact that $G\vdash\tT$ at all, because in a finitely-presented monoid, every term is already equivalent to itself via the empty rewrite path, so we let $t := \Term(\tT)$, and we set:
\[\Path \SameReq{T}{T} := 1_t\]

\InductiveStep In each case, the ``$\mathsf{path}$'' of the conclusion is defined from the ``$\mathsf{path}$'' of the step's assumptions. For an \IndexStep{AssocConf}\textsc{AssocConf} step, the induction hypothesis gives us $p_1 := \Path\TP$, so $\Src(p_1)=\Term(\tT)\cdot\pP$ and $\Dst(p_1)=\Term(\tT)$:
\[\AssocConfStepDef\]
Note that $\RuleP{P}\,\AssocConfReq{Self.U}{Q}{P}\in R$ is of the form $(\pP\cdot u\cdot\pQ,\,\pP\cdot u)$ for some $u\in A^*$. Using \LemmaRef{type param composition lemma}, we insert a~$\pP$ in the right spot, apply our associated requirement, and then delete the~$\pP$. We let $t := \Term(\tT)$, let $s := (\pP \cdot u \cdot \pQ \Rightarrow \pP \cdot u)$, and we set:
\[
\Path \ConfReq{T.U}{Q} := (p_1^{-1} \WR u \WR \pQ)
\circ
(t \WL s)
\circ
(p_1 \WR u)
\]

For an \IndexStep{AssocSame}\textsc{AssocSame} step, the induction hypothesis gives us $p_1 := \Path \TP$:
\[\AssocSameStepDef\]
Note that $\RuleP{P}\,\AssocSameReq{Self.U}{Self.V}{P}\in R$ is of the form $(\pP\cdot u,\,\pP\cdot v)$ for some $u$, $v\in A^*$. Again, we use \LemmaRef{type param composition lemma}. We let $t := \Term(\tT)$, let $s := (\pP \cdot u \Rightarrow \pP \cdot v)$, and we set:
\[
\Path \SameReq{T.U}{T.V} := (p_1^{-1} \WR u)
\circ
(t \WL s)
\circ
(p_1 \WR v)
\]

For a \IndexStep{Sym}\textsc{Sym} or \IndexStep{Trans}\textsc{Trans} step, we use the \index{rewrite rewrite path!in requirement machine}rewrite path inverse and \index{rewrite path composition!in requirement machine}composition operations:
\begin{gather*}
\SymStepDef\\
\TransStepDef\\[\medskipamount]
\Path\SameReq{U}{T} := \Path\TU^{-1}\\
\Path\SameReq{T}{V} := \Path\TU \circ \Path\SameReq{U}{V}
\end{gather*}

For a \IndexStep{SameConf}\textsc{SameConf} step, the induction hypothesis gives us a pair of rewrite paths $p_1 := \Path \ConfReq{U}{P}$, and $p_2 := \Path \TU$:
\[\SameConfStepDef\]
We rewrite $\Term(\tT)\cdot\pP$ into $\Term(\tU)\cdot\pP$ using $p_2$, delete $\pP$ from the end of the term using $p_1$, and rewrite $\Term(\tU)$ back to $\Term(\tT)$ using $p_2$ again:
\[
\Path \TP := (p_2 \WR \pP) \circ p_1 \circ p_2^{-1}
\]

For a \IndexStep{SameName}\textsc{SameName} step, the induction hypothesis gives us $p_1 := \Path \ConfReq{U}{P}$, and $p_2 := \TU$:
\[\SameNameStepDef\]
We only need $p_2$ to construct our new rewrite path, by \index{rewrite path whiskering!in requirement machine}whiskering:
\[
\Path\SameReq{T.A}{U.A} := p_2 \WR \nA
\]

By induction, this completely defines ``$\mathsf{path}$'', so we apply it to our original requirement and get the desired result. \FigRef{derivation to path figure} \index{rewrite graph!in requirement machine}shows each rewrite path we constructed.
\end{proof}

\begin{figure}\captionabove{Rewrite paths defined by \ThmRef{derivation to path swift}, as paths in the rewrite graph}\label{derivation to path figure}
\centering

\begin{tabular}{cc}
\toprule
&{\textsc{Conf:}}\\
$\TP$&
\begin{tikzcd}
\Term(\tT)\cdot\pP \arrow [r, Rightarrow]
&
\Term(\tT)
\end{tikzcd}\\
\midrule
&{\textsc{Same:}}\\
$\TU$&
\begin{tikzcd}
\Term(\tT) \arrow [r, Rightarrow]
&
\Term(\tU)
\end{tikzcd}\\
\midrule
&{\textsc{Reflex:}}\\
$\SameReq{T}{T}$&
\begin{tikzcd}
\Term(\tT)
\end{tikzcd}\\
\midrule
&{\textsc{AssocConf:}}\\
$\ConfReq{T.U}{Q}$&
\begin{tikzcd}
\Term(\texttt{T.U})\cdot\pQ \arrow [rr, Rightarrow, "\cdots" description]
&&
\Term(\tT) \cdot \TermP{P}(\texttt{Self.U}) \cdot \pQ \arrow [d, Rightarrow]
\\
\Term(\texttt{T.U})
&&
\Term(\tT) \cdot \TermP{P}(\texttt{Self.U}) \arrow [ll, Rightarrow, "\cdots" description]
\end{tikzcd}
\\
\midrule
&{\textsc{AssocSame:}}\\
$\SameReq{T.U}{T.V}$&
\begin{tikzcd}
\Term(\texttt{T.U}) \arrow [rr, Rightarrow, "\cdots" description]
&&
\Term(\tT) \cdot \TermP{P}(\texttt{Self.U}) \arrow [d, Rightarrow]
\\
\Term(\texttt{T.V})
&&
\Term(\tT) \cdot \TermP{P}(\texttt{Self.V}) \arrow [ll, Rightarrow, "\cdots" description]
\end{tikzcd}\\
\midrule
&{\textsc{Sym:}}\\
$\SameReq{U}{T}$&
\begin{tikzcd}
\Term(\tT)
&&
\Term(\tU) \arrow [ll, Rightarrow, "\cdots" description]
\end{tikzcd}\\
\midrule
&{\textsc{Trans:}}\\
$\SameReq{T}{V}$&
\begin{tikzcd}
\Term(\tT) \arrow [rr, Rightarrow, "\cdots" description]
&&
\Term(\tU) \arrow [rr, Rightarrow, "\cdots" description]
&&
\Term(\tV)
\end{tikzcd}\\
\midrule
&{\textsc{SameConf:}}\\
$\TP$&
\begin{tikzcd}
\Term(\tT) \cdot \pP \arrow [rr, Rightarrow, "\cdots" description]
&&
\Term(\tU) \cdot \pP \arrow [dd, Rightarrow, "\cdots" description]
\\\\
\Term(\tT)
&&
\Term(\tU) \arrow [ll, Rightarrow, "\cdots" description]
\end{tikzcd}\\
\midrule
&{\textsc{SameName:}}\\
$\SameReq{T.A}{U.A}$&\begin{tikzcd}
\Term(\tT) \cdot \nA \arrow [rr, Rightarrow, "\cdots" description]
&&
\Term(\tU) \cdot \nA
\end{tikzcd}\\
\bottomrule
\end{tabular}
\end{figure}

We now go in the other direction, and describe how rewrite paths in the requirement machine define derived requirements in our generic signature. Consider how we might reverse our ``$\mathsf{path}$'' mapping. The main difficulty to overcome is the fact that we did not actually use every assumption in each step:
\begin{enumerate}
\item The ``$\mathsf{path}$'' of a $\textsc{Reflex}$ step $\SameReq{T}{T}$ disregards the proof of the validity of the type parameter~\tT, because in the monoid, we can immediately construct an \index{empty rewrite path}empty rewrite path for \emph{any} term.

However, this means that if we start from the empty rewrite path at a ``nonsensical'' term, such as $\nA \cdot \rU \cdot \pSequence \cdot \rT$, we cannot ``go backwards'' and hope to prove the validity of any type parameter in~$G$.

\item The ``$\mathsf{path}$'' of a \textsc{SameName} step $\SameReq{T.A}{U.A}$ is defined from $\Path \TU$ by whiskering, ignoring $\Path \TP$, because we can \index{rewrite path whiskering}whisker \emph{any} rewrite path.

That is, if we have an equivalent pair of terms $\Term(\tT) \sim \Term(\tU)$, and \nA\ is any name symbol, it is \emph{always} the case that $\Term(\tT)\cdot \nA \sim \Term(\tU)\cdot \nA$ in the monoid. 

However, we may not be able to derive $G\vdash\SameReq{T.A}{U.A}$, because \tT\ might not conform any protocol with an associated type named ``\nA''. By the same reasoning, we might not even be able to derive $G\vdash\TU$.
\end{enumerate}

Thus, not every equivalence class of $\sim_R$ corresponds to a \index{valid type parameter!in requirement machine}valid type parameter of our generic signature~$G$. Before we can see how to translate a specific rewrite path into a derivation, we need to understand which rewrite paths are meaningful to us. We begin by describing the equivalence class of $\Term(\tT)$ for a type parameter~\tT.

\begin{definition}
Let $t\in A^*$ be a term.
\begin{itemize}
\item If the first symbol of~$t$ is a \index{generic parameter symbol}generic parameter symbol and all subsequent symbols are \index{name symbol}name symbols, then we say that $t$~is a \emph{standard} term.

\item If the first symbol of~$t$ is a generic parameter symbol and all subsequent symbols are either \index{name symbol}name or \index{protocol symbol}protocol symbols, we say that $t$~is an \emph{admissible} term.
\end{itemize}
\end{definition}

\begin{lemma}
Some consequences of the above:
\begin{enumerate}
\item Every standard term is $\Term(\tT)$ for some \index{unbound type parameter}unbound type parameter~\tT.
\item Every standard term is an admissible term.
\item If $(u,v)$ is a rewrite rule output by ``$\Rule$'', both $u$ and $v$ are admissible terms.
\item If $t\in A^*$ is an admissible term and $u\in A^*$ is a combination of name and protocol symbols (possibly empty), then $tu$ is an admissible term.
\end{enumerate}
\end{lemma}

The next lemma states that admissibility is preserved by rewriting. In particular, this means that rewriting a standard term always outputs an admissible term.
\begin{lemma}\label{rewriting admissible term}
Let $G$ be a generic signature, and let $\AR$ be the requirement machine for $G$. Let $t\in A^*$ be an admissible term. If $t\sim z$ for some other term $z\in A^*$, then $z$ is an admissible term.
\end{lemma}
\begin{proof}
Let $p$ be a rewrite path from $t$ to $z$. We argue by \index{induction}induction on the length of~$p$.

\BaseCase If we have an empty rewrite path, then $t=z$, so $z$ is an admissible term.

\InductiveStep Otherwise, $p=p^\prime \circ s$ for some rewrite path $p^\prime$ and rewrite step~$s$. We write $s := x(u\Rightarrow v)y$, where $x$, $y\in A^*$, and one of $(u,v)$ or $(v,u)\in R$.

By the induction hypothesis, $\Dst(p^\prime)=\Src(s)=xuy$ is an admissible term. Because the prefix $xu$ is non-empty, the right whisker $y$ contains only name and protocol symbols.

If the rule applied by $s$ is the ``$\Rule$'' for an explicit requirement, then the left \index{whiskering}whisker~$x$ is empty, because $u$ starts with a generic parameter symbol. Furthermore, $v$ is an admissible term. We see that $\Dst(s)=vy$ is an admissible term.

If this rule applied by $s$ is the ``$\RuleP{P}$'' for an associated requirement, then the left whisker~$x$ is non-empty, and furthermore an admissible term, and $u$ and $v$ must contain only name and protocol symbols. We see that $\Dst(s)=xvy$ is an admissible term.
\end{proof}

\newcommand{\Chart}{\mathsf{chart}}

Just like a standard term describes an \index{unbound type parameter}unbound type parameter, an admissible term more generally describes a type parameter and \textsl{a list of conformance requirements}.

\begin{definition}
The ``$\Type$'' function maps each admissible term to an unbound type parameter, by ignoring protocol symbols, and translating generic parameter symbols and name symbols into generic parameter types and dependent member types:
\[
\begin{array}{l@{\ :=\ }l}
\Type(\ttgp{d}{i})&\ttgp{d}{i} \\
\Type(\tU \cdot \nA)&\Type(\tU)\texttt{.A} \\ 
\Type(\tU \cdot \pP)&\Type(\tU) 
\end{array}
\]
\end{definition}

\begin{definition}
Let $z\in A^*$ be an admissible term. The \emph{conformance chart} of~$z$ is a \index{multiset}\emph{multiset} (that is, we allow duplicates) of conformance requirements:
\begin{enumerate}
\item Each requirement corresponds to an occurrence of a protocol symbol in~$z$.

\item The subject type of each requirement is the prefix before the protocol symbol.

\item Duplicate elements represent identical consecutive protocol symbols.
\end{enumerate}
\end{definition}

\begin{definition}
The ``$\Chart$'' function maps each admissible term to its conformance chart, by ignoring generic parameter and name symbols, and converting protocol symbols into requirements:
\[
\begin{array}{l@{\ :=\ }l}
\Chart(\ttgp{d}{i})&\{\}\\
\Chart(\tU \cdot \nA)&\Chart(\tU)\\
\Chart(\tU \cdot \pP)&\Chart(\tU) \cup \{ \ConfReq{$\Type(\tU)$}{P} \}
\end{array}
\]
\end{definition}

\begin{example}
If $z=\Term(\tT)$ is a standard term:
\begin{gather*}
\Type(z)=\tT\\
\Chart(z)=\{\}
\end{gather*}
If $z=\Term(\tT)\cdot\pP$ for some unbound type parameter \tT\ and protocol \pP:
\begin{gather*}
\Type(z)=\tT\\
\Chart(z)=\{\TP\}
\end{gather*}
If $z=\rU \cdot \pSequence \cdot \pSequence \cdot \nIterator \cdot \pIterator$,
\begin{gather*}
\Type(z) = \texttt{\rU.Iterator},\\
\Chart(z) = \{\ConfReq{\rU}{Sequence},\\
\phantom{\Chart(z) = \{}\ConfReq{\rU}{Sequence},\\
\phantom{\Chart(z) = \{}\ConfReq{\rU.Iterator}{IteratorProtocol}\}.
\end{gather*}
\end{example}

We can say a lot more if we add the assumptions that \tT\ is a \emph{valid} type parameter, and our generic signature $G$ is well-formed. (We lose nothing by doing this, because otherwise we diagnose an error and reject the program; see \SecRef{generic signature validity}). Having done so, we see that rewriting a standard term into an admissible term is tantamount to simultaneously deriving a same-type requirement \textsl{together with every conformance requirement in the destination term's chart}.

\begin{theorem}\label{type chart theorem}
Let $G$ be a well-formed generic signature, let $\AR$ be the requirement machine for~$G$, and let $t$ be a standard term such that $\Type(t)$ is a \index{valid type parameter!in requirement machine}valid type parameter of~$G$. Suppose we are given a term $z\in A^*$ such that $t \sim z$. Then $z$ is an admissible term, and furthermore:
\begin{enumerate}
\item $G \vdash \SameReq{$\Type(t)$}{$\Type(z)$}$.
\item $G \vdash \ConfReq{$\Type(u)$}{P}$ for each $\ConfReq{$\Type(u)$}{P}\in\Chart(z)$.
\end{enumerate}
\end{theorem}

\newcommand{\Case}[1]{\smallskip\par($\bigstar$ Case #1.)}

\begin{proof}
\LemmaRef{rewriting admissible term} already shows that $z$ is an admissible term. To establish the principal conclusion, we reason as follows:
\begin{enumerate}
\item Because we started with a standard term, we know that every protocol symbol appearing in~$z$ must have been introduced by some rewrite step in our path.

When a rewrite step introduces a protocol symbol, we must be able to derive this conformance requirement, and record it alongside our chart.

\item The other rewrite steps apply same-type requirements, and we must be able to build a derived same-type requirement corresponding to this transformation.

We must also understand the effect that same-type requirement rules have on the conformance chart, so that we can update our collected set of derived conformance requirements when needed.
\end{enumerate}
Let~$p$ be a rewrite path from $t$ to $z$. We argue by induction on the length of~$p$.

\BaseCase If $p$ is empty, then $t=z$, so $\Type(t)=\Type(z)$, and $\Chart(z)=\{\}$.
We use the assumption that $\Type(t)$ is a valid type parameter to derive the same-type requirement $\SameReq{$\Type(t)$}{$\Type(t)$}$, by applying the \IndexStep{Reflex}\textsc{Reflex} inference rule to a derivation of $G\vdash\Type(t)$. We do not need to derive any conformance requirements.

\InductiveStep Otherwise, $p=p^\prime \circ s$ for some rewrite path $p^\prime$ and rewrite step~$s$. Let $z^\prime := \Dst(p^\prime) = \Src(s)$, and note that $z=\Dst(s)$. By the induction hypothesis:
\begin{enumerate}
\item $G \vdash \SameReq{$\Type(t)$}{$\Type(z^\prime)$}$.
\item $G \vdash \ConfReq{$\Type(u^\prime)$}{P}$ for each $\ConfReq{$\Type(u^\prime)$}{P}\in\Chart(z^\prime)$.
\end{enumerate}
The rewrite step~$s$ applies a conformance or same-type requirement; this requirement is explicit (``$\Rule$'') or associated (``$\RuleP{P}$''); and the rewrite step may be \index{positive rewrite step}positive or \index{negative rewrite step}negative. We consider each case to derive the desired conclusion about~$z$:
\begin{center}
\begin{tabular}{lllcl}
\toprule
&\textbf{Kind:}&\textbf{Domain:}&\textbf{Sign:}&\textbf{General Form:}\\
\midrule
1.&conformance&explicit&$+$&$(u\cdot\pP\Rightarrow u)\WR y$\\
2.&&explicit&$-$&$(u\Rightarrow u\cdot\pP)\WR y$\\
3.&&associated&$+$&$x\WL(\pP\cdot u\cdot\pQ\Rightarrow\pP\cdot u)\WR y$\\
4.&&associated&$-$&$x\WL(\pP\cdot u\Rightarrow\pP\cdot u\cdot\pQ)\WR y$\\
\midrule
5.&same-type&explicit&$+$&$(u\Rightarrow v)\WR y$\\
6.&&explicit&$-$&$(v\Rightarrow u)\WR y$\\
7.&&associated&$+$&$x\WL(\pP\cdot u\Rightarrow\pP\cdot v)\WR y$\\
8.&&associated&$-$&$x\WL(\pP\cdot v\Rightarrow\pP\cdot u)\WR y$\\
\bottomrule
\end{tabular}
\end{center}

\Case{1} A positive rewrite step for an explicit \index{conformance requirement!in requirement machine}conformance requirement has the following general form, where the left whisker is empty, $(u\cdot\pP,u)\in R$ for some standard term~$u$ and protocol symbol~\pP, and the right whisker $y$~is a combination of name and protocol symbols:
\[(u\cdot\pP\Rightarrow u)\WR y\]
The rewrite step deletes an occurrence of the protocol symbol~$\pP$:
\begin{gather*}
z^\prime=\Src(s)=u\cdot\pP\cdot y\\
z=\Dst(s)=u\cdot y\\[\medskipamount]
\Type(z)=\Type(z^\prime)\\
\Chart(z)=\Chart(z^\prime) \setminus \{\ConfReq{$\Type(u)$}{P}\}
\end{gather*}
Therefore our conclusion already holds; we just ``discard'' our derivation of $\ConfReq{$\Type(u)$}{P}$.

\Case{2} A negative rewrite step for an explicit conformance requirement has the following general form, where again the left whisker is empty, $(u\cdot\pP,u)\in R$ for some standard term~$u$ and protocol symbol~\pP, and the right whisker~$y$ is as before:
\[(u\Rightarrow u\cdot\pP)\WR y\]
The rewrite step inserts an occurrence of the protocol symbol~$\pP$:
\begin{gather*}
z^\prime=\Src(s)=u\cdot y\\
z=\Dst(s)=u\cdot\pP\cdot y\\[\medskipamount]
\Type(z)=\Type(z^\prime)\\
\Chart(z)=\Chart(z^\prime) \cup \{\ConfReq{$\Type(u)$}{P}\}
\end{gather*}
To establish the conclusion, we must derive $\ConfReq{$\Type(u)$}{P}$. We do this with a \IndexStep{Conf}\textsc{Conf} elementary statement, because $\Rule\,\ConfReq{$\Type(u)$}{P}=(u\cdot\pP,u)\in R$:
\[
\ConfStep{$\Type(u)$}{P}{1}
\]

\Case{3} A positive rewrite step for an \index{associated conformance requirement!in requirement machine}associated conformance requirement has the following general form, where $x$ is an admissible term, $(\pP\cdot u\cdot\pQ,\pP\cdot u)\in R$ for some~$u$ that contains only name symbols, and the right whisker~$y$ is as before:
\[x\WL(\pP\cdot u\cdot\pQ\Rightarrow\pP\cdot u)\WR y\]
The rewrite step deletes a protocol symbol~$\pQ$. Note that $\Type(x\cdot \pP \cdot u)=\Type(x\cdot u)$:
\begin{gather*}
z^\prime=\Src(s)=x\cdot\pP\cdot u\cdot\pQ\cdot y\\
z=\Dst(s)=x\cdot\pP\cdot u\cdot y\\[\medskipamount]
\Type(z)=\Type(z^\prime)\\
\Chart(z)=\Chart(z^\prime) \setminus \{\ConfReq{$\Type(x\cdot u)$}{Q}\}
\end{gather*}
As in Case~1, we ``discard'' our prior derivation of $\ConfReq{$\Type(x\cdot u)$}{Q}$.

\Case{4} A negative rewrite step for an associated conformance requirement has the following general form, where $x$ is an admissible term, $(\pP\cdot u,\pP\cdot u\cdot \pQ)\in R$ for some~$u$ that contains only name symbols, and the right whisker~$y$ is as before:
\[x\WL (\pP\cdot u\Rightarrow\pP\cdot u\cdot\pQ)\WR y\]
The rewrite step inserts a protocol symbol~$\pQ$. Again, $\Type(x\cdot \pP \cdot u)=\Type(x\cdot u)$:
\begin{gather*}
z^\prime=\Src(s)=x\cdot\pP\cdot u\cdot y\\
z=\Dst(s)=x\cdot\pP\cdot u\cdot\pQ\cdot y\\[\medskipamount]
\Type(z)=\Type(z^\prime)\\
\Chart(z)=\Chart(z^\prime) \cup \{\ConfReq{$\Type(x\cdot u)$}{Q}\}
\end{gather*}
We must derive $\ConfReq{$\Type(x\cdot u)$}{Q}$. Since $\ConfReq{$\Type(x)$}{P}\in\Chart(z^\prime)$, the induction hypothesis tells us that $G\vdash\ConfReq{$\Type(x)$}{P}$, and the \IndexStep{AssocConf}\textsc{AssocConf} inference rule then gives us:
\begin{gather*}
\AnyStep{\ConfReq{$\Type(x)$}{P}}{1}\\
\AssocConfStep{1}{$\Type(x\cdot u)$}{Q}{2}
\end{gather*}

\Case{5} A positive rewrite step for an explicit \index{same-type requirement!in requirement machine}same-type requirement has the following general form, where the left whisker is empty, $(u,v)\in R$ for standard terms $u$~and~$v$, and the right whisker $y$ is a combination of name and protocol symbols:
\[(u\Rightarrow v)\WR y\]
The rewrite step replaces the prefix $u$ with $v$:
\begin{gather*}
z^\prime=\Src(s)=u\cdot y\\
z=\Dst(s)=v\cdot y
\end{gather*}
In this case, $\Type(z)$ and $\Type(z^\prime)$ are not identical, so we must first derive the same-type requirement $G\vdash\SameReq{$\Type(t)$}{$\Type(z)$}$. We now write $u\cdot y$ instead of $z^\prime$, so the induction hypothesis gave us this same-type requirement:
\[ \AnyStep{\SameReq{$\Type(u\cdot y)$}{$\Type(v\cdot y)$}}{1} \]
We now use the assumption that $G$ is well-formed. Because $\Type(u\cdot y)$ appears in the above requirement, the well-formedness of $G$ allows us to derive $G\vdash\Type(u\cdot y)$:
\[ \AnyStep{\Type(u\cdot y)}{2} \]
Next, we derive $\SameReq{$\Type(u)$}{$\Type(v)$}$ with a \IndexStep{Same}\textsc{Same} elementary statement:
\[ \SameStep{$\Type(u)$}{$\Type(v)$}{3} \]
Furthermore, $\Type(u)$ is a prefix of $\Type(u\cdot y)$. We apply \LemmaRef{general member type} to $G\vdash\texttt{$\Type(u\cdot y)$}$ and $G\vdash\SameReq{$\Type(u)$}{$\Type(v)$}$ to derive $G\vdash\SameReq{$\Type(u\cdot y)$}{$\Type(v\cdot y)$}$, or in other words, $\SameReq{$\Type(z^\prime)$}{$\Type(z)$}$:
\[
\AnyStep{\SameReq{$\Type(z^\prime)$}{$\Type(z)$}}{4}
\]
Finally, we apply the \IndexStep{Trans}\textsc{Trans} inference rule to compose the above requirement with the same-type requirement given to us by the induction hypothesis:
\[
\TransStep{1}{4}{$\Type(t)$}{$\Type(z)$}{5}
\]
We now have our same-type requirement, but we must also derive each conformance requirement in $\Chart(z)$ from the conformance requirements in $\Chart(z^\prime)$.

Notice how $z^\prime$ and $z$ have the same number and relative ordering of protocol symbols, and they all occur in the right whisker~$y$, so there is a one-to-one correspondence between the elements of $\Chart(z^\prime)$ and $\Chart(z)$.

At each occurrence of a protocol symbol in~$y$, we split up $y$ into a pair of terms, by writing $y=y_1\cdot\pP\cdot y_2$ for some $y_1$, $y_2\in A^*$ and some protocol \tP. Then:
\begin{gather*}
\ConfReq{$\Type(u\cdot y_1)$}{P}\in\Chart(z^\prime)\\
\ConfReq{$\Type(v\cdot y_1)$}{P}\in\Chart(z)
\end{gather*}

For each $\ConfReq{$\Type(u\cdot y_1)$}{P}\in\Chart(z^\prime)$, we know that $\Type(u\cdot y_1)$ is a prefix of $\Type(z^\prime)$. Because $G$ is well-formed, \PropRef{prefix prop} says that $G\vdash\Type(u\cdot y_1)$. Then, $\Type(u)$ is also a prefix of $\Type(u\cdot y_1)$, so \LemmaRef{general member type} says that $G\vdash\SameReq{$\Type(u\cdot y_1)$}{$\Type(v\cdot y_1)$}$. Finally, we flip this requirement with \IndexStep{Sym}\textsc{Sym}, and apply \IndexStep{SameConf}\textsc{SameConf} to derive the desired conformance requirement in $\Chart(z)$:
\begin{gather*}
\AnyStep{\SameReq{$\Type(u\cdot y_1)$}{$\Type(v\cdot y_1)$}}{1}\\
\AnyStep{\ConfReq{$\Type(u\cdot y_1)$}{P}}{2}\\
\SymStep{1}{$\Type(v\cdot y_1)$}{$\Type(u\cdot y_1)$}{3}\\
\SameConfStep{3}{1}{$\Type(u\cdot y_1)$}{P}{4}
\end{gather*}

\Case{6} A negative rewrite step for an explicit same-type requirement has the following general form, where $(u,v)\in R$ for standard terms $u$~and~$v$, the left whisker is empty, and the right whisker~$y$ is is a combination of name and protocol symbols:
\[(v\Rightarrow u)\WR y\]

We proceed as in Case~5, except that when the \textsc{Same} elementary statement gives us $\SameReq{$\Type(u)$}{$\Type(v)$}$, we must apply the \IndexStep{Sym}\textsc{Sym} inference rule to flip it around to get $\SameReq{$\Type(v)$}{$\Type(u)$}$ before we proceed:
\begin{gather*}
\SameStep{$\Type(u)$}{$\Type(v)$}{1}\\
\SymStep{1}{$\Type(v)$}{$\Type(u)$}{2}
\end{gather*}
We can then derive our final same-type requirement, and all conformance requirements listed in the chart, as before.

\Case{7} A positive rewrite step for an \index{associated same-type requirement!in requirement machine}associated same-type requirement has the following general form, where the left whisker $x$ is an admissible term, $(\pP\cdot u,\pP \cdot v)\in R$, $u$ and $v$ only contain name symbols, and the right whisker~$y$ is a combination of name and protocol symbols:
\[x\WL(\pP\cdot u\Rightarrow\pP\cdot v)\WR y\]
The rewrite step replaces $\pP\cdot u$ with $\pP\cdot v$ in the middle of the term:
\begin{gather*}
z^\prime=\Src(s)=x\cdot\pP\cdot u\cdot y\\
z=\Dst(s)=x\cdot\pP\cdot v\cdot y
\end{gather*}
Note that $\ConfReq{$\Type(x)$}{P}\in\Chart(z^\prime)$, which we can derive by the induction hypothesis. Also, observe that $\Type(x\cdot\pP\cdot u)=\Type(x\cdot u)$. We derive $\SameReq{$\Type(x\cdot u)$}{$\Type(x\cdot v$)}$ from $\ConfReq{$\Type(x)$}{P}$ via the \IndexStep{AssocSame}\textsc{AssocSame} inference rule:
\begin{gather*}
\AnyStep{\ConfReq{$\Type(x)$}{P}}{1}\\
\AssocSameStep{1}{$\Type(x\cdot u)$}{$\Type(x\cdot v)$}{2}
\end{gather*}

We then apply \LemmaRef{general member type} to $G\vdash\texttt{$\Type(x\cdot u\cdot y)$}$ and $G\vdash\SameReq{$\Type(x\cdot u)$}{$\Type(x\cdot v)$}$ to derive $G\vdash\SameReq{$\Type(x\cdot u\cdot y)$}{$\Type(x\cdot v\cdot y)$}$, or in other words, $\SameReq{$\Type(z^\prime)$}{$\Type(z)$}$:
\[
\AnyStep{\SameReq{$\Type(z^\prime)$}{$\Type(z)$}}{4}
\]
Finally, we apply the \IndexStep{Trans}\textsc{Trans} inference rule to compose the above requirement with the same-type requirement given to us by the induction hypothesis:
\[
\TransStep{1}{4}{$\Type(t)$}{$\Type(z)$}{5}
\]

We must also update the conformance chart. Both $x$ and $y$ may contain occurrences of protocol symbols, but since $\Chart(x)\subseteq\Chart(z^\prime)\cap\Chart(z)$, the requirements in $\Chart(x)$ that are common to both remain unchanged. We derive new conformance requirements corresponding to occurrences of protocol symbols in~$y$ as in Case~5.

\Case{8} A negative rewrite step for an associated same-type requirement has the following general form, where the left whisker $x$ is an admissible term, $(\pP\cdot u,\pP\cdot v)\in R$, $u$ and $v$ contain only name symbols, and 
the right whisker $y\in A^*$ is a combination of name and protocol symbols:
\[x\WL(\pP\cdot v\Rightarrow\pP\cdot u)\WR y\]

We proceed as in Case~7, except we must flip the same-type requirement around via \textsc{Sym} as in Case~6.
\end{proof}

The specific statement we are looking for falls out from the preceding theorem:

\begin{corollary}\label{path to derivation swift}
Let $G$ be a generic signature, and let $\AR$ be the requirement machine for~$G$. Assume $G$ is well-formed.
\begin{enumerate}
\item If $\Term(\tT)\cdot\pP \sim \Term(\tT)$ for some valid type parameter \tT, then $G \vdash \TP$.
\item If $\Term(\tT) \sim \Term(\tU)$ for valid type parameters \tT\ and \tU, then $G\vdash\TU$.
\end{enumerate}
\end{corollary}
\begin{proof}
In both cases, we have an equivalence between a standard term and an admissible term, so we can apply the previous theorem.

\Case{1} Let $t := \Term(\tT)$, and $z := \Term(\tT)\cdot\pP$. We have:
\begin{gather*}
\Type(z)=\tT\\
\Chart(z) = \{\TP\}
\end{gather*}
Translating our rewrite path gives us $G\vdash\SameReq{T}{T}$ which we discard, together with $G\vdash\TP$ which we keep.

\Case{2} Let $t := \Term(\tT)$, and $z := \Term(\tU)$. We have:
\begin{gather*}
\Type(z) = \tU\\
\Chart(z)=\{\}
\end{gather*}
Translating our rewrite path gives us $G\vdash\TU$ which we keep, together with an empty list of derived conformance requirements which we discard.
\end{proof}

\paragraph{The decision procedure.} Recall the four basic generic signature queries that describe the equivalence class structure of a generic signature, from \SecRef{genericsigqueries}. We saw the first two are fundamental from a theoretical standpoint.

Taken together, \CorollaryRef{convergent decidable}, \ThmRef{derivation to path swift}, and \CorollaryRef{path to derivation swift} say that if we have a well-formed generic signature~$G$ presented by a \index{convergent rewriting system}convergent rewriting system~$\AR$, and the given type parameters are \index{valid type parameter}valid, then:
\begin{enumerate}
\item $G\vdash\TP$ \textbf{if and only if} $\Term(\tT)\cdot\pP$ has the same normal form as $\Term(\tT)$.
\item $G\vdash\TU$ \textbf{if and only if} $\Term(\tT)$ has the same normal form as $\Term(\tU)$.
\end{enumerate}
Also, crucially, the preconditions here are all things we can \emph{check}, and we can compute the normal form of a term using \AlgRef{term reduction algo}. As we now quite clearly can see:

\begin{mdframed}[leftline=false,rightline=false,linecolor=black,linewidth=2pt]
When implemented as below, the two basic generic signature queries always output the correct answer in a finite number of steps.
\begin{itemize}
\item \textbf{Query:} \Query{requiresProtocol}{G,\,\tT,\,\tP}

Apply the normal form algorithm to $\Term(\tT)\cdot\pP$ and $\Term(\tT)$ and check if we get a pair of identical terms.

\item \textbf{Query:} \Query{areReducedTypeParametersEqual}{G,\,\tT,\,\tU}

Apply the normal form algorithm to $\Term(\tT)$ and $\Term(\tU)$ and check if we get a pair of identical terms.
\end{itemize}
\end{mdframed}

\section{Symbols}\label{rqm symbols}

Given a generic signature, our ``core model'' describes a monoid presentation whose alphabet consists of generic parameter, name, and protocol symbols. This gave us an elegant formalism for a subset of Swift generics. The remainder of this chapter describes the full implementation, with less mathematical rigor than before, and instead a focus on practical concerns.

We begin by expanding our alphabet with a few more symbol kinds on top of the three found in the core model. We will also define a reduction order on this alphabet. While our correctness result only needed the symmetric term equivalence relation, we need a reduction order to make use of the \index{normal form algorithm}normal form algorithm in the implementation.

Symbols are formed by the \index{rewrite context}rewrite context, the global singleton from \SecRef{protocol component} which manages the lifecycle of requirement machine instances. There are eight symbol kinds, with each kind having its own set of \index{structural components}structural components. This resembles how we modeled types in \ChapRef{types}.

For each symbol kind, a constructor function takes the structural components and returns a pointer to the unique symbol formed from those structural components. The identity of a symbol is determined by its structural components, so symbols can be compared for pointer equality.
\begin{definition}
A \IndexDefinition{symbol!in requirement machine}\emph{symbol} in the Requirement Machine \IndexDefinition{alphabet!in requirement machine}alphabet is an instance of one of the following:
\begin{itemize}
\item A \IndexDefinition{generic parameter symbol}\textbf{generic parameter symbol} \ttgp{d}{i}, for some \index{depth!in generic parameter symbol}depth $d$ and \index{index!in generic parameter symbol}index $i\in\NN$.
\item A \IndexDefinition{name symbol}\textbf{name symbol} \nA, where \nA\ is an \index{identifier!in name symbol}identifier appearing in the program.
\item A \IndexDefinition{protocol symbol}\textbf{protocol symbol} \pP, where \tP\ is a reference to a \index{protocol declaration!in protocol symbol}protocol declaration.
\item An \IndexDefinition{associated type symbol}\textbf{associated type symbol} $\aPA$, where \tP\ is some protocol, and \nA\ is the name of an associated type declaration.
\item A \IndexDefinition{layout symbol}\textbf{layout symbol} $\layoutsym{L}$, where \texttt{L} is a \index{layout constraint}layout constraint, either \Index{AnyObject@\texttt{AnyObject}}\texttt{AnyObject} or \verb|_NativeClass|.
\item A \IndexDefinition{superclass symbol}\textbf{superclass symbol} $\supersym{\texttt{C};\,t_0,\ldots,t_n}$ where \texttt{C} is an \index{canonical type!in requirement machine}interface type, called the \index{pattern type}\emph{pattern type} of the symbol, and the $t_i$ are terms, called \index{substitution term}\emph{substitution terms}. In a superclass symbol, the pattern type is a class or generic class type.
\item A \IndexDefinition{concrete type symbol}\textbf{concrete type symbol} $\concretesym{\texttt{X};\,t_0,\ldots,t_n}$ where the pattern type~\texttt{X} is now any interface type that is not a type parameter, and the $t_i$ are substitution terms.
\item A \IndexDefinition{concrete conformance symbol}\textbf{concrete conformance symbol} $\concretesym{\texttt{X}\colon\tP;\,t_0,\ldots,t_n}$ where \texttt{X} is any interface type that is not a type parameter, the $t_i$ are substitution terms, and \tP\ is a reference to a protocol declaration.
\end{itemize}
\end{definition}

\paragraph{Name symbols.}
We already introduced name symbols at the beginning of this chapter and there isn't much else to say, but we add one remark. In the requirement machine for a \index{well-formed generic signature!name symbols}well-formed generic signature~$G$, every name symbol ``\nA'' has to be the name of some associated type or type alias of some \tP\ such that $G\prec\tP$---for otherwise, ``\nA'' cannot appear in any valid type parameter. However, we allow name symbols for arbitrary identifiers to be formed, so that we can model invalid programs as well. In any case, only a finite set of name symbols are constructed.

\paragraph{Protocol symbols.}
The reduction order on \index{protocol symbol!reduction order}protocol symbols has the property that if a protocol~\tQ\ inherits from a protocol~\tP, then $\pP<\pQ$.

Consider the \index{directed graph}directed graph where the vertices are protocol declarations, and for each pair of protocols \tQ\ and \tP\ such that \tQ\ \index{inherited protocol!in requirement machine}inherits from \tP, there is an edge with \index{source vertex}source~\tQ\ and \index{destination vertex}destination~\tP. Define $\mathsf{depth}(\tP)\in\NN$ as the number of protocols we can reach from \tP, excluding \tP\ itself. To compute the ``$\mathsf{depth}$'' of a protocol, we evaluate the \index{all inherited protocols request}\Request{all inherited protocols request} with~\tP, which returns the set of all protocols reachable from \tP, and then take the number of elements in this set.

\begin{algorithm}[Protocol reduction order]\label{protocol reduction order} \IndexDefinition{protocol reduction order}Takes two protocol symbols \pP\ and \pQ\ as input, and returns one of ``$<$'', ``$>$'' or ``$=$'' as output.
\begin{enumerate}
\item If $\mathsf{depth}(\tP)>\mathsf{depth}(\tQ)$, return ``$<$''. (Deeper protocols are smaller.)
\item If $\mathsf{depth}(\tP)<\mathsf{depth}(\tQ)$, return ``$>$''.
\item If $\mathsf{depth}(\tP)=\mathsf{depth}(\tQ)$, compare the protocols with \AlgRef{linear protocol order}.
\end{enumerate}
\end{algorithm}

\begin{example}\label{protocol reduction order example}
Various standard library protocols inherit from \texttt{Sequence}:
\begin{Verbatim}
public protocol Sequence {...}
public protocol Collection: Sequence {...}
public protocol BidirectionalCollection: Collection {...}
public protocol MutableCollection: Collection {...}
public protocol RandomAccessCollection: BidirectionalCollection {...}
\end{Verbatim}
\index{tree}
The protocol inheritance relationships above define this graph:
\begin{center}
\begin{tikzpicture}[x=2.5cm]
  \node (Sequence) [interior, xshift=0.75em] at (0,3) {\texttt{\vphantom{pI}Sequence}};
  \node (Collection) [interior, xshift=0.75em] at (0,2) {\texttt{\vphantom{pI}Collection}};
  \node (BidirectionalCollection) [interior] at (-1,1) {\texttt{\vphantom{pI}BidirectionalCollection}};
  \node (MutableCollection) [interior] at (1,1) {\texttt{\vphantom{pI}MutableCollection}};
  \node (RandomAccessCollection) [interior] at (-1,0) {\texttt{\vphantom{pI}RandomAccessCollection}};

  \draw [arrow] (Collection) -- (Sequence);
  \draw [arrow] (BidirectionalCollection) -- (Collection);
  \draw [arrow] (MutableCollection) -- (Collection);

  \draw [arrow] (RandomAccessCollection) -- (BidirectionalCollection);
\end{tikzpicture}
\end{center}
The corresponding protocol symbols are ordered as follows---notice how deeper protocols precede shallower protocols:
\begin{gather*}
\protosym{RandomAccessCollection}\\
{} < \protosym{BidirectionalCollection}<\protosym{MutableCollection}\\
{} < \protosym{Collection}\\
{} < \protosym{Sequence}
\end{gather*}
\end{example}

\paragraph{Associated type symbols.}
We encode the relationship between a protocol symbol and the name symbols of its associated type declarations by extending our alphabet with \emph{associated type symbols}, and our set of rewrite rules with \emph{associated type rules}.

If $\aPA$ is an associated type symbol, it must be the case that \nA\ is the name of an associated type declared either by \tP\ itself, or some \index{inherited protocol!in requirement machine}base protocol of \tP. The notation $\aPA$ fuses a protocol symbol \pP\ with a name symbol \nA, and in fact an \index{associated type rule}associated type rule has the form $\pP\cdot\nA\sim\aPA$.

Why do we need associated type symbols? There are two reasons:
\begin{enumerate}
\item In \SecRef{genericsigqueries}, we saw that we can implement $\Query{isValidTypeParameter}{}$ using the $\Query{areReducedTypeParametersEqual}{}$ and $\Query{requiresProtocol}{}$ generic signature queries. Once we add associated type symbols, we can instead directly decide if a type parameter is valid using the \index{normal form algorithm}normal form algorithm.

\item More importantly, it also turns out that we need associated type symbols to obtain a convergent rewriting system when our generic signature has an infinite set of equivalence classes.
\end{enumerate}
We will study both of these points in great detail in \ChapRef{completion}.

The reduction order on associated type symbols is defined using the reduction order on protocol symbols:
\begin{algorithm}[Associated type reduction order]\label{associated type reduction order} \IndexDefinition{associated type reduction order}Takes two associated type symbols $\assocsym{P}{A}$ and $\assocsym{Q}{B}$ as input, and returns one of ``$<$'', ``$>$'' or ``$=$'' as output.
\begin{enumerate}
\item Compare the identifiers \texttt{A} and \texttt{B} using the \index{lexicographic order}lexicographic order. Return the result if it is ``$<$''~or~``$>$''. Otherwise, both associated types have the same name.
\item Compare the protocol symbols $\pP$ and $\pQ$ using \AlgRef{protocol reduction order} and return the result.
\end{enumerate}
\end{algorithm}

An associated type symbol does not directly refer to an associated type \index{associated type declaration!compared to associated type symbol}\emph{declaration}, because the associated type might be \index{inherited associated type}\emph{inherited} by the protocol. That is, every associated type declaration of a base protocol also gives rise to a distinct symbol when ``viewed'' from the derived protocol.

\begin{example}
We continue \ExRef{protocol reduction order example}. The \texttt{Sequence} protocol declares an \texttt{Element} associated type, so its derived protocols inherit this associated type. In the requirement machine for the \index{protocol generic signature}protocol generic signature $G_\texttt{RandomAccessCollection}$, the alphabet contains various associated type symbols, ordered as follows:
\begin{gather*}
\assocsym{RandomAccessCollection}{Element}\\
{} < \assocsym{BidirectionalCollection}{Element}\\
{} < \assocsym{Collection}{Element}\\
{} < \assocsym{MutableCollection}{Element}\\
{} < \assocsym{Sequence}{Element}
\end{gather*}
We will see \emph{why} the order must respect protocol inheritance in \SecRef{recursive conformances redux}.
\end{example}

\medskip

The next three symbol kinds appear when we build rewrite rules for \index{layout requirement}layout, \index{superclass requirement}superclass and \index{same-type requirement}concrete type requirements. Just like a \index{conformance requirement}conformance requirement $\TP$ defines a rewrite rule $\Term(\tT)\cdot\pP\sim\Term(\tT)$, these other requirement kinds define \index{rewrite rule!in requirement machine}rewrite rules of the form $\Term(\tT)\cdot s\sim\Term(\tT)$, where \tT\ is the requirement's subject type, and $s$ is a layout, superclass or concrete type symbol.

\paragraph{Layout symbols.} The $\layoutsym{AnyObject}$ \index{layout symbol}layout symbol represents the \texttt{AnyObject} layout constraint we introduced in \DefRef{requirement def}. It appears when we translate a layout requirement $\ConfReq{T}{AnyObject}$ into a rule $\Term(\tT)\cdot\layoutsym{AnyObject} \sim \Term(\tT)$.

We also mentioned the \verb|_NativeClass| layout constraint in \SecRef{genericsigqueries}. This constraint cannot be stated directly by the user, but it is implied by a superclass requirement to a Swift-native class. These two layout symbols are ordered as follows:
\[\layoutsym{AnyObject} < \layoutsym{\char`_NativeClass}\]

\paragraph{Superclass and concrete type symbols.}
\index{superclass symbol}Superclass and \index{concrete type symbol}concrete type symbols encode a concrete type that may contain type parameters. To form the symbol, we first decompose the concrete type into a \IndexDefinition{pattern type}\emph{pattern type} and a list of \IndexDefinition{substitution term}\emph{substitution terms}:
\begin{ceqn}
\[\text{concrete type} = \text{pattern type} + \text{substitution terms}\]
\end{ceqn}
We're forming the symbol because we're translating an explicit or associated requirement into a rewrite rule, so we use the ``$\Term$'' or ``$\TermP{P}$'' mapping as appropriate to translate each type parameter appearing in our concrete type. (The next section will introduce \AlgRef{build term generic} and \AlgRef{build term protocol} used for this purpose, but for now, the definitions from the start of this chapter remain valid.) We then replace each type parameter with a ``phantom'' generic parameter \ttgp{0}{i}, where the \index{depth}depth is always zero, and the \index{index}index~$i\in\NN$ is the index of the corresponding substitution term in the list.

\begin{algorithm}[Build concrete type symbol]\label{concretesymbolcons}
Receives an interface type~\texttt{X} as input, and optionally, a protocol~\tP. As output, returns a pattern type together with a list of substitution terms. Note that the type \texttt{X} must not itself be a type parameter.
\begin{enumerate}
\item Initialize $S$ with an empty list of terms, and let $i:=0$.
\item Perform a pre-order walk over the tree structure of \texttt{T}, transforming each type parameter~\tT\ contained in \texttt{X} to form the pattern type~\texttt{Y}:
\begin{enumerate}
\item If we're lowering an explicit requirement, let $t := \Term(\tT)$. Otherwise, let $t := \TermP{P}(\tT)$. Set $S\leftarrow S + \{t\}$.
\item Replace \tT\ with the generic parameter type \ttgp{0}{i} in \texttt{X}.
\item Set $i\leftarrow i + 1$.
\end{enumerate}
\item Return the type \texttt{Y}, and the array of substitution terms~$S$.
\end{enumerate}
\end{algorithm}

\begin{example}
Given the explicit requirement $\SameReq{\rT}{Array<\rU.Element>}$, we decompose the right-hand side as follows:
\begin{ceqn}
\[\texttt{Array<\rU.Element>} = \texttt{Array<\rT>} + \{\rU\cdot\nElement\}\]
\end{ceqn}
We can then form the concrete type symbol $\concretesym{\texttt{Array<\rT>};\, \rU\cdot\nElement}$ from the pattern type \texttt{Array<\rT>} and list of substitution terms $\{\rU\cdot\nElement\}$.
\end{example}

\begin{example}
If we have a \index{fully-concrete type}fully concrete type that does not contain type parameters, then our list of substitution terms will be empty. For example, the right-hand side of the superclass requirement $\ConfReq{Self}{NSObject}$ defines the symbol $\supersym{\texttt{NSObject}}$.
\end{example}

\begin{example}
The pattern type output by \AlgRef{concretesymbolcons} satisfies certain conditions:
\begin{enumerate}
\item The pattern type itself cannot be a type parameter.
\item The pattern type does not contain any dependent member types.
\item Every generic parameter type appearing in the pattern type has depth zero.
\item Every generic parameter type has a unique index.
\item Indices are consecutive and start from zero.
\end{enumerate}
None of the following are valid pattern types:
\begin{gather*}
\rT\\
\texttt{Array<\rT.Element>}\\
\texttt{Array<\ttgp{1}{0}>}\\
\texttt{Dictionary<\rT,~\rT>}\\
\texttt{(\rU) -> \rT}
\end{gather*}
\end{example}
To compare a pair of superclass or concrete type symbols, we first compare their pattern types for canonical type equality, and then compare their substitution terms using the reduction order on terms, which we define in the next section. Note that this is a \index{partial order}partial order; symbols with distinct pattern types are incomparable.

\begin{algorithm}[Concrete type reduction order]\label{concrete reduction order}
Takes two superclass or concrete type symbols $s_1$ and $s_2$ as input. Returns one of ``$<$'', ``$>$'', ``$=$'' or \index{$\bot$}``$\bot$'' as output.
\begin{enumerate}
\item (Invariant) We assume the two symbols already have the same kind; the case of comparing different kinds is handled by the general symbol order we define next.
\item (Incomparable) Compare the pattern type of $s_1$ and $s_2$ with \index{canonical type equality}canonical type equality. If the pattern types are distinct, return ``$\bot$''.
\item (Initialize) Both symbols have the same pattern type, so they must have the same number of substitution terms, say $n$. Also, let $i:=0$.
\item (Equal) If $i=n$, all substitution terms are identical. Return ``$=$''.
\item (Compare) Compare the $i$th substitution terms of $s_1$ and $s_2$ using \AlgRef{rqm reduction order}. Return the result if it is ``$<$'' or ``$>$''.
\item (Next) Otherwise, set $i\leftarrow i+1$ and go back to Step~4.
\end{enumerate}
\end{algorithm}

Note that superclass and concrete type symbols contain terms, but those terms cannot recursively contain superclass and concrete type symbols, because terms corresponding to type parameters only contain generic parameter, name, protocol and associated type symbols.

\paragraph{Concrete conformance symbols.} Such a \index{concrete conformance symbol}symbol consists of a pattern type, a list of substitution terms, and a protocol declaration. We will see in \ChapRef{concrete conformances} that when a type parameter \tT\ is subject to the combination of a \index{conformance requirement}conformance requirement $\TP$ and a concrete same-type requirement $\TX$, we introduce a rewrite rule containing a concrete conformance symbol:
\[\Term(\tT)\cdot\concretesym{\texttt{X}\colon\texttt{P};\,\ldots} \sim \Term(\tT)\]
To compare two concrete conformance symbols, we first compare their protocol, then we compare their pattern type and substitution terms.
\begin{algorithm}[Concrete conformance reduction order]\label{concrete conformance reduction order}
Takes two concrete conformance symbols $s_1$ and $s_2$ as input. Returns one of ``$<$'', ``$>$'', ``$=$'' or \index{$\bot$}``$\bot$'' as output.
\begin{enumerate}
\item Compare the protocol of $s_1$ and $s_2$ using \AlgRef{protocol reduction order}. Return the result if it is ``$<$'' or ``$>$''.
\item Otherwise, compare the pattern type and substitution terms as in \AlgRef{concrete reduction order}.
\end{enumerate}
\end{algorithm}

\paragraph{Symbol order.} To compare an arbitrary pair of symbols that may have different kinds, we must define an order among the symbol kinds.

\begin{algorithm}[Symbol reduction order]\label{symbol reduction order}
Takes two symbols as input, and returns one of ``$<$'', ``$>$'', ``$=$'' or ``$\bot$'' as output. If the two symbols have different kinds, map their kinds to \index{natural number}natural numbers and compare the numbers with the usual linear order on~$\NN$:
\begin{center}
\begin{tabular}{ll}
\toprule
Concrete conformance:&0\\
Protocol:&1\\
Associated type:&2\\
Generic parameter:&3\\
Name:&4\\
Layout:&5\\
Superclass:&6\\
Concrete type:&7\\
\bottomrule
\end{tabular}
\end{center}
Otherwise, both symbols have the same kind, which we already know how to compare:
\begin{itemize}
\item For \index{generic parameter symbol}generic parameter symbols, use \AlgRef{generic parameter order}.
\item For \index{name symbol}name symbols, use the \index{lexicographic order}lexicographic order on their stored \index{identifier}identifiers.
\item For protocol symbols, use \AlgRef{protocol reduction order}.
\item For \index{associated type symbol}associated type symbols, use \AlgRef{associated type reduction order}.
\item For layout symbols, use the order previously described.
\item For superclass symbols, use \AlgRef{concrete reduction order}.
\item For concrete type symbols, use \AlgRef{concrete reduction order}.
\item For concrete conformance symbols, use \AlgRef{concrete conformance reduction order}.
\end{itemize}
\end{algorithm}

\section{Terms}\label{building terms}

In the theory, a term is an element of a \index{free monoid}free monoid. In the implementation, a \IndexDefinition{term!in requirement machine}term is a sequence of symbols. There are two flavors. A \IndexDefinition{mutable term}\emph{mutable term} is a value type which store its own heap-allocated buffer. Mutable terms are cheap to modify, but expensive to copy and store; the normal form algorithm and Knuth-Bendix completion both operate on mutable terms. An \IndexDefinition{immutable term}\emph{immutable term} immutable term is expensive to allocate, because it is uniqued by the \index{rewrite context}rewrite context, but cheap to compare for equality, because immutable terms with the same length and symbols are equal as pointers. Immutable terms are used in the representation of rewrite rules.

Because of how requirements map to rules, the rewrite rules in a requirement machine always have non-empty terms on both sides. For this reason, there is no immutable term representation of the empty term~$\varepsilon$. Mutable terms may be empty though, and that is the initial state of a mutable term upon creation, before any symbols are added.

We now describe a pair of algorithms for translating type parameters to mutable terms, implementing the ``$\Term$'' and ``$\TermP{P}$'' mappings from the start of the present chapter. We start with the ``$\Term$'' mapping, used for lowering type parameters to terms in \index{query machine}query machines and \index{minimization machine}minimization machines. We extend this mapping to handle \index{bound type parameter!in requirement machine}bound dependent member types, which translate to associated type symbols. They appear when we're building a query machine from the minimal requirements of an existing generic signature. Here is the general idea:

\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Type parameter:}&\textbf{Term:}\\
\midrule
\texttt{\rT.A.B}&$\rT\cdot\nA\cdot\nB$\\
\texttt{\rT.[P]A.[Q]B}&$\rT\cdot\aPA\cdot\assocsym{Q}{B}$\\
\bottomrule
\end{tabular}
\end{center}

A \index{type parameter!in requirement machine}type parameter is a \index{linked list}single-linked list where each interior node is a \index{dependent member type!in requirement machine}dependent member type, and the tail of the list is a generic parameter type. The head of the list is the \emph{outermost} member type, so ``\texttt{B}'' in \texttt{\rT.A.B}, and the base type of each dependent member type is the ``next'' pointer.

The below is an instance of the classical algorithm for converting a linked list into an array. We traverse the list from head to tail, at each step adding a symbol at the end of the term; this leaves us with a term where the \emph{last} element is the generic parameter symbol. We then reverse the order of symbols to get the final result.

\begin{algorithm}[Build term for explicit requirement]\label{build term generic}
Takes a type parameter \tT\ as input, and outputs a (non-empty) mutable term.
\begin{enumerate}
\item (Initialize) Let $t$ be a new empty mutable term.
\item (Base case) If \tT\ is a generic parameter type \ttgp{d}{i}:
\begin{enumerate}
\item First, add the generic parameter symbol \ttgp{d}{i} to $t$.
\item Then, reverse the symbols in $t$, and return $t$.
\end{enumerate}
\item (Recursive case) Otherwise, \tT\ is a dependent member type:
\begin{enumerate}
\item If \tT\ is an unbound dependent member type \verb|U.A| for some type parameter~\tU, add the \index{name symbol}name symbol \texttt{A} to $t$.
\item Otherwise, \tT\ is a bound dependent member type \verb|U.[P]A|, again for some type parameter~\tU. Add the \index{associated type symbol}associated type symbol $\assocsym{P}{A}$ to $t$.
\end{enumerate}
Set $\tT \leftarrow \tU$, and go back to Step~2.
\end{enumerate}
\end{algorithm}

\ThmRef{bound and unbound equiv} showed that every valid type parameter has a bound and unbound type parameter form. The above mapping is defined such that the terms obtained from the bound and unbound form of the same type parameter become equivalent under the \index{term equivalence relation!in requirement machine}term equivalence relation that will be generated by our rewrite rules.

An alternate valid implementation of \AlgRef{build term generic} would instead map both bound and unbound dependent member types to name symbols, ignoring the protocol of an associated type declaration referenced by a bound dependent member type. Instead, our implementation constructs associated type symbols directly, which has the effect of short-circuiting some work that would otherwise be performed later, in the normal form algorithm or in completion. We will say more about this in \SecRef{critical pairs}.

\smallskip

Next, consider the ``$\TermP{P}$'' mapping, used for building terms in a \index{protocol machine}protocol machine or \index{protocol minimization machine}protocol minimization machine. Once again, we define the mapping on both unbound and bound type parameters. We've already seen that an unbound type parameter of $\GP$ maps to a term that starts with a protocol symbol, followed by a series of name symbols. For bound type parameters, the protocol symbol disappears, and we're left with only associated type symbols:
\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Type parameter:}&\textbf{Term:}\\
\midrule
\texttt{Self}&$\pP$\\
\texttt{Self.A.B}&$\pP\cdot\nA\cdot\nB$\\
\texttt{Self.[P]A.[Q]B}&$\aPA\cdot\assocsym{Q}{B}$\\
\bottomrule
\end{tabular}
\end{center}

\begin{algorithm}[Build term for associated requirement]\label{build term protocol}
Takes a type parameter \tT\ and a protocol declaration \tP\ as input, and outputs a (non-empty) mutable term.
\begin{enumerate}
\item (Initialize) Let $t$ be a new empty mutable term.
\item (Base case) If \tT\ is the protocol \tSelf\ type (\ttgp{0}{0}), consider the term~$t$ constructed so far:
\begin{enumerate}
\item If $t$ ends with an associated type symbol $\assocsym{Q}{A}$, then either $\tQ=\tP$, or \tP\ inherits from~\tQ. In both cases, \emph{replace} the last symbol of $t$ with $\assocsym{P}{A}$.
\item Otherwise, either $t$ is empty, or it ends with a name symbol. Add the protocol symbol~$\pP$ to $t$.
\end{enumerate}
Finally, reverse the symbols in $t$, and return $t$.
\item (Recursive case) Otherwise, \tT\ is a dependent member type.
\begin{enumerate}
\item If \tT\ is an unbound dependent member type \verb|U.A|, add the name symbol~\nA\ to~$t$.
\item Otherwise, \tT\ is a bound dependent member type \verb|U.[Q]A|. Add the associated type symbol $\assocsym{Q}{A}$ to $t$.
\end{enumerate}
Set $\tT \leftarrow \tU$, and go back to Step~2.
\end{enumerate}
\end{algorithm}

\begin{example}
Note the behavior of \AlgRef{build term protocol} with \index{inherited associated type}\index{inherited protocol}inherited associated types:
\begin{Verbatim}
protocol Base {
  associatedtype Element
}

protocol Derived: Base {
  // associatedtype Element
}
\end{Verbatim}
Let's apply \AlgRef{build term protocol} to the bound and unbound form of the type parameter \texttt{Self.Element} of $G_\texttt{Derived}$:
\begin{gather*}
\TermP{Derived}(\texttt{Self.[Base]Element}) = \assocsym{Derived}{Element}\\
\TermP{Derived}(\texttt{Self.Element}) = \protosym{Derived}\cdot\nElement
\end{gather*}
Notice the appearance of an inherited associated type symbol. Now, suppose we uncomment the declaration of \texttt{Element} in \texttt{Derived}. We have a new bound type parameter \texttt{Self.[Derived]Element}, whose term is actually identical to the other one:
\begin{gather*}
\TermP{Derived}(\texttt{Self.[Derived]Element}) = \assocsym{Derived}{Element}
\end{gather*}
In \texttt{Derived}, both of these pairs of terms are equivalent:
\begin{gather*}
\protosym{Derived}\cdot\nElement\sim\assocsym{Derived}{Element}\\
\protosym{Derived}\cdot\assocsym{Base}{Element}\sim\assocsym{Derived}{Element}
\end{gather*}
We will see why in the next section, when we define the rewrite rules for a protocol machine.
\end{example}

\paragraph{Reduction order.}
In the previous section, we defined a partial order on symbols. We now extend this to a partial order on terms. Recall the discussion of reduction orders from \SecRef{rewritesystemintro}.

We start with the standard shortlex order from \AlgRef{shortlex}, but add an additional check to ensure that terms containing name symbols are always ordered after terms without name symbols, even if the term with name symbols is shorter. This is an instance of a \emph{weighted shortlex order}, where our chosen weight function counts the number of name symbols appearing in a term. In the next section, we will see that the weighted shortlex order is necessary for correctness once we introduce the \index{rewrite rule!protocol type alias}rewrite rules for protocol type aliases.

\begin{definition}
Let $A$ be any set. We say that $w\colon A^*\rightarrow\NN$ is a \IndexDefinition{weight function}\emph{weight function} if it satisfies $w(xy)=w(x)+w(y)$ for all $x$, $y\in A^*$. That is, $w$ is a \index{monoid homomorphism}monoid homomorphism from $A^*$~to~$\NN$, where the latter is viewed as a monoid under addition.
\end{definition}

\begin{algorithm}[Weighted shortlex order]\label{rqm reduction order}
Takes two terms $t$ and $u$ as input, and returns one of ``$<$'', ``$>$'', ``$=$'' or \index{$\bot$}``$\bot$'' as output.
\begin{enumerate}
\item (Weight) Compute $w(t)$ and $w(u)$.
\item (Less) If $w(t)<w(u)$, return ``$<$''.
\item (More) If $w(t)>w(u)$, return ``$>$''.
\item (Shortlex) Otherwise $w(t)=w(u)$, so we compare the terms using \AlgRef{shortlex} and return the result.
\end{enumerate}
\end{algorithm}

The weighted shortlex order is a suitable reduction order under \DefRef{reduction order def}.

\begin{proposition} Let \index{natural numbers}$w\colon A^*\rightarrow\NN$ be a weight function. Then the weighted shortlex order induced by $w$ is \index{translation-invariant relation}translation-invariant and \index{well-founded order}well-founded.
\end{proposition}
\begin{proof}
Let $<$ be the standard shortlex order on $A^*$, and let $<_w$ be the weighted shortlex order induced by~$w$.

We prove translation invariance first. We're given $x$, $y$, $z\in A^*$ with $x<_w y$. We will show that $zx<_w zy$; the proof that $xz<_w yz$ is similar. Since $x<_w y$, by definition we either have $w(x)<w(y)$, or $w(x)=w(y)$ and $x<y$. We consider each case:
\begin{enumerate}
\item If $w(x)<w(y)$, then $w(z)+w(x)<w(z)+w(y)$ because the linear order on $\NN$ is translation-invariant, and since $w(zx)=w(z)+w(x)$ and $w(zy)=w(z)+w(y)$, we see that $w(zx)<w(zy)$, therefore $zx <_w zy$.
\item If $w(x)=w(y)$ and $x<y$, then $w(zx)=w(zy)$, and the translation invariance of~$<$ on $A^*$ implies that $zx<zy$. Once again, we conclude that $zx <_w zy$.
\end{enumerate}
Now, we demonstrate that $<_w$ is well-founded, by contradiction. Assume we have an infinite descending chain:
\[ t_1 >_w t_2 >_w t_3 >_w \cdots \]
If we apply the weight function $w$ to each term $t_i$ in this chain, we see that:
\[ w(t_1) \geq w(t_2) \geq w(t_3) \geq \cdots \]
Since $w(t_i)\in\NN$, we can only ``step down'' finitely many times. So there exists some index~$i$ such that for all $j>i$, $w(t_j)=w(t_i)$. Together with $t_j <_w t_i$, we conclude that actually, $t_j < t_i$. Thus, we get an infinite descending chain for the \emph{standard} shortlex order~$<$:
\[ t_i > t_{i+1} > t_{i+2} > \cdots \]
However, this is a contradiction, because the standard shortlex order $<$ is well-founded. Thus, $<_w$ must also be well-founded.
\end{proof}
We now dispose of the notation $<_w$. We will denote the reduction order on terms by~$<$, with the understanding that it is the weighted shortlex order of \AlgRef{rqm reduction order}.

\section{Rules}\label{building rules}

We now completely describe the ``$\Rule$'' and ``$\RuleP{P}$'' mappings for translating requirements to rewrite rules. Recall the requirement machine kinds from \ChapRef{rqm basic operation}.

We start with the ``$\Rule$'' mapping, which defines the local rules of \index{generic signature machine}\textbf{generic signature} and \index{generic signature minimization machine}\textbf{generic signature minimization} machines. We can assume the input requirement is desugared already (\SecRef{requirement desugaring}). This mapping uses \AlgRef{build term generic}, denoted ``$\Term$'', to translate type parameters to terms.

The handling of the interesting requirement kinds---layout, superclass and concrete type requirements---resembles conformance requirements. Let's say that a \IndexDefinition{property rule}\emph{property rule} is a rewrite rule of the form $(\Term(\tT)\cdot s,\Term(\tT))$, where $s$ is a symbol. Every requirement kind, with the exception of same-type requirements between type parameters, maps to a property rule. The following table summarizes the algorithm:

\begin{center}
\begin{tabular}{ll}
\toprule
\multicolumn{2}{c}{\textbf{Property rules:}}\\
\multicolumn{2}{c}{$\Term(\tT)\cdot s \sim \Term(\tT)$}\\
\midrule
$\Rule\, \TP$ & $s=\pP$\\
$\Rule\, \TAnyObject$ & $s=\layoutsym{AnyObject}$\\
$\Rule\, \TC$ & $s=\supersym{\ldots}$\\
$\Rule\, \TX$ & $s=\concretesym{\ldots}$\\
\midrule
\multicolumn{2}{c}{\textbf{Same-type rules:}}\\
$\TU$ & $\Term(\tT)\sim\Term(\tU)$\\
\bottomrule
\end{tabular}
\end{center}

\begin{algorithm}[Build rule from explicit requirement]\label{build rule}
Takes a desugared requirement as input, and outputs a pair of terms.
\begin{enumerate}
\item For a \index{conformance requirement!in requirement machine}\textbf{conformance requirement} $\TP$, build a property rule from $\Term(\tT)$ and the protocol symbol $\pP$.
\item For a \index{layout requirement!in requirement machine}\textbf{layout requirement} $\TAnyObject$, build a property rule from $\Term(\tT)$ and the layout symbol $\layoutsym{AnyObject}$.
\item For a \index{superclass requirement!in requirement machine}\textbf{superclass requirement} $\TC$, build a superclass symbol~$s$ using \AlgRef{concretesymbolcons}, and then build a property rule from from $\Term(\tT)$ and $s$.
\item For a \index{same-type requirement!in requirement machine}\textbf{same-type requirement} $\TX$, where \texttt{X} is a \textbf{concrete type}, build a concrete type symbol~$s$ using \AlgRef{concretesymbolcons}, and then build a property rule from from $\Term(\tT)$ and $s$.
\item For a \textbf{same-type requirement} $\TU$ where \tU\ is a \textbf{type parameter}, build a rule from $\Term(\tT)$ and $\Term(\tU)$.
\end{enumerate}
\end{algorithm}

For \index{protocol machine}protocol machines and \index{protocol minimization machine}protocol minimization machines, the translation is the same, except for the use of \AlgRef{build term protocol} (denoted ``$\TermP{P}$'') instead of \AlgRef{build term generic} (denoted ``$\Term$'') to translate type parameters to terms.

\begin{center}
\begin{tabular}{ll}
\toprule
\multicolumn{2}{c}{\textbf{Property rules:}}\\
\multicolumn{2}{c}{$\TermP{P}(\texttt{Self.U})\cdot s \sim \TermP{P}$}\\
\midrule
$\RuleP{P}\, \AssocConfReq{Self.U}{Q}{P}$ & $s = \pQ$\\
$\RuleP{P}\, \AssocConfReq{Self.U}{AnyObject}{P}$ & $s = \layoutsym{AnyObject}$\\
$\RuleP{P}\, \AssocConfReq{Self.U}{C}{P}$ & $s = \supersym{\ldots}$\\
$\RuleP{P}\, \AssocSameReq{Self.U}{X}{P}$ & $s = \concretesym{\ldots}$\\
\midrule
\multicolumn{2}{c}{\textbf{Same-type rules:}}\\
$\RuleP{P}\, \AssocSameReq{Self.U}{Self.V}{P}$ & $\TermP{P}(\texttt{Self.U})\sim\TermP{P}(\texttt{Self.V})$\\
\bottomrule
\end{tabular}
\end{center}

\begin{algorithm}[Build rule from associated requirement]\label{build rule protocol}
Takes a desugared requirement and a protocol declaration~\tP\ as input, and outputs a pair of terms.
\begin{enumerate}
\item For an \index{conformance requirement!in requirement machine}\textbf{associated conformance requirement} $\AssocConfReq{Self.U}{Q}{P}$, build a property rule from $\TermP{P}(\texttt{Self.U})$ and the protocol symbol $\pP$.
\item For a \index{layout requirement!in requirement machine}\textbf{associated layout requirement} $\AssocConfReq{Self.U}{AnyObject}{P}$, build a property rule from $\TermP{P}(\texttt{Self.U})$ and the layout symbol $\layoutsym{AnyObject}$.
\item For a \index{superclass requirement!in requirement machine}\textbf{associated superclass requirement} $\AssocConfReq{Self.U}{C}{P}$, build a superclass symbol~$s$ using \AlgRef{concretesymbolcons}, and then build a property rule from from $\TermP{P}(\texttt{Self.U})$ and $s$.
\item For a \index{same-type requirement!in requirement machine}\textbf{associated same-type requirement} $\AssocSameReq{Self.U}{X}{P}$, where \texttt{X} is a \textbf{concrete type}, build a concrete type symbol~$s$ using \AlgRef{concretesymbolcons}, and then build a property rule from from $\TermP{P}(\texttt{Self.U})$ and $s$.
\item For a \textbf{associated same-type requirement} $\AssocSameReq{Self.U}{Self.V}{P}$ where \texttt{Self.V} is a \textbf{type parameter}, build a rule from $\TermP{P}(\texttt{Self.U}))$ and $\TermP{P}(\texttt{Self.V})$.
\end{enumerate}
\end{algorithm}

In the core model, we lower each associated requirement of each protocol dependency to a rewrite rule. In the implementation, we add a few more rules for each protocol, to describe the structure of each protocol itself:
\begin{center}
\begin{tabular}{ll}
\toprule
\multicolumn{2}{c}{\textbf{Identity conformance rule:}}\\
\texttt{protocol P} & $\pP\cdot\pP \sim \pP$\\
\midrule
\multicolumn{2}{c}{\textbf{Associated type rules:}}\\
\texttt{associatedtype A} & $\pP\cdot\nA \sim \aPA$\\
\midrule
\multicolumn{2}{c}{\textbf{Inherited ssociated type rules:}}\\
\texttt{associatedtype A} & $\pP\cdot\nA \sim \aPA$\\
\bottomrule
\end{tabular}
\end{center}

The \IndexDefinition{identity conformance rule}\emph{identity conformance rule} conceptually states that the \tSelf\ type of an associated requirement conforms to the protocol itself. It plays a minor role. We can mostly ignore it, but we will justify it in \ExRef{proto assoc rule}. We also add a series of \IndexDefinition{associated type rule}\emph{associated type rules} for the protocol's own associated type declarations, and finally, \IndexDefinition{inherited associated type rule}\emph{inherited associated type rules} for those it inherits. The last two kinds convert between \index{name symbol}name symbols and \index{associated type symbol}associated type symbols.

\begin{algorithm}[Build protocol rules]\label{rules for protocol algo}
Takes a protocol declaration \tP\ as input, and outputs a list of rules.
\begin{enumerate}
\item Initialize $R$ with an empty list of rules, represented as pairs of terms.
\item Add the identity conformance rule $(\pP \cdot \pP,\, \pP)$ to $R$.
\item For each associated type \nA\ of \tP, build the associated type rule $(\pP \cdot \nA,\, \aPA)$ and add it to~$R$.

\item (Inherited associated types) For each associated type~\nA\ of each protocol~\tQ\ inherited by~\tP, add the inherited associated type rule $(\pP \cdot \nA,\,\aPA)$ to~$R$.
\end{enumerate}
\end{algorithm}

In the previous section, we claimed that our extension of ``$\Term$'' and ``$\TermP{P}$'' to bound type parameters has the property that if we build a pair of terms from the bound and unbound form of the same type parameter, we get an equivalent pair of terms. Associated type rules ensure that this equivalence holds.

 We will say more about these symbols in \SecRef{more critical pairs}. Tietze transformations.
 This also does not change either the alphabet or rewrite rules of the requirement machine:
\begin{Verbatim}
protocol Base {
  associatedtype Element
}

protocol Derived: Base {
  // associatedtype Element
}
\end{Verbatim}
Suppose we're building a requirement machine for $G_\texttt{Derived}$.
If we then uncomment the redundant associated type declaration, we generate the same list of rewrite rules either way, except now $(\protosym{Derived}\cdot\nElement, \assocsym{Derived}{Element})$ is an associated type rule and not an \emph{inherited} associated type rule.

\paragraph{Protocol type aliases.}
Derived requirements don’t capture protocol type aliases

The second algorithm concerns protocol type aliases. 

Protocol type aliases are part of the rewrite system because they can appear in generic requirements. Here is an example, They must be in the protocol itself and not inside an extension. Link to here from other sections and vice versa.

Written protocols:
\begin{itemize}
\item Underlying type is resolved with structural resolution
\item Protocol type aliases are in fact analogous to same-type requirements where the subject type is an unresolved type \texttt{Self.A}.
\item For protocol minimization machines, we evaluate the \textbf{type alias requirements} request to collect all type alias declarations together.
\end{itemize}

Minimized protocols:
\begin{itemize}
\item For protocol machines, protocol type aliases are encoded in the requirement signature. 
\end{itemize}

Like same-type requirements, we must separately consider the case where the underlying type is a concrete type, and where it is a type parameter. Mention the reduction order thing.

\begin{algorithm}[Build rule for protocol type alias]
Takes a protocol \tP, and a type alias member \nA\ of \tP\ as input. Returns a pair of terms $(u,\,v)$ as output.
\begin{enumerate}
\item Get the \index{underlying type}underlying type of \nA.
\item If the underlying type of \nA\ is concrete, use \AlgRef{concretesymbolcons} to build a concrete type symbol, say~$s$, return the pair:
\[(\pP \cdot \nA \cdot s,\, \pP \cdot \nA)\]
\item If the underlying type of \nA\ is some type parameter \texttt{Self.U}, return the pair:
\[(\pP \cdot \nA,\, \TermP{P}(\texttt{Self.U}))\]
\end{enumerate}
\end{algorithm}

\paragraph{Representation of rules.}
\IndexDefinition{rewrite rule!in requirement machine}%
A rewrite rule is represented by a pair of immutable terms---the \emph{left-hand side} and \emph{right-hand side}---together with some flags. The right-hand side term must precede the left-hand side term in the reduction order, as required by the theory.

The flags associated with each rule are important for \index{completion}completion and minimization:
\begin{itemize}
\IndexDefinition{permanent rule}%
\item \textbf{Permanent} rules are created from associated type declarations and the implicit conformance of the protocol \tSelf\ type to the protocol itself. Permanent rules are not subject to minimization. This bit is set by the rule builder (\SecRef{building rules}).
\index{left-simplified rule}%
\index{right-simplified rule}%
\index{substitution-simplified rule}%
\item \textbf{Left-simplified}, \textbf{right-simplified} and \textbf{substitution-simplified} rules were replaced by new rules (\SecRef{rule reduction}).
\index{conflicting rule}%
\index{recursive rule}%
\item \textbf{Conflicting} rules and \textbf{Recursive} rules are discovered during property map construction, and indicate a problem with user-written requirements that needs to be diagnosed (\ChapRef{propertymap}).
\IndexDefinition{explicit rule}%
\item \textbf{Explicit} rules are directly created from user-written requirements, or related to other explicit rules in a very specific way. This bit is set by the rule builder and then propagated to other rules during minimization. Explicit rules have a special behavior with the minimal conformances algorithm (\SecRef{minimal conformances}).
\index{redundant rule}%
\item \textbf{Redundant} rules are discovered during minimization, after which the requirement builder constructs the final list of minimal requirements from all remaining rules not marked as redundant (\ChapRef{requirement builder}).
\index{frozen rule}%
\item \textbf{Frozen} rules cannot have any of their flags changed. After construction but before a requirement machine is installed in the rewrite context (\ChapRef{rqm basic operation}), all rules are marked frozen to establish the invariant that no further updates can be made to any rule flags.
\end{itemize}
Once a flag has been set, it cannot be cleared, and the frozen flag prevents any more flags from being set.

\index{local rule}%
\index{imported rule}%
A requirement machine stores its rewrite rules in an array. Imported rules appear first, followed by local rules. Often we need to iterate over just the local rules, so we track the index of the first local rule in the array. During rewrite system construction and completion, new rules are appended at the end of the array, but we require that indices into the array remain stable, so rules are never inserted in the middle. Various auxiliary data structures represent references to rules as indices into the rules array:
\begin{itemize}
\item Term reduction repeatedly looks for rules whose left-hand side matches a subterm of a given term; these lookups are made efficient with a prefix trie where each entry references a rule (\SecRef{term reduction}).
\item Property map entries reference the rules they were constructed from.
\index{rewrite path}
\index{rewrite step}
\item Completion and property map construction both need to derive rewrite paths describing equivalences between terms, and these rewrite paths are comprised of rewrite steps which reference rules.
\end{itemize}

\index{local rule}%
\index{imported rule}%

\section{The Normal Form Algorithm}\label{term reduction}

\IndexTwoFlag{debug-requirement-machine}{simplify}

rewrite steps only store the length of each whisker, index of rule, and inverse flag.

\IndexDefinition{trie}
rule trie. Section~6.3 of \cite{art3}.

\begin{algorithm}[Insert rule in rule trie]\label{trie insert algo}
Takes the index of a rewrite rule as input. Has side effects.
\begin{enumerate}
\item (Initialize) Let $N$ be the root node of the trie. Let $i:=0$.
\item (End) If $i=|t|$, store the index of our rewrite rule in~$N$ and return.
\item (Traverse) Let $s_i$ be the $i$th symbol of $t$. Look up $s_i$ in $N$. Create a new node if no such node exists.
\item (Child) Call this child node~$M$. Set $N \leftarrow M$. Set $i \leftarrow i+1$. Go back to Step~2.
\end{enumerate}
\end{algorithm}

\begin{algorithm}[Lookup in rule trie]\label{trie lookup algo}
Takes a term $t$ and an offset $i$ such that $0\leq i<|t|$. Return the index of a rewrite rule~$(u, v)$ such that~$u$ is a prefix of $t[i:]$, or a null value if no such rule exists.
\begin{enumerate}
\item (Initialize) Let $N$ be the root node of the trie.
\item (End) If $i=|t|$, we've reached the end of the term. Return null.
\item (Traverse) Let $s_i$ be the $i$th symbol of $t$. Look up $s_i$ in $N$. Return null if no such node exists.
\item (Child) Otherwise, call this child node~$M$. If $M$ stores the index of a rewrite rule, return this index.
\item (Advance) Set $N \leftarrow M$. Set $i \leftarrow i+1$. Go back to Step~2.
\end{enumerate}
\end{algorithm}

\begin{algorithm}[Normal form algorithm using rule trie]\label{term reduction trie algo}
Takes a mutable term $t$ as input. Mutates $t$, and outputs a \index{positive rewrite path}positive rewrite path~$p$ where $\Src(p)$ is the original term~$t$, and $\Dst(p)$ is the normal form of~$t$.
\begin{enumerate}
\item (Initialize) Initialize the return value $p$ with the empty rewrite path $1_p$. Let $i := 0$.
\item (End) If $i=|t|$, return $p$.
\item (Lookup) Invoke \AlgRef{trie lookup algo} with $t$ and $i$.
\item (Rewrite) If we found a rewrite rule $(u, v)$, then let $x := t[i:]$, $y := t[:i+|u|]$. Replace the subterm $t[i:i+|u|]$ with $v$, set $i\leftarrow i+1$, set $p\leftarrow p\circ x(u\Rightarrow v)y$, and go back to Step~2.
\item (Done) Otherwise, $t$ is reduced. Return $p$.
\end{enumerate}
\end{algorithm}

\begin{algorithm}[Record rewrite rule]\label{add rewrite rule}
Takes a pair of terms $(u,v)$ as input. Has side effects.
\begin{enumerate}
\item (Reduce) Apply \AlgRef{term reduction trie algo} to $u$ and $v$ to obtain $\tilde{u}$ and $\tilde{v}$.
\item (Trivial) If $\tilde{u}=\tilde{v}$, return.
\item (Compare) Use \AlgRef{rqm reduction order} to compare $\tilde{u}$ with $\tilde{v}$.
\item (Error) If $\tilde{u}$ and $\tilde{v}$ are incomparable, signal an error.
\item (Orient) If $\tilde{v}>\tilde{u}$, swap $\tilde{u}$ and $\tilde{v}$.
\item (Record) Add $(\tilde{u},\tilde{v})$ to the list of local rules.
\item (Trie) Invoke \AlgRef{trie insert algo} to insert the new local rule in the trie.
\end{enumerate}
\end{algorithm}

Our implementation explicitly stores the source and destination terms in a critical pair, as well as the rewrite path itself. As we will learn in \SecRef{completion sourceref}, we use a compressed representation for \index{rewrite path!representation}rewrite paths in memory, where a \index{rewrite step!representation}rewrite step $x(u\Rightarrow v)y$ only stores the \emph{length} of each \index{whiskering}whisker $x$ and $y$ and not the actual terms $x$ and $y$. Thus, we must store the source and destination terms separately since they cannot be recovered from the rewrite path alone.

Aho-Corasick algorithm \cite{ahocorasick}.

\section{Source Code Reference}\label{symbols terms rules sourceref}

\subsection*{Symbols}

Key source files:
\begin{itemize}
\item \SourceFile{lib/AST/RequirementMachine/Symbol.h}
\item \SourceFile{lib/AST/RequirementMachine/Symbol.cpp}
\item \SourceFile{lib/AST/RequirementMachine/Term.h}
\item \SourceFile{lib/AST/RequirementMachine/Term.cpp}
\item \SourceFile{lib/AST/RequirementMachine/Trie.h}
\end{itemize}

\apiref{rewriting::Symbol::Kind}{enum class}

The symbol kind. The order of the cases is significant; it is from the reduction order on symbols (\AlgRef{symbol reduction order}).
\begin{itemize}
\item \texttt{ConcreteConformance}
\item \texttt{Protocol}
\item \texttt{AssociatedType}
\item \texttt{GenericParam}
\item \texttt{Layout}
\item \texttt{Superclass}
\item \texttt{ConcreteType}
\end{itemize}

\apiref{rewriting::Symbol}{class}
\IndexSource{symbol}
\IndexSource{name symbol}
\IndexSource{protocol symbol}
\IndexSource{associated type symbol}
\IndexSource{generic parameter symbol}
\IndexSource{concrete type symbol}
\IndexSource{superclass symbol}
\IndexSource{layout symbol}
\IndexSource{concrete conformance symbol}
Represents an immutable, uniqued symbol. Meant to be passed as a value, it wraps a single pointer to internal storage. Symbols are logically variant types, but C++ does not directly support that concept so there is a bit of boilerplate in their definition.

\IndexSource{pattern type}
\IndexSource{substitution term}
Symbols are constructed with a set of static factory methods which take the structural components and the \texttt{RewriteContext}:
\begin{itemize}
\item \texttt{forName()} takes an \texttt{Identifier}.
\item \texttt{forProtocol()} takes a \texttt{ProtocolDecl *}.
\item \texttt{forAssociatedType()} takes a \texttt{ProtocolDecl *} and \texttt{Identifier}.
\item \texttt{forGenericParam()} takes a canonical \texttt{GenericTypeParamType *}.
\item \texttt{forLayout()} takes a \texttt{LayoutConstraint}.
\item \texttt{forSuperclass()} takes a pattern type and substitution terms.
\item \texttt{forConcreteType()} takes a pattern type and substitution terms.
\item \texttt{forConcreteConformance()} also takes a \texttt{ProtocolDecl *}.
\end{itemize}
The last three methods take the pattern type as a \texttt{CanType} and the substitution terms as an \texttt{ArrayRef<CanType>}. The \texttt{RewriteContext::getSubstitutionSchemaFromType()} method implements \AlgRef{concretesymbolcons} to build the pattern type and substitution terms from an arbitrary \texttt{Type}. Note that the pattern type is always a canonical type, so type sugar is not preserved when round-tripped through the Requirement Machine, for example when building a new generic signature.

Taking symbols apart:
\begin{itemize}
\item \texttt{getKind()} returns the \texttt{Symbol::Kind}.
\item \texttt{getName()} returns the \texttt{Identifier} stored in a name or associated type symbol.
\item \texttt{getProtocol()} returns the \texttt{ProtocolDecl *} stored in a protocol, associated type or concrete conformance symbol.
\item \texttt{getGenericParam()} returns the \texttt{GenericTypeParamDecl *} stored in a generic parameter symbol.
\item \texttt{getLayoutConstraint()} returns the \texttt{LayoutConstraint} stored in a layout symbol.
\item \texttt{getConcreteType()} returns the pattern type stored in a superclass, concrete type or concrete conformance symbol.
\item \texttt{getSubstitutions()} returns the substitution terms stored in a superclass, concrete type or concrete conformance symbol.
\item \texttt{getRootProtocol()} returns \texttt{nullptr} if this is a generic parameter symbol, or a protocol declaration if this is a protocol or associated type symbol. Otherwise, asserts. This is the ``domain'' of the symbol.
\end{itemize}
Comparing symbols:
\begin{itemize}
\item \texttt{operator==} tests for equality.
\item \texttt{compare()} is the symbol reduction order (\AlgRef{symbol reduction order}). The return type of \texttt{Optional<int>} encodes the result as follows:
\begin{itemize}
\item \verb|None|: $\bot$
\item \verb|Some(0)|: $=$
\item \verb|Some(-1)|: $<$
\item \verb|Some(1)|: $>$
\end{itemize}
\end{itemize}
Debugging:
\begin{itemize}
\item \texttt{dump()} prints a human-readable representation of a symbol.
\end{itemize}

\apiref{rewriting::Term}{class}
\IndexSource{term!in requirement machine}
\IndexSource{immutable term}
An immutable term. Meant to be passed as a value, it wraps a single pointer to internal storage. Immutable terms are created by a static factory method:
\begin{itemize}
\item \texttt{get()} creates a \texttt{Term} from a \texttt{MutableTerm}, which must be non-empty.
\end{itemize}
Looking at terms:
\begin{itemize}
\item \texttt{containsUnresolvedSymbols()} returns true if the term contains name symbols.
\item \texttt{getRootProtocol()} returns \texttt{nullptr} if the first symbol is a generic parameter symbol, otherwise returns the protocol of the first protocol or associated type symbol. Asserts if the first symbol has any other kind.
\item \texttt{size()}, \texttt{begin()}, \texttt{end()}, \texttt{rbegin()}, \texttt{rend()}, \texttt{operator[]} are the standard C++ operations for iteration and indexing into the term, as an array of \texttt{Symbol}.
\item \texttt{back()} returns the last \texttt{Symbol} in the term.
\end{itemize}
Comparing terms:
\begin{itemize}
\item \texttt{operator==} tests for equality.
\item \texttt{compare()} is the term reduction order (\AlgRef{rqm reduction order}). The return type of \texttt{Optional<int>} encodes the result in the same manner as \texttt{Symbol::compare()}.
\end{itemize}
Debugging:
\begin{itemize}
\item \texttt{dump()} prints a human-readable representation of a term.
\end{itemize}

\apiref{rewriting::MutableTerm}{class}
\IndexSource{mutable term}
A mutable term. Meant to be passed as a value or const reference. Owns a heap-allocated buffer for storing its own elements. The default constructor creates an \IndexSource{empty term}empty \texttt{MutableTerm}. The other constructors allow specifying an initial list of symbols as an iterator pair, \texttt{ArrayRef}, or the symbols of an immutable \texttt{Term}.

Supports the same operations as \texttt{Term}, together with various mutating methods:
\begin{itemize}
\item \texttt{add()} pushes a single \texttt{Symbol} on the end of the term.
\end{itemize}

\apiref{rewriting::Rule}{class}
\IndexSource{rewrite rule!in requirement machine}

\apiref{rewriting::RewriteSystem}{class}
\IndexSource{rewrite system!in requirement machine}

See also \SecRef{completion sourceref}.

\begin{itemize}
\item \texttt{simplify()} reduces a term using \AlgRef{term reduction trie algo}.
\end{itemize}

\apiref{rewriting::RewriteContext}{class}

\apiref{rewriting::RuleBuilder}{class}
\IndexSource{rule builder}
collectRulesFromReferencedProtocols() is actually the algorithm from the previous section.

\apiref{rewriting::Trie}{template class}
\IndexSource{trie}

See also \SecRef{completion sourceref}.
\begin{itemize}
\item \texttt{insert()} inserts an entry using \AlgRef{trie insert algo}.
\item \texttt{find()} finds an entry using \AlgRef{trie lookup algo}.
\end{itemize}

\end{document}
