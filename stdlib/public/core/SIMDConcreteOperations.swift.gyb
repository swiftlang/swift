//===--- SIMDConcreteOperations.swift -------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2021 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
from SwiftIntTypes import all_integer_types
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8
storagescalarCounts = [2,4,8,16,32,64]
vectorscalarCounts = storagescalarCounts + [3]
}%

%for int in all_integer_types(word_bits):
% Scalar = int.stdlib_name
% for n in vectorscalarCounts:
%  Vector = "SIMD" + str(n) + "<" + Scalar + ">"
%  storageN = 4 if n == 3 else n
%  s = "s" if int.is_signed else "u"
%  Builtin = "Vec" + str(storageN) + "xInt" + str(int.bits)
%  Int1Vec = "Vec" + str(storageN) + "xInt1"
%  MaskExt = "Builtin.sext_" + Int1Vec + "_" + Builtin
%  if int.is_signed:
extension SIMDMask where Storage == ${Vector} {
  @_alwaysEmitIntoClient
  internal init(_ _builtin: Builtin.${Builtin}) {
    _storage = ${Vector}(_builtin)
  }
    
  /// A vector with the specified value in all lanes.
  @_alwaysEmitIntoClient
  public init(repeating scalar: Bool) {
    _storage = ${Vector}(repeating: scalar ? -1 : 0)
  }
  
  @_alwaysEmitIntoClient
  internal static var allTrue: Self {
    let zero = ${Vector}()
    return zero .== zero
  }
  
  /// A vector mask that is the pointwise logical negation of the input.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = !a[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public static prefix func .!(a: Self) -> Self {
    a .^ .allTrue
  }
    
  /// A vector mask that is the pointwise logical conjunction of the inputs.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] && b[i]
  /// }
  /// ```
  ///
  /// Note that unlike the scalar `&&` operator, the SIMD `.&` operator
  /// always fully evaluates both arguments.
  @_alwaysEmitIntoClient
  public static func .&(a: Self, b: Self) -> Self {
    Self(${Vector}(Builtin.and_${Builtin}(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
    
  /// Replaces `a` with the pointwise logical conjunction of `a` and `b`.
  ///
  /// Equivalent to:
  /// ```
  /// for i in a.indices {
  ///   a[i] = a[i] && b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public static func .&=(a: inout Self, b: Self) {
    a = a .& b
  }
      
  /// A vector mask that is the pointwise exclusive or of the inputs.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] != b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public static func .^(a: Self, b: Self) -> Self {
    Self(${Vector}(Builtin.xor_${Builtin}(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
    
  /// Replaces `a` with the pointwise exclusive or of `a` and `b`.
  ///
  /// Equivalent to:
  /// ```
  /// for i in a.indices {
  ///   a[i] = a[i] != b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public static func .^=(a: inout Self, b: Self) {
    a = a .^ b
  }
      
  /// A vector mask that is the pointwise logical disjunction of the inputs.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] || b[i]
  /// }
  /// ```
  ///
  /// Note that unlike the scalar `||` operator, the SIMD `.|` operator
  /// always fully evaluates both arguments.
  @_alwaysEmitIntoClient
  public static func .|(a: Self, b: Self) -> Self {
    Self(${Vector}(Builtin.or_${Builtin}(
      a._storage._storage._value,
      b._storage._storage._value
    )))
  }
    
  /// Replaces `a` with the pointwise logical disjunction of `a` and `b`.
  ///
  /// Equivalent to:
  /// ```
  /// for i in a.indices {
  ///   a[i] = a[i] || b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public static func .|=(a: inout Self, b: Self) {
    a = a .| b
  }
    
  /// A vector mask with the result of a pointwise equality comparison.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] == b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public static func .==(a: Self, b: Self) -> Self {
    .!(a .^ b)
  }
  
  /// A vector mask with the result of a pointwise inequality comparison.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] != b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public static func .!=(a: Self, b: Self) -> Self {
    a .^ b
  }
    
  /// Replaces elements of this vector with elements of `other` in the lanes
  /// where `mask` is `true`.
  ///
  /// Equivalent to:
  /// ```
  /// for i in indices {
  ///   if mask[i] { self[i] = other[i] }
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public mutating func replace(with other: Self, where mask: Self) {
    self = replacing(with: other, where: mask)
  }
    
  /// Returns a copy of this vector, with elements replaced by elements of
  /// `other` in the lanes where `mask` is `true`.
  ///
  /// Equivalent to:
  /// ```
  /// var result = Self()
  /// for i in indices {
  ///   result[i] = mask[i] ? other[i] : self[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public func replacing(with other: Self, where mask: Self) -> Self {
    (self .& .!mask) .| (other .& mask)
  }
  
  /// Returns a vector mask with `true` or `false` randomly assigned in each
  /// lane, using the given generator as a source for randomness.
  @_alwaysEmitIntoClient
  public static func random<T: RandomNumberGenerator>(using generator: inout T) -> Self {
    let data = Builtin.truncOrBitCast_Int64_Int${storageN}(generator.next()._value)
    return Self(${MaskExt}(
      Builtin.bitcast_Int${storageN}_Vec${storageN}xInt1(data)
    ))
  }
  
  /// Returns a vector mask with `true` or `false` randomly assigned in each
  /// lane.
  @_alwaysEmitIntoClient
  public static func random() -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(using: &g)
  }
}

/// True if any lane of mask is true.
@_alwaysEmitIntoClient
public func any(_ mask: SIMDMask<${Vector}>) -> Bool {
#if arch(i386) || arch(x86_64)
% mask = hex((1 << n) - 1)
  return mask._storage.movemask() & ${mask} != 0
#else
  return mask._storage.min() < 0
#endif
}

/// True if every lane of mask is true.
@_alwaysEmitIntoClient
public func all(_ mask: SIMDMask<${Vector}>) -> Bool {
#if arch(i386) || arch(x86_64)
% mask = hex((1 << n) - 1)
  return mask._storage.movemask() & ${mask} == ${mask}
#else
  return mask._storage.max() < 0
#endif
}

%  end
extension SIMD${n} where Scalar == ${Scalar} {
  @_alwaysEmitIntoClient
  internal init(_ _builtin: Builtin.${Builtin}) {
    _storage = ${Scalar}.SIMD${storageN}Storage(_builtin)
  }

#if arch(i386) || arch(x86_64)
  /// Implements the x86 PMOVMSKB / MOVMSKPS / MOVMSKPD instruction
  /// semantics. Not available on other targets.
  @_alwaysEmitIntoClient
  internal func movemask() -> UInt${max(n, 8)} {
    let zero: Builtin.${Builtin} = Builtin.zeroInitializer()
    let mask = Builtin.cmp_slt_${Builtin}(_storage._value, zero)
    let int = Builtin.bitcast_${Int1Vec}_Int${storageN}(mask)
    return UInt${max(n, 8)}(
      Builtin.zextOrBitCast_Int${storageN}_Int${max(n, 8)}(int)
    )
  }
#endif
    
  /// A vector with the specified value in all lanes.
  @_alwaysEmitIntoClient
  public init(repeating scalar: ${Scalar}) {
    let vec = Builtin.insertelement_${Builtin}_Int${int.bits}_Int32(
      Builtin.zeroInitializer(), scalar._value, Builtin.zeroInitializer()
    )
    self.init(Builtin.shufflevector_${Builtin}_Vec${storageN}xInt32(
      vec, vec, Builtin.zeroInitializer()
    ))
  }
    
  /// A vector mask with the result of a pointwise equality comparison.
  @_alwaysEmitIntoClient
  public static func .==(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_eq_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise inequality comparison.
  @_alwaysEmitIntoClient
  public static func .!=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_ne_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise less-than comparison.
  @_alwaysEmitIntoClient
  public static func .<(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}lt_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise less-than-or-equal-to comparison.
  @_alwaysEmitIntoClient
  public static func .<=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}le_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise greater-than comparison.
  @_alwaysEmitIntoClient
  public static func .>(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}gt_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise greater-than-or-equal-to comparison.
  @_alwaysEmitIntoClient
  public static func .>=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}ge_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
    
  /// The wrapping sum of two vectors.
  @_alwaysEmitIntoClient
  public static func &+(a: Self, b: Self) -> Self {
    Self(Builtin.add_${Builtin}(a._storage._value, b._storage._value))
  }
    
  /// The wrapping difference of two vectors.
  @_alwaysEmitIntoClient
  public static func &-(a: Self, b: Self) -> Self {
    Self(Builtin.sub_${Builtin}(a._storage._value, b._storage._value))
  }
    
  /// The pointwise wrapping product of two vectors.
  @_alwaysEmitIntoClient
  public static func &*(a: Self, b: Self) -> Self {
    Self(Builtin.mul_${Builtin}(a._storage._value, b._storage._value))
  }
        
  /// Updates the left hand side with the wrapping sum of the two
  /// vectors.
  @_alwaysEmitIntoClient
  public static func &+=(a: inout Self, b: Self) { a = a &+ b }
    
  /// Updates the left hand side with the wrapping difference of the two
  /// vectors.
  @_alwaysEmitIntoClient
  public static func &-=(a: inout Self, b: Self) { a = a &- b }
    
  /// Updates the left hand side with the pointwise wrapping product of two
  /// vectors.
  @_alwaysEmitIntoClient
  public static func &*=(a: inout Self, b: Self) { a = a &* b }
      
  /// The least scalar in the vector.
  ///
  /// Equivalent to:
  /// ```
  /// indices.reduce(into: Scalar.max) {
  ///   $0 = min($0, self[$1])
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public func min() -> Scalar {
  % if n == 3:
    var storage = _storage
    storage[3] = Scalar.max
  % else:
    let storage = _storage
  % end
  % if int.is_signed:
    return Scalar(Builtin.int_vector_reduce_smin_${Builtin}(storage._value))
  % else:
    return Scalar(Builtin.int_vector_reduce_umin_${Builtin}(storage._value))
  % end
  }
      
  /// The greatest element in the vector.
  ///
  /// Equivalent to:
  /// ```
  /// indices.reduce(into: Scalar.min) {
  ///   $0 = max($0, self[$1])
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public func max() -> Scalar {
  % if n == 3:
    var storage = _storage
    storage[3] = Scalar.min
  % else:
    let storage = _storage
  % end
  % if int.is_signed:
    return Scalar(Builtin.int_vector_reduce_smax_${Builtin}(storage._value))
  % else:
    return Scalar(Builtin.int_vector_reduce_umax_${Builtin}(storage._value))
  % end
  }
    
  /// Returns the sum of the scalars in the vector, computed with wrapping
  /// addition.
  ///
  /// Equivalent to:
  /// ```
  /// indices.reduce(into: 0) {
  ///   $0 &+= self[$1]
  /// }
  /// ```
  @_alwaysEmitIntoClient
  public func wrappedSum() -> Scalar {
  % if n == 3:
    var storage = _storage
    storage[3] = 0
  % else:
    let storage = _storage
  % end
  return Scalar(Builtin.int_vector_reduce_add_${Builtin}(storage._value))
  }
}

% end
%end

%for (Scalar, bits) in [('Float16',16), ('Float',32), ('Double',64)]:
% for n in vectorscalarCounts:
%  Vector = "SIMD" + str(n) + "<" + Scalar + ">"
%  storageN = 4 if n == 3 else n
%  Builtin = "Vec" + str(storageN) + "xFPIEEE" + str(bits)
%  VecPre = "Vec" + str(storageN) + "x"
%  MaskExt = "Builtin.sext_" + VecPre + "Int1_" + VecPre + "Int" + str(bits)
%  if bits == 16:
#if !((os(macOS) || targetEnvironment(macCatalyst)) && arch(x86_64))
@available(SwiftStdlib 5.3, *)
%  end
extension SIMD${n} where Scalar == ${Scalar} {
  @_alwaysEmitIntoClient
  internal init(_ _builtin: Builtin.${Builtin}) {
    _storage = ${Scalar}.SIMD${storageN}Storage(_builtin)
  }
    
  /// A vector with the specified value in all lanes.
  @_alwaysEmitIntoClient
  public init(repeating scalar: ${Scalar}) {
    let vec = Builtin.insertelement_${Builtin}_FPIEEE${bits}_Int32(
      Builtin.zeroInitializer(), scalar._value, Builtin.zeroInitializer()
    )
    self.init(Builtin.shufflevector_${Builtin}_Vec${storageN}xInt32(
      vec, vec, Builtin.zeroInitializer()
    ))
  }
  
  /// A vector mask with the result of a pointwise equality comparison.
  @_alwaysEmitIntoClient
  public static func .==(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.fcmp_oeq_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise inequality comparison.
  @_alwaysEmitIntoClient
  public static func .!=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.fcmp_une_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise less-than comparison.
  @_alwaysEmitIntoClient
  public static func .<(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.fcmp_olt_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise less-than-or-equal-to comparison.
  @_alwaysEmitIntoClient
  public static func .<=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.fcmp_ole_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise greater-than comparison.
  @_alwaysEmitIntoClient
  public static func .>(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.fcmp_ogt_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise greater-than-or-equal-to comparison.
  @_alwaysEmitIntoClient
  public static func .>=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.fcmp_oge_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
}
%  if bits == 16:
#endif
%  end

% end
%end
