//===--- SIMDIntegerConcreteOperations.swift ------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2021-2025 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
from SwiftIntTypes import all_integer_types
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8
storagescalarCounts = [2,4,8,16,32,64]
vectorscalarCounts = storagescalarCounts + [3]
}%

%for int in all_integer_types(word_bits):
% Scalar = int.stdlib_name
% for n in vectorscalarCounts:
%  Vector = "SIMD" + str(n) + "<" + Scalar + ">"
%  storageN = 4 if n == 3 else n
%  s = "s" if int.is_signed else "u"
%  Builtin = "Vec" + str(storageN) + "xInt" + str(int.bits)
%  MaskExt = "Builtin.sext_Vec" + str(storageN) + "xInt1_" + Builtin
extension SIMD${n} where Scalar == ${Scalar} {
  @_alwaysEmitIntoClient
  internal init(_ _builtin: Builtin.${Builtin}) {
    _storage = ${Scalar}.SIMD${storageN}Storage(_builtin)
  }
    
  /// A vector mask with the result of a pointwise equality comparison.
  @_alwaysEmitIntoClient
  public static func .==(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_eq_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise inequality comparison.
  @_alwaysEmitIntoClient
  public static func .!=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_ne_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise less-than comparison.
  @_alwaysEmitIntoClient
  public static func .<(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}lt_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise less-than-or-equal-to comparison.
  @_alwaysEmitIntoClient
  public static func .<=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}le_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise greater-than comparison.
  @_alwaysEmitIntoClient
  public static func .>(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}gt_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
  
  /// A vector mask with the result of a pointwise greater-than-or-equal-to comparison.
  @_alwaysEmitIntoClient
  public static func .>=(a: Self, b: Self) -> SIMDMask<MaskStorage> {
    SIMDMask<MaskStorage>(${MaskExt}(
      Builtin.cmp_${s}ge_${Builtin}(a._storage._value, b._storage._value)
    ))
  }
    
  /// The wrapping sum of two vectors.
  @_alwaysEmitIntoClient
  public static func &+(a: Self, b: Self) -> Self {
    Self(Builtin.add_${Builtin}(a._storage._value, b._storage._value))
  }
    
  /// The wrapping difference of two vectors.
  @_alwaysEmitIntoClient
  public static func &-(a: Self, b: Self) -> Self {
    Self(Builtin.sub_${Builtin}(a._storage._value, b._storage._value))
  }
    
  /// The pointwise wrapping product of two vectors.
  @_alwaysEmitIntoClient
  public static func &*(a: Self, b: Self) -> Self {
    Self(Builtin.mul_${Builtin}(a._storage._value, b._storage._value))
  }
        
  /// Updates the left hand side with the wrapping sum of the two
  /// vectors.
  @_alwaysEmitIntoClient
  public static func &+=(a: inout Self, b: Self) { a = a &+ b }
    
  /// Updates the left hand side with the wrapping difference of the two
  /// vectors.
  @_alwaysEmitIntoClient
  public static func &-=(a: inout Self, b: Self) { a = a &- b }
    
  /// Updates the left hand side with the pointwise wrapping product of two
  /// vectors.
  @_alwaysEmitIntoClient
  public static func &*=(a: inout Self, b: Self) { a = a &* b }
}

% end
%end
