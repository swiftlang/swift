%for N in [2,3,4,8,16,32,64]:
/// A computational vector with ${N} elements.
public protocol SIMDVector${N} : SIMDVector where Predicate : SIMDVector${N} {
% if N >= 4:
  /// A type representing half of the vector.
  associatedtype HalfVector: SIMDVector${N/2} where HalfVector.Element == Element

  init(lowHalf: HalfVector, highHalf: HalfVector)

  var lowHalf: HalfVector { get set }

  var highHalf: HalfVector { get set }

  var evenHalf: HalfVector { get set }

  var oddHalf: HalfVector { get set }
% end
}

//  Non-customizable operations on SIMDVector${N}
public extension SIMDVector${N} {

  @inlinable
  init(${', '.join(['_ v' + str(n) + ': Element' for n in range(N)])}) {
    self.init()
% for n in range(N):
    self[${n}] = v${n}
% end
  }

% if N <= 4:
  @inlinable
  init(${', '.join([c + ': Element' for c in 'xyzw'[:N]])}) {
    self.init(${', '.join('xyzw'[:N])})
  }

%  for n in range(N):
  @_transparent
  var ${'xyzw'[n]}: Element {
    @_transparent get { return self[${n}]}
    @_transparent set { self[${n}] = newValue }
  }

%  end
% end
  @inlinable
  init<D, I>(gathering source: D, at index: I)
  where D : SIMDVector, D.Element == Element,
        I : SIMDIntegerVector & SIMDVector${N} {
    self.init()
    for i in indices {
      if index[i] >= 0 && index[i] < source.count {
        self[i] = source[Int(index[i])]
      }
    }
  }
}

//  Defaulted conformance to RandomAccessCollection.
public extension SIMDVector${N} {
  @inlinable
  var endIndex: Int {
    return ${N}
  }
}

//  Defaulted conformance to SIMDVector.
public extension SIMDVector${N} {
  @inlinable
  init(repeating x: Element) {
    self.init(${', '.join('x'*N)})
  }

  @inlinable
  init(arrayLiteral elements: Element...) {
    self.init(fromArray: elements)
  }

  @inlinable
  init(fromArray array: [Element]) {
    _precondition(array.count == ${N})
    self.init()
    for i in indices { self[i] = array[i] }
  }
}
% if N >= 4:

//  Defaulted conformance to SIMDVectorN, providing the half-vector accessors.
public extension SIMDVector${N} {
  @_transparent
  init(lowHalf: HalfVector, highHalf: HalfVector) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }

  // Implementing these via for-loop looks inefficient, but the optimizer
  // is generally pretty good at recognizing the idiom and mapping this to
  // a single shuffle-vector operation. For any outstanding cases we find,
  // we can either work on the optimizer, specialize for the types where the
  // codegen is bad, or add a header-inline C shim that just wraps the
  // shufflevector operation that we want to generate if necessary.
%  for (half,indx) in [('low','i'), ('high',str(N/2)+'+i'), ('even','2*i'), ('odd','2*i+1')]:
  var ${half}Half: HalfVector {
    @inlinable
    get {
      var result = HalfVector()
      for i in result.indices { result[i] = self[${indx}] }
      return result
    }

    @inlinable
    set {
      for i in newValue.indices { self[${indx}] = newValue[i] }
    }
  }
%  end
}

% end
%end
