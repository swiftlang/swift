//===--- SIMDMaskConcreteOperations.swift ---------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2021-2025 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
from SwiftIntTypes import all_signed_types
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8
storagescalarCounts = [2,4,8,16,32,64]
vectorscalarCounts = storagescalarCounts + [3]
logical = [
  ("&", "&&", "and"),
  ("^", "!=", "exclusive or"),
  ("|", "||", "inclusive or"),
]
}%

%for int in all_signed_types(word_bits):
% Scalar = int.stdlib_name
% for n in vectorscalarCounts:
%  Vector = "SIMD" + str(n) + "<" + Scalar + ">"
%  storageN = 4 if n == 3 else n
%  s = "s"
%  Builtin = "Vec" + str(storageN) + "xInt" + str(int.bits)
%  MaskExt = "Builtin.sext_Vec" + str(storageN) + "xInt1_" + Builtin
extension SIMDMask where Storage == ${Vector} {
  @_alwaysEmitIntoClient @_transparent
  internal init(_ _builtin: Builtin.${Builtin}) {
    _storage = ${Vector}(_builtin)
  }
  
  @_alwaysEmitIntoClient @_transparent
  public init(repeating scalar: Bool) {
    _storage = ${Vector}(repeating: scalar ? -1 : 0)
  }
  
  @_alwaysEmitIntoClient
  internal static var allTrue: Self {
    let zero = ${Vector}()
    return zero .== zero
  }
  
  /// Pointwise logical negation
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = !a[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient @_transparent
  public static prefix func .!(a: Self) -> Self {
    Self(~a._storage)
  }
    
%  for (op, scalarOp, description) in logical:
  /// Pointwise logical ${description}.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] ${scalarOp} b[i]
  /// }
  /// ```
  ///
  /// Note that unlike the scalar `&&` and `||` operators, the SIMD logical
  /// operators `.&`, `.|`, and `.^` always fully evaluate both sides of the
  /// expression.
  @_alwaysEmitIntoClient @_transparent
  public static func .${op}(a: Self, b: Self) -> Self {
    Self(a._storage ${op} b._storage)
  }
  
  /// In-place pointwise logical ${description}.
  ///
  /// Equivalent to:
  /// ```
  /// for i in result.indices {
  ///   a[i] ${scalarOp}= b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient @_transparent
  public static func .${op}=(a: inout Self, b: Self) {
    a = a .${op} b
  }
  
%  end
  /// Pointwise compare equal to.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] == b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient @_transparent
  public static func .==(a: Self, b: Self) -> Self {
    .!(a .^ b)
  }
  
  /// Pointwise compare not equal to.
  ///
  /// Equivalent to:
  /// ```
  /// var result = SIMDMask<${Vector}>()
  /// for i in result.indices {
  ///   result[i] = a[i] != b[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient @_transparent
  public static func .!=(a: Self, b: Self) -> Self {
    a .^ b
  }
    
  /// Replaces elements of this vector with elements of `other` in the lanes
  /// where `mask` is `true`.
  ///
  /// Equivalent to:
  /// ```
  /// for i in indices {
  ///   if mask[i] { self[i] = other[i] }
  /// }
  /// ```
  @_alwaysEmitIntoClient @_transparent
  public mutating func replace(with other: Self, where mask: Self) {
    self = replacing(with: other, where: mask)
  }
    
  /// Returns a copy of this vector, with elements replaced by elements of
  /// `other` in the lanes where `mask` is `true`.
  ///
  /// Equivalent to:
  /// ```
  /// var result = Self()
  /// for i in indices {
  ///   result[i] = mask[i] ? other[i] : self[i]
  /// }
  /// ```
  @_alwaysEmitIntoClient @_transparent
  public func replacing(with other: Self, where mask: Self) -> Self {
    (self .& .!mask) .| (other .& mask)
  }
}

% end
%end
