%import gyb

import Foundation
import CoreFoundation

// NSError and CFError conform to the standard ErrorType protocol. Compiler
// magic allows this to be done as a "toll-free" conversion when an NSError
// or CFError is used as an ErrorType existential.

extension NSError : ErrorType {
  public var _domain: String { return domain }
  public var _code: Int { return code }
}

extension CFError : ErrorType {
  public var _domain: String {
    return CFErrorGetDomain(self) as String
  }

  public var _code: Int {
    return CFErrorGetCode(self)
  }
}

// An error value to use when an Objective-C API indicates error
// but produces a nil error object.
public enum _GenericObjCError : ErrorType {
  case NilError
}

/// An intrinsic used by the runtime to create an error when an
/// Objective-C API indicates failure but produces a nil error.
@asmname("_swift_allocNilObjCError")
func _allocNilObjCError() -> ErrorType {
  return _GenericObjCError.NilError
}

/// An internal protocol to represent Swift error enums that map to standard
/// Cocoa NSError domains.
public protocol _ObjectiveCBridgeableErrorType : ErrorType {
  /// Produce a value of the error type corresponding to the given NSError,
  /// or return nil if it cannot be bridged.
  init?(_bridgedNSError: NSError)
}

%{

# Cocoa domains and their mapping information.
#
# Each entry in this dictionary is a mapping from the name of the
# enumeration type to the set of errors in that domain.
mappedDomains = {
  'NSCocoaError': [
    # TODO: Split this up into subdomains based on the Minimum/Maximum
    # delimited ranges?

    # Foundation errors
    ('NSFileNoSuchFileError', '', 0),
    ('NSFileLockingError', '', 0),
    ('NSFileReadUnknownError', '', 0),
    ('NSFileReadNoPermissionError', '', 0),
    ('NSFileReadInvalidFileNameError', '', 0),
    ('NSFileReadCorruptFileError', '', 0),
    ('NSFileReadNoSuchFileError', '', 0),
    ('NSFileReadInapplicableStringEncodingError', '', 0),
    ('NSFileReadUnsupportedSchemeError', '', 0),
    ('NSFileReadTooLargeError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSFileReadUnknownStringEncodingError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSFileWriteUnknownError', '', 0),
    ('NSFileWriteNoPermissionError', '', 0),
    ('NSFileWriteInvalidFileNameError', '', 0),
    ('NSFileWriteFileExistsError', 'available(OSX 10.7, iOS 5.0, *)', 0),
    ('NSFileWriteInapplicableStringEncodingError', '', 0),
    ('NSFileWriteUnsupportedSchemeError', '', 0),
    ('NSFileWriteOutOfSpaceError', '', 0),
    ('NSFileWriteVolumeReadOnlyError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSKeyValueValidationError', '', 0),
    ('NSFormattingError', '', 0),
    ('NSUserCancelledError', '', 0),
    ('NSFeatureUnsupportedError', 'available(OSX 10.8, iOS 6.0, *)', 0),
    ('NSExecutableNotLoadableError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableArchitectureMismatchError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableRuntimeMismatchError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableLoadError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSExecutableLinkError', 'available(OSX 10.5, iOS 2.0, *)', 0),
    ('NSPropertyListReadCorruptError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListReadUnknownVersionError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListReadStreamError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListWriteStreamError', 'available(OSX 10.6, iOS 4.0, *)', 0),
    ('NSPropertyListWriteInvalidError', 'available(OSX 10.10, iOS 8.0, *)', 0),

    ('NSXPCConnectionInterrupted', 'available(OSX 10.8, iOS 6.0, *)', 0),
    ('NSXPCConnectionInvalid', 'available(OSX 10.8, iOS 6.0, *)', 0),
    ('NSXPCConnectionReplyInvalid', 'available(OSX 10.8, iOS 6.0, *)', 0),

    ('NSUbiquitousFileUnavailableError', 'available(OSX 10.9, iOS 7.0, *)', 0),
    ('NSUbiquitousFileNotUploadedDueToQuotaError', 'available(OSX 10.9, iOS 7.0, *)', 0),
    ('NSUbiquitousFileUbiquityServerNotAvailable', 'available(OSX 10.9, iOS 7.0, *)', 0),

    ('NSUserActivityHandoffFailedError', 'available(OSX 10.10, iOS 8.0, *)', 0),
    ('NSUserActivityConnectionUnavailableError', 'available(OSX 10.10, iOS 8.0, *)', 0),
    ('NSUserActivityRemoteApplicationTimedOutError', 'available(OSX 10.10, iOS 8.0, *)', 0),
    ('NSUserActivityHandoffUserInfoTooLargeError', 'available(OSX 10.10, iOS 8.0, *)', 0),

    ('NSCoderReadCorruptError', 'available(OSX 10.11, iOS 9.0, *)', 0),
    ('NSCoderValueNotFoundError', 'available(OSX 10.11, iOS 9.0, *)', 0),

    # CoreData errors.
    ('NSManagedObjectValidationError', '', 1550),
    ('NSValidationMultipleErrorsError', '', 1560),
    ('NSValidationMissingMandatoryPropertyError', '', 1570),
    ('NSValidationRelationshipLacksMinimumCountError', '', 1580),
    ('NSValidationRelationshipExceedsMaximumCountError', '', 1590),
    ('NSValidationRelationshipDeniedDeleteError', '', 1600),
    ('NSValidationNumberTooLargeError', '', 1610),
    ('NSValidationNumberTooSmallError', '', 1620),
    ('NSValidationDateTooLateError', '', 1630),
    ('NSValidationDateTooSoonError', '', 1640),
    ('NSValidationInvalidDateError', '', 1650),
    ('NSValidationStringTooLongError', '', 1660),
    ('NSValidationStringTooShortError', '', 1670),
    ('NSValidationStringPatternMatchingError', '', 1680),
    ('NSManagedObjectContextLockingError', '', 132000),
    ('NSPersistentStoreCoordinatorLockingError', '', 132010),
    ('NSManagedObjectReferentialIntegrityError', '', 133000),
    ('NSManagedObjectExternalRelationshipError', '', 133010,),
    ('NSManagedObjectMergeError', '', 133020),
    ('NSManagedObjectConstraintMergeError', '', 133021),
    ('NSPersistentStoreInvalidTypeError', '', 134000),
    ('NSPersistentStoreTypeMismatchError', '', 134010),
    ('NSPersistentStoreIncompatibleSchemaError', '', 134020),
    ('NSPersistentStoreSaveError', '', 134030),
    ('NSPersistentStoreIncompleteSaveError', '', 134040),
    ('NSPersistentStoreSaveConflictsError', '', 134050),
    ('NSCoreDataError', '', 134060),
    ('NSPersistentStoreOperationError', '', 134070),
    ('NSPersistentStoreOpenError', '', 134080),
    ('NSPersistentStoreTimeoutError', '', 134090),
    ('NSPersistentStoreUnsupportedRequestTypeError', '', 134091),
    ('NSPersistentStoreIncompatibleVersionHashError', '', 134100),
    ('NSMigrationError', '', 134110),
    ('NSMigrationCancelledError', '', 134120),
    ('NSMigrationMissingSourceModelError', '', 134130),
    ('NSMigrationMissingMappingModelError', '', 134140),
    ('NSMigrationManagerSourceStoreError', '', 134150),
    ('NSMigrationManagerDestinationStoreError', '', 134160),
    ('NSEntityMigrationPolicyError', '', 134170),
    ('NSSQLiteError', '', 134180),
    ('NSInferredMappingModelError', '', 134190),
    ('NSExternalRecordImportError', '', 134200),
  ],
}

mappedDomainsOSX = {
  'NSCocoaError': [
    # Foundation errors
    ('NSFileManagerUnmountUnknownError', 'available(OSX 10.11, *)', 0),
    ('NSFileManagerUnmountBusyError', 'available(OSX 10.11, *)', 0),
    # AppKit errors
    ('NSTextReadInapplicableDocumentTypeError', '', 65806),
    ('NSTextWriteInapplicableDocumentTypeError', '', 66062),
    ('NSServiceApplicationNotFoundError', '', 66560),
    ('NSServiceApplicationLaunchFailedError', '', 66561),
    ('NSServiceRequestTimedOutError', '', 66562),
    ('NSServiceInvalidPasteboardDataError', '', 66563),
    ('NSServiceMalformedServiceDictionaryError', '', 66564),
    ('NSServiceMiscellaneousError', '', 66800),    
    ('NSSharingServiceNotConfiguredError', '', 67072),
  ]
}
}%

%TObjectiveCBridgeableError = gyb.parseTemplate("../../common/ObjectiveCBridgeableError.gyb")
%FoundationErrors = gyb.executeTemplate(TObjectiveCBridgeableError, mappedDomains=mappedDomains, mappedDomainsOSX=mappedDomainsOSX)

${FoundationErrors}

/// A hook for the runtime to use _ObjectiveCBridgeableErrorType in order to
/// attempt an "errorTypeValue as? SomeError" cast.
///
/// If the bridge succeeds, the bridged value is written to the uninitialized
/// memory pointed to by 'out', and true is returned. Otherwise, 'out' is
/// left uninitialized, and false is returned.
@asmname("swift_stdlib_bridgeNSErrorToErrorType")
public func _stdlib_bridgeNSErrorToErrorType<
  T : _ObjectiveCBridgeableErrorType
>(error: NSError, out: UnsafeMutablePointer<T>) -> Bool {
  if let bridged = T(_bridgedNSError: error) {
    out.initialize(bridged)
    return true
  } else {
    return false
  }
}
