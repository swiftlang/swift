import Foundation
import CoreFoundation

// NSError and CFError conform to the standard ErrorType protocol. Compiler
// magic allows this to be done as a "toll-free" conversion when an NSError
// or CFError is used as an ErrorType existential.

extension NSError : _ErrorType {}

extension CFError : _ErrorType {
  public var domain: String {
    return CFErrorGetDomain(self) as String
  }

  public var code: Int {
    return CFErrorGetCode(self)
  }
}

// An error value to use when an Objective-C API indicates error
// but produces a nil error object.
public enum _GenericObjCError : _ErrorType {
  case NilError
}

/// An intrinsic used by the runtime to create an error when an
/// Objective-C API indicates failure but produces a nil error.
@asmname("_swift_allocNilObjCError")
func _allocNilObjCError() -> _ErrorType {
  return _GenericObjCError.NilError
}

/// An internal protocol to represent Swift error enums that map to standard
/// Cocoa NSError domains.
public protocol _ObjectiveCBridgeableErrorType : _ErrorType {
  /// Produce a value of the error type corresponding to the given NSError,
  /// or return nil if it cannot be bridged.
  init?(_bridgedNSError: NSError)
}

%{

# Cocoa domains and their mapping information.
mappedDomains = {
  'NSCocoaError': [
    # TODO: Split this up into subdomains based on the Minimum/Maximum
    # delimited ranges?
    'NSFileNoSuchFileError',
    'NSFileLockingError',
    'NSFileReadUnknownError',
    'NSFileReadNoPermissionError',
    'NSFileReadInvalidFileNameError',
    'NSFileReadCorruptFileError',
    'NSFileReadNoSuchFileError',
    'NSFileReadInapplicableStringEncodingError',
    'NSFileReadUnsupportedSchemeError',
    'NSFileReadTooLargeError',
    'NSFileReadUnknownStringEncodingError',
    'NSFileWriteUnknownError',
    'NSFileWriteNoPermissionError',
    'NSFileWriteInvalidFileNameError',
    'NSFileWriteFileExistsError',
    'NSFileWriteInapplicableStringEncodingError',
    'NSFileWriteUnsupportedSchemeError',
    'NSFileWriteOutOfSpaceError',
    'NSFileWriteVolumeReadOnlyError',
    'NSKeyValueValidationError',
    'NSFormattingError',
    'NSUserCancelledError',
    #'NSFileErrorMinimum',
    #'NSFileErrorMaximum',
    #'NSValidationErrorMinimum',
    #'NSValidationErrorMaximum',
    #'NSFormattingErrorMinimum',
    #'NSFormattingErrorMaximum',
    'NSPropertyListReadCorruptError',
    'NSPropertyListReadUnknownVersionError',
    'NSPropertyListReadStreamError',
    'NSPropertyListWriteStreamError',
    #'NSPropertyListErrorMinimum',
    #'NSPropertyListErrorMaximum',
    #'NSExecutableErrorMinimum',
    'NSExecutableNotLoadableError',
    'NSExecutableArchitectureMismatchError',
    'NSExecutableRuntimeMismatchError',
    'NSExecutableLoadError',
    'NSExecutableLinkError',
    #'NSExecutableErrorMaximum',
  ],
}

}%

%for domain in mappedDomains:

// TODO: API review for how to name these enums and cases.
%{
EnumName = "_" + domain
}%

public enum ${EnumName} : _ObjectiveCBridgeableErrorType {
%  for code in mappedDomains[domain]:
  case ${code}
%  end

  public var domain: String { return ${domain}Domain }
  public var code: Int {
    switch self {
%  for code in mappedDomains[domain]:
    case ${EnumName}.${code}: return Foundation.${code}
%  end
    }
  }

  public init?(_bridgedNSError: NSError) {
    if _bridgedNSError.domain != ${domain}Domain {
      return nil
    }

    switch _bridgedNSError.code {
%  for code in mappedDomains[domain]:
    case Foundation.${code}: self = ${EnumName}.${code}
%  end
    default: return nil
    }
  }
}

%end

/// A hook for the runtime to use _ObjectiveCBridgeableErrorType in order to
/// attempt an "errorTypeValue as? SomeError" cast.
///
/// If the bridge succeeds, the bridged value is written to the uninitialized
/// memory pointed to by 'out', and true is returned. Otherwise, 'out' is
/// left uninitialized, and false is returned.
@asmname("swift_stdlib_bridgeNSErrorToErrorType")
public func _stdlib_bridgeNSErrorToErrorType<
  T : _ObjectiveCBridgeableErrorType
>(error: NSError, out: UnsafeMutablePointer<T>) -> Bool {
  if let bridged = T(_bridgedNSError: error) {
    out.initialize(bridged)
    return true
  } else {
    return false
  }
}
