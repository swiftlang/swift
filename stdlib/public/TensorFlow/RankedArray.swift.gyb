//===-- RankedArray.swift.gyb ---------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// Dynamically shaped but statically ranked n-dimensional arrays.
//
// Ranked arrays (Array1D, Array2D, etc) use an array of integers to represent a
// shape with known rank. The number of dimensions is guaranteed to equal the
// rank of the array.
//
//===----------------------------------------------------------------------===//

// TODO:
// - Further gyb similar methods of ArrayXD and ArraySliceXD.
// - Add documentation and standardize with ShapedArray.

import CTensorFlow

public typealias Array1D = Array
public typealias ArraySlice1D = ArraySlice

fileprivate extension Array1D {
  /// Creates an `Array1D` from a `ShapedArray`.
  /// - Precondition: The `ShapedArray` must have rank 1.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  init(base: ShapedArray<Element>) {
    assert(base.rank == 1, "The ShapedArray does not have rank 1.")
    switch base.buffer.allocation {
    case let .native(box):
      self = box.array
    case .tensorFlow:
      self = base.scalars
    }
  }
}

fileprivate extension ArraySlice1D {
  /// Creates an `ArraySlice1D` from a `ShapedArraySlice`.
  /// - Precondition: The `ShapedArraySlice` must have rank 1.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  init(base: ShapedArraySlice<Element>) {
    assert(base.rank == 1, "The ShapedArraySlice does not have rank 1.")
    self = base.withUnsafeBufferPointer(ArraySlice.init)
  }
}

%{
  ranks = [2, 3, 4]

  def rankName(rank):
    if rank == 2:
      return 'two'
    elif rank == 3:
      return 'three'
    elif rank == 4:
      return 'four'

  def _elementArrayLiteral(rank):
    return 'Scalar' if rank == 1 else '[' + _elementArrayLiteral(rank - 1) + ']'

  def _element(rank):
    return 'Scalar' if rank == 1 else 'ArraySlice{}D'.format(rank - 1)
}%

% for rank in ranks:
%   elementRank = rank - 1
%   liftedRank = rank + 1
%   ArrayXD = 'Array{}D'.format(rank)
%   TensorXD = 'Tensor{}D'.format(rank)
%   Element = _element(rank)
%   SliceXD = 'ArraySlice{}D'.format(rank)
%   elementArrayLiteral = _elementArrayLiteral(rank)
%   arrayLiteral = '[' + elementArrayLiteral + ']'

/// A ${rankName(rank)}-dimensional array.
@_fixed_layout
public struct ${ArrayXD}<Scalar> {
  /// The underlying `ShapedArray` of the `${ArrayXD}`.
  @_versioned
  internal var base: ShapedArray<Scalar>

  /// The number of dimensions of the `${ArrayXD}`.
  public static var rank: Int {
    return ${rank}
  }

  /// The number of dimensions of the `${ArrayXD}`.
  /// `rank` is always equal to ${rank} for `${ArrayXD}`.
  public var rank: Int {
    return ${ArrayXD}.rank
  }

  /// The dimensions of the `${ArrayXD}`.
  public var shape: [Int] {
    return base.shape
  }

  /// The number of scalars in the `${ArrayXD}`.
  public var scalarCount: Int {
    return base.scalarCount
  }

  /// The scalars of the `${ArrayXD}`, in row-major order.
  public var scalars: [Scalar] {
    get {
      return base.scalars
    }
    set {
      precondition(newValue.count == scalarCount, "Scalar count mismatch.")
      base.scalars = newValue
    }
  }

  /// Creates an `${ArrayXD}` from a `TensorBuffer` and a shape.
  fileprivate init(buffer: TensorBuffer<Scalar>, shape: [Int]) {
    self.init(base: ShapedArray(buffer: buffer, shape: shape))
  }

  /// Creates an `${ArrayXD}` from a `ShapedArray`.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  @_versioned
  internal init(base: ShapedArray<Scalar>) {
    self.base = base
  }

  /// Creates an `${ArrayXD}` from a `ShapedArray`. Returns nil if the
  /// `ShapedArray` does not have rank ${rank}.
  public init?(_ other: ShapedArray<Scalar>) {
    guard other.rank == ${rank} else { return nil }
    self.init(base: other)
  }

  /// Creates an `${ArrayXD}` from a `ShapedArray`.
  /// - Precondition: The `ShapedArray` must have rank ${rank}.
  public init(identicallyRanked other: ShapedArray<Scalar>) {
    precondition(other.rank == ${rank}, "Rank is not ${rank}.")
    self.init(base: other)
  }
}

public extension ${ArrayXD} {
  /// Returns the number of element arrays in an `${ArrayXD}` (equivalent to the
  /// first dimension).
  /// - Note: `count` is distinct from `scalarCount`, which represents the total
  ///   number of scalars.
  var count: Int {
    return base.count
  }

  /// Creates an `${ArrayXD}` with the specified shape and contiguous scalars in
  /// row-major order.
  /// - Precondition: The number of scalars must equal the product of the
  ///   dimensions of the shape.
  init(shape: [Int], scalars: [Scalar]) {
    precondition(shape.count == ${rank},
                 "The shape does not have ${rank} dimensions.")
    precondition(shape.reduce(1, *) == scalars.count, "Scalar count mismatch.")
    // self = ArraySlice(scalars)
    self.init(base: ShapedArray(shape: shape, scalars: scalars))
  }

  /// Creates an `${ArrayXD}` with the specified shape and a single, repeated
  /// value.
  /// - Parameters:
  ///   - shape: The dimensions of the array.
  ///   - repeatedValue: The scalar value to repeat.
  init(shape: [Int], repeating repeatedValue: Scalar) {
    self.init(base: ShapedArray(shape: shape, repeating: repeatedValue))
  }
}

internal extension ${ArrayXD} where Scalar : AccelerableByTensorFlow {
  @_versioned
  init(owning cTensor: CTensor) {
    let shape = (0..<TF_NumDims(cTensor)).map { Int(TF_Dim(cTensor, $0)) }
    let buffer = TensorBuffer<Scalar>(owning: cTensor, count: shape.count)
    self.init(buffer: buffer, shape: shape)
  }
}

public extension ${ArrayXD} {
  func withUnsafeBufferPointer<Result>(
    _ body: (UnsafeBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeBufferPointer(body)
  }

  mutating func withUnsafeMutableBufferPointer<Result>(
    _ body: (inout UnsafeMutableBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeMutableBufferPointer(body)
  }
}

extension ${ArrayXD} : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Element = ${Element}<Scalar>
  public typealias SubSequence = ${SliceXD}<Scalar>

  public var indices: Range<Int> {
    return base.indices
  }

  public var startIndex: Int {
    return base.startIndex
  }

  public var endIndex: Int {
    return base.endIndex
  }

  /// Access the element `${Element}` specified by an index in the leading
  /// dimension.
  /// - Parameter index: Index of the element `${Element}`.
  public subscript(index: Int) -> Element {
    get {
      precondition(index < endIndex, "${ArrayXD} index is out of range")
      precondition(index >= startIndex,
                   "${ArrayXD} index is out of range (before startIndex)")
      let slice = ShapedArraySlice<Scalar>(
        base: base,
        baseIndices: [index]
      )
% if rank == 2:
      return slice.withUnsafeBufferPointer(ArraySlice.init)
% else:
      return ${Element}(base: slice)
% end
    }
    set {
      precondition(index < endIndex, "${ArrayXD} index is out of range")
      precondition(index >= startIndex,
                   "${ArrayXD} index is out of range (before startIndex)")
% if rank == 2:
      precondition(shape.dropFirst().elementsEqual([newValue.count]),
                   "Element shape mismatch")
      base[index].scalars = Array(newValue)
% else:
      precondition(shape.dropFirst().elementsEqual(newValue.shape),
                   "Element shape mismatch")
      base[index] = newValue.base
% end
    }
  }

  /// Access the `${SliceXD}` specified by a contiguous range of indices.
  /// - Parameter bounds: Contiguous range of indices.
  public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${ArrayXD} indices are out of range")
      return ${SliceXD}(
        base: ShapedArraySlice(
          base: base,
          bounds: bounds
        )
      )
    }
    set {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${ArrayXD} indices are out of range")
      let subArrayShape = [bounds.count] + shape.dropFirst()
      precondition(subArrayShape == newValue.shape,
                   "Subarray shape mismatch.")
      base[bounds] = newValue.base
    }
  }
}

/// `${TensorXD}` conversion
public extension ${ArrayXD} where Scalar : AccelerableByTensorFlow {
  init(_ tensor: ${TensorXD}<Scalar>) {
    self = tensor.array
  }
}

/// Equatable conformance
extension ${ArrayXD} : Equatable where Scalar : Equatable {
  static public func == (lhs: ${ArrayXD}, rhs: ${ArrayXD}) -> Bool {
    return lhs.base == rhs.base
  }
}

/// String conversion.
extension ${ArrayXD} : CustomStringConvertible {
  /// A textual representation of this `${ArrayXD}`.
  public var description: String {
    return base.description
  }
}

/// Xcode Playground display conversion.
extension ${ArrayXD} : CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    return description
  }
}

/// Mirror representation, used by debugger/REPL.
extension ${ArrayXD} : CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [], displayStyle: .struct)
  }
}

/// A ${rankName(rank)}-dimensional wrapper around a `ShapedArraySlice`.
@_fixed_layout
public struct ${SliceXD}<Scalar> {
  /// The underlying ShapedArraySlice of the `${SliceXD}`.
  fileprivate var base: ShapedArraySlice<Scalar>

  /// Creates an `${SliceXD}` from a `ShapedArraySlice`.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  fileprivate init(base: ShapedArraySlice<Scalar>) {
    self.base = base
  }
}

public extension ${SliceXD} {
  /// The number of dimensions of the `${SliceXD}`.
  /// `rank` is always equal to ${rank} for `${SliceXD}`.
  var rank: Int {
    return ${rank}
  }

  /// The dimensions of the `${SliceXD}`.
  var shape: [Int] {
    return base.shape
  }

  /// The number of scalars in the`${SliceXD}`.
  var scalarCount: Int {
    return base.scalarCount
  }

  /// The scalars of the `${SliceXD}`, in row-major order.
  var scalars: [Scalar] {
    get {
      return base.scalars
    }
    set {
      precondition(newValue.count == scalarCount, "Scalar count mismatch.")
      base.scalars = newValue
    }
  }
}

/// Slice initializers
public extension ${SliceXD} {
  /// Returns the number of element arrays in an `${SliceXD}` (equivalent to the
  /// first dimension).
  /// - Note: `count` is distinct from `scalarCount`, which represents the total
  ///   number of scalars.
  var count: Int {
    return base.count
  }

  /// Creates an `${SliceXD}` with the specified shape and contiguous scalars in
  /// row-major order.
  /// - Precondition: The number of scalars must equal the product of the
  ///   dimensions of the shape.
  init(shape: [Int], scalars: [Scalar]) {
    self.init(base: ShapedArraySlice(shape: shape, scalars: scalars))
  }

  /// Creates an `${SliceXD}` with the specified shape and a single, repeated
  /// value.
  /// - Parameters:
  ///   - shape: The dimensions of the array.
  ///   - repeatedValue: The scalar value to repeat.
  init(shape: [Int], repeating repeatedValue: Scalar) {
    self.init(base: ShapedArraySlice(shape: shape, repeating: repeatedValue))
  }
}

public extension ${SliceXD} {
  func withUnsafeBufferPointer<Result>(
    _ body: (UnsafeBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeBufferPointer(body)
  }

  mutating func withUnsafeMutableBufferPointer<Result>(
    _ body: (inout UnsafeMutableBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeMutableBufferPointer(body)
  }
}

extension ${SliceXD} : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Element = ${Element}<Scalar>
  public typealias SubSequence = ${SliceXD}

  public var indices: Range<Int> {
    return base.indices
  }

  public var startIndex: Int {
    return base.startIndex
  }

  public var endIndex: Int {
    return base.endIndex
  }

  /// Access the element `${Element}` specified by an index in the leading
  /// dimension.
  /// - Parameter index: Index of the element `${Element}`.
  public subscript(index: Int) -> Element {
    get {
      precondition(index < endIndex, "${SliceXD} index is out of range")
      precondition(index >= startIndex,
                   "${SliceXD} index is out of range (before startIndex)")
      let slice = ShapedArraySlice<Scalar>(
        base: base.base,
        baseIndices: base.baseIndices + [index],
        bounds: base.bounds
      )
% if rank == 2:
      return slice.withUnsafeBufferPointer(ArraySlice.init)
% else:
      return ${Element}(base: slice)
% end
    }
    set {
      precondition(index < endIndex, "${SliceXD} index is out of range")
      precondition(index >= startIndex,
                   "${SliceXD} index is out of range (before startIndex)")
% if rank == 2:
      precondition(shape.dropFirst().elementsEqual([newValue.count]),
                   "Element shape mismatch")
      base[index] = ShapedArraySlice(shape: [newValue.count], scalars: newValue)
% else:
      precondition(shape.dropFirst().elementsEqual(newValue.shape),
                   "Element shape mismatch")
      base[index] = newValue.base
% end
    }
  }

  /// Access the `${SliceXD}` specified by a contiguous range of indices.
  /// - Parameter bounds: Contiguous range of indices.
  public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${SliceXD} indices are out of range")
      return ${SliceXD}(
        base: ShapedArraySlice(
          base: base.base,
          baseIndices: base.baseIndices,
          bounds: bounds
        )
      )
    }
    set {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${SliceXD} indices are out of range")
      let subArrayShape = [bounds.count] + shape.dropFirst()
      precondition(subArrayShape == newValue.shape, "Subarray shape mismatch")
      base[bounds] = newValue.base
    }
  }
}

/// `${TensorXD}` conversion
public extension ${SliceXD} where Scalar : AccelerableByTensorFlow {
  init(_ tensor: ${TensorXD}<Scalar>) {
    self.init(base: ShapedArraySlice<Scalar>(tensor.base))
  }
}

/// Equatable conformance
extension ${SliceXD} : Equatable where Scalar : Equatable {
  public static func == (lhs: ${SliceXD}, rhs: ${SliceXD}) -> Bool {
    return lhs.base == rhs.base
  }
}

/// String conversion.
extension ${SliceXD} : CustomStringConvertible {
  /// A textual representation of this `${SliceXD}`.
  public var description: String {
    return base.description
  }
}

/// Xcode Playground display conversion.
extension ${SliceXD} : CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    return description
  }
}

/// Mirror representation, used by debugger/REPL.
extension ${SliceXD} : CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, children: [], displayStyle: .struct)
  }
}
% end
