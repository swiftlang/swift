//===--- tgmath.swift.gyb -------------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftShims

// Generic functions implementable directly on FloatingPoint.
@_transparent
@available(swift, deprecated: 4.2/*, obsoleted: 5.1*/, renamed: "abs")
public func fabs<T: FloatingPoint>(_ x: T) -> T {
  return x.magnitude
}

@_transparent
public func sqrt<T: FloatingPoint>(_ x: T) -> T {
  return x.squareRoot()
}

@_transparent
public func fma<T: FloatingPoint>(_ x: T, _ y: T, _ z: T) -> T {
  return z.addingProduct(x, y)
}

@_transparent
public func remainder<T: FloatingPoint>(_ x: T, _ y: T) -> T {
  return x.remainder(dividingBy: y)
}

@_transparent
public func fmod<T: FloatingPoint>(_ x: T, _ y: T) -> T {
  return x.truncatingRemainder(dividingBy: y)
}

@_transparent
public func ceil<T: FloatingPoint>(_ x: T) -> T {
  return x.rounded(.up)
}

@_transparent
public func floor<T: FloatingPoint>(_ x: T) -> T {
  return x.rounded(.down)
}

@_transparent
public func round<T: FloatingPoint>(_ x: T) -> T {
  return x.rounded()
}

@_transparent
public func trunc<T: FloatingPoint>(_ x: T) -> T {
  return x.rounded(.towardZero)
}

@_transparent
public func scalbn<T: FloatingPoint>(_ x: T, _ n : Int) -> T {
  return T(sign: .plus, exponent: T.Exponent(n), significand: x)
}

@_transparent
public func modf<T: FloatingPoint>(_ x: T) -> (T, T) {
  // inf/NaN: return canonicalized x, fractional part zero.
  guard x.isFinite else { return (x+0, 0) }
  let integral = trunc(x)
  let fractional = x - integral
  return (integral, fractional)
}

@_transparent
public func frexp<T: BinaryFloatingPoint>(_ x: T) -> (T, Int) {
  guard x.isFinite else { return (x+0, 0) }
  guard x != 0 else { return (x, 0) }
  // The C stdlib `frexp` uses a different notion of significand / exponent
  // than IEEE 754, so we need to adjust them by a factor of two.
  return (x.significand / 2, Int(x.exponent + 1))
}

// SWIFT_ENABLE_TENSORFLOW
@usableFromInline
@derivative(of: sqrt)
func _vjpSqrt<T: FloatingPoint & Differentiable> (
  _ x: T
) -> (value: T, pullback: (T) -> T) where T == T.TangentVector {
  let value = sqrt(x)
  return (value, { v in v / (2 * value) })
}

@usableFromInline
@derivative(of: fma)
func _vjpFma<T: FloatingPoint & Differentiable> (
  _ x: T,
  _ y: T,
  _ z: T
) -> (value: T, pullback: (T) -> (T, T, T)) where T == T.TangentVector {
  return (fma(x, y, z), { v in (v * y, v * x, v) })
}

@usableFromInline
@derivative(of: remainder)
func _vjpRemainder<T: FloatingPoint & Differentiable> (
  _ x: T,
  _ y: T
) -> (value: T, pullback: (T) -> (T, T)) where T == T.TangentVector {
  return (remainder(x, y), { v in (v, -v * ((x / y).rounded(.toNearestOrEven))) })
}

@usableFromInline
@derivative(of: fmod)
func _vjpFmod<T: FloatingPoint & Differentiable> (
  _ x: T,
  _ y: T
) -> (value: T, pullback: (T) -> (T, T)) where T == T.TangentVector {
  return (fmod(x, y), { v in (v, -v * ((x / y).rounded(.towardZero))) })
}

@usableFromInline
@derivative(of: ceil)
func _vjpCeil<T: FloatingPoint & Differentiable> (
  _ x: T
) -> (value: T, pullback: (T) -> T) where T == T.TangentVector {
  return (ceil(x), { v in 0 })
}

@usableFromInline
@derivative(of: floor)
func _vjpFloor<T: FloatingPoint & Differentiable> (
  _ x: T
) -> (value: T, pullback: (T) -> T) where T == T.TangentVector {
  return (floor(x), { v in 0 })
}

@usableFromInline
@derivative(of: round)
func _vjpRound<T: FloatingPoint & Differentiable> (
  _ x: T
) -> (value: T, pullback: (T) -> T) where T == T.TangentVector {
  return (round(x), { v in 0 })
}

@usableFromInline
@derivative(of: trunc)
func _vjpTrunc<T: FloatingPoint & Differentiable> (
  _ x: T
) -> (value: T, pullback: (T) -> T) where T == T.TangentVector {
  return (trunc(x), { v in 0 })
}
// SWIFT_ENABLE_TENSORFLOW END

%for T in ['Float','Double']:
@available(swift, deprecated: 4.2, renamed: "scalbn")
@_transparent
public func ldexp(_ x: ${T}, _ n : Int) -> ${T} {
  return ${T}(sign: .plus, exponent: n, significand: x)
}

%end

// SWIFT_ENABLE_TENSORFLOW
%for T in ['Float', 'Double', 'Float80']:
%   if T == 'Float80':
#if !(os(Windows) || os(Android)) && (arch(i386) || arch(x86_64))
%   end
@derivative(of: exp)
public func _vjpExp(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  let value = exp(x)
  return (value, { v in value * v })
}

@derivative(of: exp)
public func _jvpExp(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'exp(_:)'")
}

@derivative(of: exp2)
public func _vjpExp2(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  let value = exp2(x)
  return (value, { v in v * ${T}(M_LN2) * value })
}

@derivative(of: exp2)
public func _jvpExp2(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'exp2(_:)'")
}

@derivative(of: log)
public func _vjpLog(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (log(x), { v in v / x })
}

@derivative(of: log)
public func _jvpLog(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'log(_:)'")
}

@derivative(of: log10)
public func _vjpLog10(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (log10(x), { v in v * ${T}(M_LOG10E) / x })
}

@derivative(of: log10)
public func _jvpLog10(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'log10(_:)'")
}

@derivative(of: log2)
public func _vjpLog2(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (log2(x), { v in v / (${T}(M_LN2) * x) })
}

@derivative(of: log2)
public func _jvpLog2(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'log2(_:)'")
}

@derivative(of: sin)
public func _vjpSin(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (sin(x), { v in v * cos(x) })
}

@derivative(of: sin)
public func _jvpSin(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'sin(_:)'")
}

@derivative(of: cos)
public func _vjpCos(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (cos(x), { v in -v * sin(x) })
}

@derivative(of: cos)
public func _jvpCos(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'cos(_:)'")
}

@derivative(of: tan)
public func _vjpTan(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  let value = tan(x)
  return (value, { v in v * (1 + value * value) })
}

@derivative(of: tan)
public func _jvpTan(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'tan(_:)'")
}

@derivative(of: asin)
public func _vjpAsin(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (asin(x), { v in v / sqrt(1 - x * x) })
}

@derivative(of: asin)
public func _jvpAsin(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'asin(_:)'")
}

@derivative(of: acos)
public func _vjpAcos(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (acos(x), { v in -v / sqrt(1 - x * x) })
}

@derivative(of: acos)
public func _jvpAcos(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'acos(_:)'")
}

@derivative(of: atan)
public func _vjpAtan(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (atan(x), { v in v / (1 + x * x) })
}

@derivative(of: atan)
public func _jvpAtan(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'atan(_:)'")
}

@derivative(of: sinh)
public func _vjpSinh(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (sinh(x), { v in v * cosh(x) })
}

@derivative(of: sinh)
public func _jvpSinh(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'sinh(_:)'")
}

@derivative(of: cosh)
public func _vjpCosh(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (cosh(x), { v in v * sinh(x) })
}

@derivative(of: cosh)
public func _jvpCosh(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'cosh(_:)'")
}

@derivative(of: tanh)
public func _vjpTanh(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  let value = tanh(x)
  return (value, { v in v * (1 - value * value) })
}

@derivative(of: tanh)
public func _jvpTanh(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'tanh(_:)'")
}

@derivative(of: asinh)
public func _vjpAsinh(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (asinh(x), { v in v / sqrt(1 + x * x) })
}

@derivative(of: asinh)
public func _jvpAsinh(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'asinh(_:)'")
}

@derivative(of: acosh)
public func _vjpAcosh(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (acosh(x), { v in v / sqrt(x * x - 1) })
}

@derivative(of: acosh)
public func _jvpAcosh(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'acosh(_:)'")
}

@derivative(of: atanh)
public func _vjpAtanh(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (atanh(x), { v in v / (1 - x * x) })
}

@derivative(of: atanh)
public func _jvpAtanh(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'atanh(_:)'")
}

@derivative(of: expm1)
public func _vjpExpm1(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (expm1(x), { v in exp(x) * v })
}

@derivative(of: expm1)
public func _jvpExpm1(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'expm1(_:)'")
}

@derivative(of: log1p)
public func _vjpLog1p(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (log1p(x), { v in v / (x + 1) })
}

@derivative(of: log1p)
public func _jvpLog1p(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'log1p(_:)'")
}

@derivative(of: erf)
public func _vjpErf(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (erf(x), { v in v * ${T}(M_2_SQRTPI) * exp(-x * x) })
}

@derivative(of: erf)
public func _jvpErf(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'erf(_:)'")
}

@derivative(of: erfc)
public func _vjpErfc(_ x: ${T}) -> (value: ${T}, pullback: (${T}) -> ${T}) {
  return (erfc(x), { v in v * -${T}(M_2_SQRTPI) * exp(-x * x) })
}

@derivative(of: erfc)
public func _jvpErfc(_ x: ${T}) -> (value: ${T}, differential: (${T}) -> ${T}) {
  fatalError("Unimplemented JVP for 'erfc(_:)'")
}
// SWIFT_ENABLE_TENSORFLOW END
%   if T == 'Float80':
#endif
%   end
%end

//  Floating-point properties that are exposed as functions in the C math
//  library. Mark those function names unavailable and direct users to the
//  properties instead.
@available(*, unavailable, message: "use the floatingPointClass property.")
public func fpclassify<T: FloatingPoint>(_ value: T) -> Int { fatalError() }

@available(*, unavailable, message: "use the isNormal property.")
public func isnormal<T: FloatingPoint>(_ value: T) -> Bool { fatalError() }

@available(*, unavailable, message: "use the isFinite property.")
public func isfinite<T: FloatingPoint>(_ value: T) -> Bool { fatalError() }

@available(*, unavailable, message: "use the isInfinite property.")
public func isinf<T: FloatingPoint>(_ value: T) -> Bool { fatalError() }

@available(*, unavailable, message: "use the isNaN property.")
public func isnan<T: FloatingPoint>(_ value: T) -> Bool { fatalError() }

@available(*, unavailable, message: "use the sign property.")
public func signbit<T: FloatingPoint>(_ value: T) -> Int { fatalError() }

@available(swift, deprecated: 4.2/*, obsoleted: 5.1*/, message: "use the exponent property.")
public func ilogb<T: BinaryFloatingPoint>(_ x: T) -> Int {
  return Int(x.exponent)
}

%{

# Don't need 64-bit (Double/CDouble) overlays. The ordinary C imports work fine.
overlayFloatBits = [32, 80]
allFloatBits = [32, 64, 80]

def floatName(bits):
    if bits == 32:
        return 'Float'
    if bits == 64:
        return 'Double'
    if bits == 80:
        return 'Float80'

def cFloatName(bits):
    if bits == 32:
        return 'CFloat'
    if bits == 64:
        return 'CDouble'
    if bits == 80:
        return 'CLongDouble'

def cFuncSuffix(bits):
    if bits == 32:
        return 'f'
    if bits == 64:
        return ''
    if bits == 80:
        return 'l'

# Each of the following lists is ordered to match math.h

# (T) -> T
# These functions do not have a corresponding LLVM intrinsic
UnaryFunctions = [
    'acos', 'asin', 'atan', 'tan',
    'acosh', 'asinh', 'atanh', 'cosh', 'sinh', 'tanh',
    'expm1',
    'log1p',
    'erf', 'erfc',
]

# These functions have a corresponding LLVM intrinsic
UnaryIntrinsicFunctions = [
    'cos', 'sin', 'exp', 'exp2', 'log', 'log10', 'log2', 'nearbyint', 'rint'
]

# SWIFT_ENABLE_TENSORFLOW
HasVJP = [
    'acos', 'asin', 'atan', 'tan',
    'acosh', 'asinh', 'atanh', 'cosh', 'sinh', 'tanh',
    'expm1',
    'log1p',
    'erf', 'erfc',
    'cos', 'sin', 'exp', 'exp2', 'log', 'log10', 'log2'
]

def AllFloatTypes():
    for bits in allFloatBits:
        yield floatName(bits), cFloatName(bits), cFuncSuffix(bits)

def OverlayFloatTypes():
    for bits in overlayFloatBits:
        yield floatName(bits), cFloatName(bits), cFuncSuffix(bits)

def TypedUnaryFunctions():
    for ufunc in UnaryFunctions:
        for bits in overlayFloatBits:
            yield floatName(bits), cFloatName(bits), cFuncSuffix(bits), ufunc

def TypedUnaryIntrinsicFunctions():
    for ufunc in UnaryIntrinsicFunctions:
        for bits in allFloatBits:
            yield floatName(bits), ufunc

def TypedBinaryFunctions():
    for bfunc in BinaryFunctions:
        for bits in overlayFloatBits:
            yield floatName(bits), cFloatName(bits), cFuncSuffix(bits), bfunc

}%

// Unary functions
// Note these do not have a corresponding LLVM intrinsic
% for T, CT, f, ufunc in TypedUnaryFunctions():
%  if T == 'Float80':
#if (arch(i386) || arch(x86_64)) && !(os(Windows) || os(Android))
%  end
@_transparent
// SWIFT_ENABLE_TENSORFLOW
%   if ufunc in HasVJP:
@differentiable
%   end
public func ${ufunc}(_ x: ${T}) -> ${T} {
  return ${T}.${ufunc}(x)
}
%  if T == 'Float80':
#endif
%  end

% end
@_transparent
public func cbrt(_ x: Float) -> Float {
  return Float.root(x, 3)
}

@available(swift, deprecated: 5.1, message: "Use `x.exponent` or `floor(log2(x))`.")
@_transparent
public func logb(_ x: Float) -> Float {
  return Float.log2(x).rounded(.down)
}

@_transparent
public func tgamma(_ x: Float) -> Float {
  return Float.gamma(x)
}

#if (arch(i386) || arch(x86_64)) && !(os(Windows) || os(Android))
@_transparent
public func cbrt(_ x: Float80) -> Float80 {
  return Float80.root(x, 3)
}

@available(swift, deprecated: 5.1, message: "Use `x.exponent` or `floor(log2(x))`.")
@_transparent
public func logb(_ x: Float80) -> Float80 {
  return Float80.log2(x).rounded(.down)
}

@_transparent
public func tgamma(_ x: Float80) -> Float80 {
  return Float80.gamma(x)
}
#endif

// Unary intrinsic functions
// Note these have a corresponding LLVM intrinsic
% for T, ufunc in TypedUnaryIntrinsicFunctions():
%  if T == 'Float80':
#if (arch(i386) || arch(x86_64)) && !(os(Windows) || os(Android))
%  end
%  if ufunc[-3:] != 'int':
@_transparent
// SWIFT_ENABLE_TENSORFLOW
%   if ufunc in HasVJP:
@differentiable
%   end
public func ${ufunc}(_ x: ${T}) -> ${T} {
  return ${T}.${ufunc}(x)
}
%  else:
@available(swift, deprecated: 5.1, message: "Swift does not model dynamic rounding modes, use x.rounded(.toNearestOrEven) instead.")
@_transparent
// SWIFT_ENABLE_TENSORFLOW
%   if ufunc in HasVJP:
@differentiable
%   end
public func ${ufunc}(_ x: ${T}) -> ${T} {
  return x.rounded(.toNearestOrEven)
}
%  end
%  if T == 'Float80':
#endif
%  end

% end

// Binary functions
% for T, CT, f in OverlayFloatTypes():
%  if T == 'Float80':
#if (arch(i386) || arch(x86_64)) && !(os(Windows) || os(Android))
%  end
@_transparent
public func atan2(_ y: ${T}, _ x: ${T}) -> ${T} {
  return ${T}.atan2(y: y, x: x)
}

@_transparent
public func hypot(_ x: ${T}, _ y: ${T}) -> ${T} {
  return ${T}.hypot(x, y)
}

@_transparent
public func pow(_ x: ${T}, _ y: ${T}) -> ${T} {
  return ${T}.pow(x, y)
}

@_transparent
public func copysign(_ x: ${T}, _ y: ${T}) -> ${T} {
  return ${T}(signOf: y, magnitudeOf: x)
}

@_transparent
public func fdim(_ x: ${T}, _ y: ${T}) -> ${T} {
  return ${T}(fdim${f}(${CT}(x), ${CT}(y)))
}

@available(swift, deprecated: 5.1, message: "Use the .nextUp and .nextDown properties.")
@_transparent
public func nextafter(_ x: ${T}, _ y: ${T}) -> ${T} {
  return y > x ? x.nextUp : (y < x ? x.nextDown : y)
}

@available(swift, deprecated: 5.1, message: "Use ${T}.minimum( ) or Swift.min( )")
@_transparent
public func fmin(_ x: ${T}, _ y: ${T}) -> ${T} {
  return .minimum(x, y)
}

@available(swift, deprecated: 5.1, message: "Use ${T}.maximum( ) or Swift.max( )")
@_transparent
public func fmax(_ x: ${T}, _ y: ${T}) -> ${T} {
  return .maximum(x, y)
}
%  if T == 'Float80':
#endif
%  end

% end

% # This is AllFloatTypes not OverlayFloatTypes because of the tuple return.
% for T, CT, f in AllFloatTypes():
%  if T == 'Float80':
#if (arch(i386) || arch(x86_64)) && !(os(Windows) || os(Android))
%  else:
//  lgamma not available on Windows, apparently?
#if !os(Windows)
%  end
@_transparent
public func lgamma(_ x: ${T}) -> (${T}, Int) {
  return (${T}.logGamma(x), ${T}.signGamma(x) == .plus ? 1 : -1)
}
#endif

% end

% # This is AllFloatTypes not OverlayFloatTypes because of the tuple return.
% for T, CT, f in AllFloatTypes():
%  if T == 'Float80':
#if (arch(i386) || arch(x86_64)) && !(os(Windows) || os(Android))
%  end
@_transparent
public func remquo(_ x: ${T}, _ y: ${T}) -> (${T}, Int) {
  var quo = Int32(0)
  let rem = remquo${f}(${CT}(x), ${CT}(y), &quo)
  return (${T}(rem), Int(quo))
}
%  if T == 'Float80':
#endif
%  end

% end

% for T, CT, f in OverlayFloatTypes():
%  if T == 'Float80':
#if (arch(i386) || arch(x86_64)) && !(os(Windows) || os(Android))
%  end
@available(swift, deprecated: 4.2/*, obsoleted: 5.1*/, message:
           "use ${T}(nan: ${T}.RawSignificand).")
@_transparent
public func nan(_ tag: String) -> ${T} {
  return ${T}(nan${f}(tag))
}
%  if T == 'Float80':
#endif
%  end

% end

% # These C functions only support double. The overlay fixes the Int parameter.
@_transparent
public func jn(_ n: Int, _ x: Double) -> Double {
#if os(Windows)
  return _jn(Int32(n), x)
#else
  return jn(Int32(n), x)
#endif
}

@_transparent
public func yn(_ n: Int, _ x: Double) -> Double {
#if os(Windows)
  return _yn(Int32(n), x)
#else
  return yn(Int32(n), x)
#endif
}

% end

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
