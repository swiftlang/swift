%# -*- mode: swift -*-
//===--- IntegerArithmetic.swift.gyb --------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
%# Ignore the following admonition; it applies to the resulting .swift file only

// Automatically Generated From IntegerArithmetic.swift.gyb.  Do Not
// Edit Directly!

% integerBinaryOps = [
%    (x[:-1], x[-1]) for x in 
%     'Add+ Subtract- Multiply* Divide/ Modulus%'.split()]

protocol _IntegerArithmetic {
% for name,_ in integerBinaryOps:
  class func unchecked${name}(lhs: Self, _ rhs: Self) -> (Self, Bool)
% end
}

protocol IntegerArithmetic : _IntegerArithmetic, Comparable {
  // Checked arithmetic functions.  Specific implementations in
  // FixedPoint.swift.gyb support static checking for integer types.
% for _,op in integerBinaryOps:
  func ${op} (lhs: Self, rhs: Self) -> Self
% end
  
  // Explicitly convert to IntMax, trapping on overflow
  func toIntMax() -> IntMax
}

% for name,op in integerBinaryOps:
@transparent
func ${op} <T: _IntegerArithmetic>(lhs: T, rhs: T) -> T {
  return _overflowChecked(T.unchecked${name}(lhs, rhs))
}

@transparent
func &${op} <T: _IntegerArithmetic>(lhs: T, rhs: T) -> T {
  return T.unchecked${name}(lhs, rhs).0
}

@assignment @transparent
func ${op}= <T: _IntegerArithmetic>(inout lhs: T, rhs: T) {
  lhs = lhs ${op} rhs
}
% end

//===--- SignedNumber -----------------------------------------------------===//
// A numeric type that supports abs(x), +x and -x
//===----------------------------------------------------------------------===//

// Base protocol containing all the non-defaulted implentations.  This
// protocol should be presented to users as part of SignedNumber.
protocol _SignedNumber : Comparable, IntegerLiteralConvertible {
  // Subtraction is a requirement for SignedNumber
  @infix func - (lhs: Self, rhs: Self) -> Self
}

// SignedNumber itself contains only operator requirements having
// default implementations on the base protocol.
protocol SignedNumber : _SignedNumber {
  @prefix func - (x: Self) -> Self

  // Do not use this operator directly; call abs(x) instead
  func ~> (_:Self,_:(_Abs, ())) -> Self
}

// Unary negation in terms of subtraction.  This is a default
// implementation; models of SignedNumber can provide their own
// implementations.
@prefix @transparent
func - <T : _SignedNumber>(x: T) -> T {
  return 0 - x
}

// Unary +
@prefix @transparent
func + <T: _SignedNumber>(x: T) -> T {
  return x
}

//===--- abs(x) -----------------------------------------------------------===//
struct _Abs {}
func _abs<Args>(args: Args) -> (_Abs, Args) {
  return (_Abs(), args)
}

// Do not use this operator directly; call abs(x) instead
@transparent
func ~> <T : _SignedNumber>(x:T,_:(_Abs, ())) -> T {
  return x < 0 ? -x : x
}

protocol AbsoluteValuable : SignedNumber {
  class func abs(_:Self) -> Self
}

// Do not use this operator directly; call abs(x) instead
@transparent
func ~> <T : AbsoluteValuable>(x:T,_:(_Abs, ())) -> T {
  return T.abs(x)
}

// Absolute value.  Concrete instances of SignedNumber can specialize
// this function by conforming to AbsoluteValuable.
@transparent
func abs<T : SignedNumber>(x: T) -> T {
  return x~>_abs()
}

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
