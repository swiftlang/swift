// RUN: not --crash %target-swift-frontend %s -parse

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

k)
func yx<jih>() -> (jih, jih -> jih) -> jih {
   cb n cb.x = {
}
 {
   jih) {
        vu  }
}
protocol yx {
   class func x()
}
class cb: yx{  class func x {}
ih k<ut> {
    po vu(ut, () -> ())
}
func n<cb {
    ih n {
        func k
        ml _ = k
    }
}
class dcb {
    typealias po = po
}
func dcb<ut>() {
    v> : jih {
    func po(po: ji.ay) {
    }
}
func dcb<k: kji, ut ts qp<ut> == k.s.n>(w : k) -> ut? {
    wv (po : ut?) in w {
        rq let cb = po {
            u cb
        }
    }
    u cb
}
let w : [r?] = [cb, ihg, cb]
xw(dcb(w))
func yx<ut : sr>(po: ut) {
}
yx(l dc sr)
func dcb(po: r = hg) {
}
let n = dcb
n()
on n<cb : kji> {
    ml po: cb
}
func dcb<cb>() -> [n<cb>] {
    u []
}
protocol jih {
    typealias nm
}
class vu<lk> {
    edc <jih: jih ts jih.nm == lk>(k: jih.nm) {
    }
}
func x(n: () -> ()) {
}
class dcb {
    ml _ = x() {
    }
}
protocol jih {
    typealias gfe
}
on nm<ut : jih> {
    let vu: ut
    let x: ut.gfe
}
protocol vu {
    typealias ba
    func jih<ut ts ut.gfe == ba>(yx: nm<ut>)
}
on lk : vu {
    typealias ba = r
    func jih<ut ts ut.gfe == ba>(yx: nm<ut>) {
    }
}
class jih: jih {
}
class nm : vu {
}
typealias vu = nm
func ^(dcb: sr, o) -> o {
    u !(dcb)
}
func dcb(cb: ed, ut: ed) -> (((ed, ed) -> ed) -> ed) {
    u {
        (gfe: (ed, ed) -> ed) -> ed in
        u gfe(cb, ut)
    }
}
func po(t: (((ed, ed) -> ed) -> ed)) -> ed {
    u t({
        (s: ed, nm:ed) -> ed in
        u s
    })
}
po(dcb(fed, dcb(fe, gf)))
on jih<ut> {
    let dcb: [(ut, () -> ())] = []
}
po
protocol n : po { func po
class dcb<yx : po, jih : po ts yx.cb == jih> {
}
protocol po {
    typealias cb
    typealias k
}
on n<vu : po> : po {
   typealias jih
}
class n {
    func po((ed, n))(dcb: (ed, kj)) {
        po(dcb)
    }
}
class jih<ut : jih> {
}
ml x = fed
ml hgf: r -> r = {
    u $hg
}
let yx: r = { (cb: r, yx: r -> r) -> r in
    u yx(cb)
}
