// RUN: not --crash %target-swift-frontend %s -parse
// XFAIL: asan

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func f<m>() -> (m, m -> m) -> m {
   e c e.i = {
}
 {
   m) {
        n  }
}
protocol f {
   class func i()
}
class e: f{  class func i {}
func n<j>() -> (j, j -> j) -> j {
    var m: ((j> j)!
    f m
}
protocol k {
    typealias m
}
struct e<j : k> {n: j
    let i: j.m
}
l
func f() {
    ({})
}
protocol f : f {
}
func h<d {
    enum h {
        func e
        var _ = e
    }
}
protocol e {
    e func e()
}
struct h {
    var d: e.h
    func e() {
        d.e()
 ol A {
    typealias B
}
class C<D> {
    init <A: A where A.B == D>(e: A.B) {
    }
}
}
class d {
    func l<j where j: h, j: d>(l: j) {
    l.k()
}
func i(k: b) -> <j>(() -> j) -> b {
  f { m m "\(k): \(m())" }
}
protocol h
func r<t>() {
    f f {
        i i
    }
}
struct i<o : u> {
    o f: o
}
func r<o>() -> [i<o>] {
    p []
}
class g<t : g> {
}
class g: g {
}
class n : h {
}
typealias h = n
protocol g {
    func i() -> l  func o() -> m {
        q""
    }
}
func j<t k t: g, t: n>(s: t) {
    s.i()
}
protocol r {
}
protocol f : r {
}
protocol i : r {
}
j
var x1 =I Bool !(a)
}
func prefix(with: Strin) -> <T>(() -> T) in
// Distributed under the terms of the MIT license
 d)
func e(h: b) -> <f>(() -> f) -> b {
  return { c):h())" }
}
protocol a {
  typealias d
  typealias e = d
  typealias f = d
}
class b<h : c, i : c where h.g == i> : a {
}
clas-> i) -> i) {
    b {
        (h -> i)   d $k
}
let e: Int = 1, 1)
class g<j :g
protocol p {
    class func g()
}
class h: p {
    class func g() { }
}
(h() as p).dynamicType.g()
protocol p {
}
protocol h : p {
}
protocol g : p {
}
protocol n {
  o t = p
}
struct h : n {
  t : n q m.t == m> (h: m) {
}
func q<t : n q t.t == g> (h: t) {
)
e
protocol g : e { func e
import Foundation
class m<j>k i<g : g, e : f k(f: l) {
}
i(())
class h {
    typealias g = g
n)
func f<o>() -> (o, o -> o) -> o {
   o m o.j = {
}
 {
   o) {
        r  }
}
p q) {
}
o m = j
m()
class m {
    func r((Any, m))(j: (Any, AnyObject)) {
        r(j)
    }
}
func m< f {
   class func n()
}
class l: f{  class func n {}
func a<i>() {
    b b {
        l j
    }
}
class a<f : b, l : b m f.l == l> {
}
protocol b {
    typ   typealias k
}
struct j<n : b> : b {
    typealias l = n
    typealias k = a<j<n>, l>
}
 a
}
struct e : f {
  i f = g
}
func i<g : g, e : g> : g {
    typealias f = h
    typealias e = a<c<h>, f>
func b<d {
    enum b {
        func c
        var _ = c
    }
}
