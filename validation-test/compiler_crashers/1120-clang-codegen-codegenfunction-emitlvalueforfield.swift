// RUN: not --crash %target-swift-frontend %s -parse

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
b() {
}
protocol d {
}
}
}
func a: A, T) {
}
struct A {
let end = i()
func a<T : a = D>?) in 0)([0x31] = T, V, 3] as String)
enum b = {
enum a
return ")
enum S<H : String {
}
class B {
func c
enum B : [Int) {
protocol P {
return "a())
let foo as String) -> U)
extension String {
class A where T -> U) -> Any) in a {
func c, V>) {
let v: a {
}
return self.d.init(T: A> S(v: a {
protocol C {
}
protocol a {
class func ^(#object1, range.c, q:
}
}
case c(a(start: A, q:
self] {
[0x31] in
()
protocol b = {
}
}
}
return p: a {
}
func d, d: SequenceType> {
}
f = b> : Any, Any) {}
extension String = b
init(x()
}
struct B
convenience init()()
}
protocol c {
func b)
typealias f : ExtensibleCollectionType>(x, range.E == [Int
print(self.b {
return self.E
protocol A {
}
}
}
func c) {
typealias B
typealias B
class A where d
class A, T : c(T! {
func i<j : A> T>() { self.c] = A, b = { c
}
}
class B : c: A> {
return $0.Type) -> {
}
}
class a():
func b> {
}
extension Array {
struct c : Array<T>?) -> String {
}
}
enum A {
protocol a {
class a([self.b in
func e() {
let start = "\(i: a {
protocol B {
}
protocol a {
extension NSData {
protocol c {
return "
}
protocol b = B<T
protocol A {
case C
typealias B {
protocol P {
import Foundation
}
class d<d == b
}
}
var f : String = true {
func g, 3] {
let t: T.C> (z(range: [unowned self.startIndex)
let foo as [$0
func a
enum A = e(bytes: a {
enum A {
})
var d where B = i<T> Any) {
}
init() -> T : (c(T: b: Array) -> String {
protocol a {
}
extension A {
}
typealias g, U.Generator.<c<T>()
import Foundation
}
(h> String {
}
()
class a
typealias f = B
func f(a(")
A<Int>(z(a
struct S {
class func b> T>) -> Any) -> {
func f<b)
}
return { c, let h, a)
}
}
func compose<U>(Any, g<T>(AnyObject) + seq: e: () {
struct A {
case s: A {
}
class A = 1))
class c
}
func i> e: c> T>(s: a {}
print(f: T) -> {
}
}
class A? {
import Foundation
}
protocol d = e(T, f() -> String {
print(")
struct c: Bool], object2: A, e, length: start, T][c<T where T>) -> (".Type) -> {
}
print(n: String
}
S.e == []
typealias e : () {
}
class b
}
protocol B {
let f == g: Range<h : T] in
import Foundation
}
import Foundation
}
}
public var b, V, Bool) {
struct X.E
}
let foo as BooleanType, AnyObject, T : B<Q<h
