// RUN: not --crash %target-swift-frontend %s -parse
// XFAIL: asan

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

return d<A"\()
import CoreData
return "
case b in x in a {
typealias B<I : B? = {
self] in
let g = compose(g: c> [B) -> ("""
}
case b {
let c: NSObject {
protocol a {
import Foundation
return $0
protocol A : Array) {
self.E == .c> U.dynamicType)
return nil
}
return b
}
}
return d
return true
return [B
let t: P {
func f("")-> Int = { x }
typealias R
}
import Foundation
}
extension NSSet {
}
static let h = [T>: NSManagedObject {
}
let g = { c>()
typealias h> {
convenience init() -> T
var c>Bool)
}
func g(t: C {
var e: String = {
init()
}
}
class d: NSObject {
}
}
self.B
func b<T>(t: T]((t: NSObject {
self] {
protocol c = {
func a(object1: P {
typealias R
convenience init("\() {
class C<T
var e)
}
var e: AnyObject.R
extension NSSet {
let c: Array) -> [B<T] {
import CoreData
var e: A.d.Type) {
class C) -> {
}
protocol P {
println(object2: T
}
}
class C
}
}
typealias e : Int -> : d where T) -> {
let a {
struct D : A {
}
}
import Foundation
let d<H : A? = nil
self.B? {
private let d<T, f: NSManagedObject {
class func f: B<C> : C> Self {
typealias F>(n: NSObject {
}
protocol P {
class A : e, f: AnyObject, AnyObject) -> Int = A"\(n: d = { c) {
typealias F = compose()(f)
class C<f : Int -> {
import Foundation
}
}
class A : A: T>>(false)
}
let g = D>)
import Foundation
struct D : Int -> T>())
import Foundation
let c(AnyObject, b = .init()
println(t: A {
f = b: U.E == {
if true {
}
case b = e: P {
private class A {
return nil
func g<T) {
convenience init()
if c == f<T! {
return self.b = ""
if c = b<T where A: e, object1, f<T] in
override init(n: P {
}
func f(t: A((c: A : A> Int = b> {
}
}
d: Int
}
return d.Type) {
struct S {
[T>()
}
import Foundation
}
class A : T>? {
var b {
self.E
struct B
}
protocol c {
typealias e = 0
func b
struct c {
convenience init(x)
import Foundation
}
typealias R = b
typealias e : B<A? = 0
}
class C) ->) -> Int {
}
return { x }
}
typealias R
}
protocol P {
let c: B("A.e where A.c()(f<T where T>(g<T! {
var b<H : P> {
let f = {
e : T] in
}
}
class A {
}
}
class func b.e == { c(x: e: Int
let v: P {
}
}
class func a(self)
let d<T>) {
}
println(c: B? = B<c> Self {
let c = {
}
self.R
}
class A {
struct c == e: A>>()
let c(n: Array) -> T -> {
}
return $0
}
private class A : U : (x: P> T where H) {
if true {
let c
