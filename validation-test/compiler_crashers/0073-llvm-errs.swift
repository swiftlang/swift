// RUN: not --crash %target-swift-frontend %s -parse

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func kj<ts>() -> (ts, ts -> ts) -> ts {
   nm ml nm.p = {
}
 {
   ts) {
        ji  }
}
protocol kj {
   class func p()
}
class nm: kj{  class func p {}
x nm<q> {
    hg ts(q, () -> ())
}
dc ji = po
dc qp: m -> m = {
    cb $w
}
let e: m = { (c: m, kj: m -> m) -> m on
    cb kj(c)
}(ji, qp)
let u: m = { c, kj on
    cb kj(c)
}(ji, qp)
class c {
    func hg((r, c))(rq: (r, y)) {
        hg(rq)
    }
}
protocol rq hg<ji : c, p : c ih ji.ts == p> : rq {
}
class hg<ji, p> {
}
protocol c {
    o ts
}
protocol rq {
}
protocol hg : rq {
}
protocol c : rq {
}
protocol nm {
  o kj = rq
}
gf e : nm {
  o kj = hg
}
func p<ml : hg, ml : nm ih ml.kj == ml> (cb: ml) {
}
func p<v : nm ih v.kj == c> (cb: v) {
}
p(e())
func c<nm {
    x c {
        func e
        dc _ = e
    }
}
protocol kj {
}
gf v : kj {
}
gf ts<hg, p: kj ih hg.ts == p> {
}
gf c<nm : ut> {
    dc hg: nm
}
func rq<nm>() -> [c<nm>] {
    cb []
}
protocol kj {
    o v
    func hg(v)
}
gf rq<Y> : kj {
    func hg(hg: rq.lk) {
    }
}
class rq<kj : hg, ts : hg ih kj.nm == ts> {
}
protocol hg {
    o nm
    o e
fe e = rq<c<ji>, nm>
}
protocol rq {
    class func c()
}
class hg: rq {
    class func c() { }
}
(hg() s rq).t.c()
func sr(ed: ml) -> <q>(() -> q) -> ml {
  cb { ts on "\(ed): \(ts())" }
}
gf kj<q> {
    let rq: [(q, () -> ())] = []
}
func() {
    x hg {
        hg c
    }
}
func rq(hg: m = w) {
}
let c = rq
