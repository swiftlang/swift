// RUN: not --crash %target-swift-frontend %s -parse
// XFAIL: no_asserts
// XFAIL: asan

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

import Foundation
class m<j>k i<g : g, e : f k(f: l) {
}
i(())
class h {
    typealias g = g
func a<d>() -> [c{    enum b {
        case c
  }
}
class b<i : b> i: g{ func c {}
e g {
 : g {
h func i() ->  }
struct c<d : SequenceType> {
    var b: d
}
func a<d>() -> [c<d>] {
    return []
}
func j(d: h) -> <k>(() -> k) -> h {
  return { n n "\(}
c i<k : i> {
}
 y: Any) -> (((Any, Any) -> Any) -> Any) {
    return {
        (m: (Any, Any) -> Any) -> Any in
        return m(x, y)
    }
}
 
func b(z: (((Any, Any) -> Any) -> Any)) -> Any {
    return z({
        (p: Any, q:Any) -> Any in
        return p
    })
}
b(a(1, a(2, 3)))
func p<p>() -> (p, p -> p) -> p {
   l c l.l = {
}
 {
   p) {
      (e: o, h:o) ->  e
    })
}
j(k(m, k(2, 3)))
func l(p: j) -> <n>(() -> n 
func ^(a: BooleanType, Bool) -> Bool {
    return !(a)
}
func b((Any, e))(e: (Any) -> <d>(()-> d) -> f
protocol A {
    func c()l k {
    func l() -> g {
        m ""
    }
}
class C: k, A {
    j func l()q c() -> g {
        m ""
    }
}
func e<r where r: A, r: k>(n: r) {
    n.c()
}
protocol A {
    typealias h
}
c k<r : A> {
    p f: r
    p p: r.h
}
protocol C      l.e()
    }
}
class o {
    typealias l = l
func h<j>() -> (j, j -> j) -> j {
    var f: ({ (c: e, f: e -> e) ->   return f(c)
}(k, i)
let o: e = { c, g
    return f(c)
}(l) -> m) -> p>, e>
}
class n<j : n> 
struct A<T> {
    let a: [(T, () -> ())] = []
}
struct d<f : e, g: e where g.h == f.h> {
}
protocol e {
    typealias h
}
protocol A {
    func c() -> String
}
class B {
    func d() -> String {
        return ""
    }
}
class C: B, A {
    override func d() -> St}
func i<l : d where l.f == c> (n: l) {
}
i(e())
d> Bool {
    e !(f)
}
b
protocol f : b { func b
)
func n<w>() -> (w, w -> w) -> w {
   o m o.q = {
}
 {
   w) {
        k  }
}
protocol n {
   class func q()
}
class o: n{  class func q {}
func p(e: Int = x) {
}
let c = p
c()
func r<o: y, s q n<s> ==(r(t))
protocol p : p {
}
protocol p {
    class func c()
}
class e: p {
    class func c() { }
}
(e() u p).v.c()
k e.w == l> {
}
func p(c: Any, m: Any) -> (((Any, Any) -> Any) -> Any) {
i)
import Foundation
class q<k>: c a(b: Int = 0) {
}
let c = a
c()
func d<b: SequenceType, e where Optional<e> == b.Generator.Element>(c : b) -> e? {
    for (mx : e?) in c {
struct c<d: SequenceType, b where Optional<b> == d.Generator.Element>
enum S<T> {
    case C(T, () -> ())
}
struct A<T> {
    let a: [(T, () - == g> {
}
protocol g {
    typealias f 
    typealias e
}
struct c<h : g> : g {
    typealias f = h
    typealias e = a<c<h>, f>
a)
func a<b:a
protocol A {
    typealias B
    func b(B)
}
struct X<Y> : A {
    func b(b: X.Type) {
    }
}
func g<h>() -> (h, h -> h) -> h {
    f f: ((h, h -> h) -> h)!
    j f
}
protocol f {
    class func j()
}
struct i {
    f d: f.i
    func j() {
        d.j()
    }
}
class g {
    typealias f = f
}
func g(f: Int = k) {
}
let i = g
struct l<e : SequenceType> {
    l g: e
}
func h<e>() -> [l<e>] {
    f []
}
func i(e: g) -> <j>(() -> j) -> k
func f<e>() -> (e, e -> e) -> e {
   e b e.c = {
}
 {
   e) {
        f  }
}
protocol f {
   class func c()
}
class e: f{  class func c
protocol A {
    typealias E
}
struct B<T : A> {
    let h: T
    let i: T.E
}
protocol C {
    typealias F
    func g<T where T.E == F>(f: B<T>)
}
struct D : C {
    typealias F = Int
    func g<T where T.E == F>(f: B<T>) {
    }
}
