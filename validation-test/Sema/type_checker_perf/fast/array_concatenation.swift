// RUN: %target-typecheck-verify-swift -disable-constraint-solver-performance-hacks

// Self-contained test case
protocol P1 {}; func f<T: P1>(_: T, _: T) -> T { fatalError() }
protocol P2 {}; func f<T: P2>(_: T, _: T) -> T { fatalError() }
protocol P3 {}; func f<T: P3>(_: T, _: T) -> T { fatalError() }
protocol P4 {}; func f<T: P4>(_: T, _: T) -> T { fatalError() }

func f<T>(_: Array<T>, _: Array<T>) -> Array<T> { fatalError() }

let fn1: (_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) -> Array<Int> = {
  f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f($0, $1), $2), $3), $4), $5), $6), $7), $8), $9), $10), $11), $12), $13), $14), $15), $16), $17), $18), $19)
}

let fn2: (_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) -> Array<Int> = {
  f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f([$0], [$1]), [$2]), [$3]), [$4]), [$5]), [$6]), [$7]), [$8]), [$9]), [$10]), [$11]), [$12]), [$13]), [$14]), [$15]), [$16]), [$17]), [$18]), [$19])
}

let x1: Array<Int> = f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f([0], [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0]), [0])

// Same setup with standard library operator
let fn3: (_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) -> Array<Int> = {
  $0 + $1 + $2 + $3 + $4 + $5 + $6 + $7 + $8 + $9 + $10 + $11 + $12 + $13 + $14 + $15 + $16 + $17 + $18 + $19
}

let fn4: (_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) -> Array<Int> = {
  [$0] + [$1] + [$2] + [$3] + [$4] + [$5] + [$6] + [$7] + [$8] + [$9] + [$10] + [$11] + [$12] + [$13] + [$14] + [$15] + [$16] + [$17] + [$18] + [$19]
}

let x2: Array<Int> = [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0] + [0]
