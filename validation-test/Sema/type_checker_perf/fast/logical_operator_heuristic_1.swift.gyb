// RUN: %scale-test --begin 1 --end 6 --step 1 --select NumLeafScopes %s
// REQUIRES: tools-release,no_asan,asserts

public struct S1: Equatable {}
public struct S2: Equatable {}
public struct S3: Equatable {}

// Here, we have overloads of &&, which usually isn't overloaded.
// The expression does not actually involve those overloads.

public func && (_: S1, _: S1) -> S2 { S2() }
public func && (_: S2, _: S3) -> S2 { S2() }
public func && (_: S3, _: S2) -> S2 { S2() }
public func && (_: S2, _: S1) -> S2 { S2() }
public func && (_: S1, _: S2) -> S2 { S2() }
public func && (_: S3, _: S3) -> S2 { S2() }
public func && (_: S3, _: S1) -> S2 { S2() }
public func && (_: S1, _: S3) -> S2 { S2() }

public struct G<T> {}

public func && <T>(_: G<T>, _: G<T>) -> G<T> { G<T>() }

public func == <T, U>(_: U, _: U) -> G<T> where U : Equatable { G<T>() }
public func == <T, U>(_: KeyPath<T, U>, _: U) -> G<T> where U : Equatable { G<T>() }
public func == <T, U>(_: U, _: KeyPath<T, U>) -> G<T> where U : Equatable { G<T>() }
public func == <T, U>(_: KeyPath<T, U>, _: KeyPath<T, U>) -> G<T> where U : Equatable { G<T>() }

public struct S4: Equatable {}

public struct S5: Equatable {
  public static func == (lhs: S5, rhs: S5) -> Bool {
    return (lhs.lastEditedBy == rhs.lastEditedBy &&
%for i in range(0, N):
            lhs.lastEditedBy == rhs.lastEditedBy &&
%end
            lhs.lastEditedBy == rhs.lastEditedBy)
  }

  var lastEditedBy: S4?
}

