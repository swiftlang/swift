// RUN: not %target-swift-frontend %s -parse

// Without assertions, this test fails nondeterministically.
// REQUIRES: asserts

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

let h> T -> U)
import Foundation
let f = {
}
typealias h
struct c == 0
}
typealias e : I.init(array: Int
typealias F
}
deinit {
}
typealias F>(f: P {
struct c == {
}
0
}
class A where T
class func a(e: Int = c> T) {
}
}
}
}
return nil
}
}
convenience init(x: AnyObject) {
let t: AnyObject) -> {
}
println(")
extension NSSet {
extension NSSet {
class A {
struct S<T>()
return $0) -> T where T] in
enum A where T> Int = {
return g<T: AnyObject) {
}
}
}
b: H.E == a
protocol c == {
struct d: C<H : a {
var e: NSObject {
}
b
}
struct Q<D> : Int = {
protocol A : Array) {
let c = [unowned self.B == 0
typealias R
}
class A where T>()
protocol P {
}
return $0
}
}
protocol e = nil
}
struct B? {
class A : e, object2)?
protocol a = T, b {
struct e = compose(x)
var d = b.c {
}
return nil
}
let t: I.E
}
func a(g(b
}
class A where T: T> String {
self.E == "
}
return $0
func compose(self.init()
func g(b<(x: C {
struct B<C) {
func f)
}
}
struct Q<T>(f: (x: NSObject {
struct c = "
let d<U -> (array: A? = D> Int -> Void>(n: C
}
}
self.h = {
}
typealias E
}
}
typealias e {
import CoreData
println(f)
let t: e: NSManagedObject {
struct B<C> : A.c : AnyObject.c = e!.d
}
b> : B()-> String = B()-> V, g() -> String {
}
}
protocol a {
}
return [T
func a
}
convenience init()
let c>) {
if true {
import Foundation
class B<T>]()"")
}
struct e : A"")
return [T, g<T> Self {
}
return "")
}
convenience init(v: Array<T {
protocol b in
protocol A {
var e: Int = {
deinit {
}
}
self.c> V {
struct c : c()
protocol P {
}
func g, e)
var b in x }
}
}
typealias F>(() {
let d: $0) -> {
protocol A : I) {
let c : NSObject {
static let v: P> T>()?
let c(x: P {
let c
protocol A {
import Foundation
protocol b : $0
var f: T -> U, f<c(#object1: T {
}
typealias e = B
return nil
}
let t: I.Type) {
class d.c = c()
enum S<I : Int
}
}
typealias h: B<T {
let t: Array<T>()
}
enum A : C {
func a(self.h: U -> : B<T>: A(g: T>>) {
private let i: e = B<T.a
func g: A>(self)
return nil
}
func b(b: C<I : AnyObject, b = e: I.b = {
protocol A {
}
let g = c) {
func a()
var b = B(T
extension NSSet {
}
}
let a = {
}
b: B? = compose() -> : A: P {
}
import Foundation
0
func a(f<T> U, f, e: e == {
var f = 1, object2)
