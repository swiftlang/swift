#!/usr/bin/env bash
#===--- build-script-impl - Implementation details of build-script ---------===#
#
## This source file is part of the Swift.org open source project
##
## Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
## Licensed under Apache License v2.0 with Runtime Library Exception
##
## See http://swift.org/LICENSE.txt for license information
## See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
#===------------------------------------------------------------------------===#

#
# This script is an implementation detail of other build scripts and should not
# be called directly.
#
# Note: This script will NOT auto-clean before building.
#

set -o pipefail
set -e

umask 0022

#
# Options that can be "configured" by editing this file.
#
# These options are not exposed as command line options on purpose.  If you
# need to change any of these, you should do so on trunk or in a branch.
#

LLVM_TARGETS_TO_BUILD="X86;ARM;AArch64;PowerPC"

#
# End of configurable options.
#

# Declare the set of known settings along with each one's description
#
# If you add a user-settable variable, add it to this list.
#
# A default value of "" indicates that the corresponding variable
# will remain unset unless set explicitly.
#
# skip-* parameters do not affect the configuration (CMake parameters).
# You can turn them on and off in different invocations of the script for the
# same build directory.
#
# build-* parameters affect the CMake configuration (enable/disable those
# components).
#
# Each variable name is re-exported into this script in uppercase, where dashes
# are substituted by underscores. For example, `swift-install-components` is
# referred to as `SWIFT_INSTALL_COMPONENTS` in the remainder of this script.
KNOWN_SETTINGS=(
    # name                      default          description
    build-args                  ""               "arguments to the build tool; defaults to -j8 when CMake generator is \"Unix Makefiles\""
    build-dir                   ""               "out-of-tree build directory; default is in-tree. **This argument is required**"
    host-cc                     ""               "the path to CC, the 'clang' compiler for the host platform. **This argument is required**"
    host-cxx                    ""               "the path to CXX, the 'clang++' compiler for the host platform. **This argument is required**"
    darwin-xcrun-toolchain      "default"        "the name of the toolchain to use on Darwin"
    build-ninja                 ""               "build the Ninja tool"
    cmark-build-type            "Debug"          "the CMake build variant for CommonMark (Debug, RelWithDebInfo, Release, MinSizeRel).  Defaults to Debug."
    lldb-extra-cmake-args       ""               "extra command line args to pass to lldb cmake"
    lldb-extra-xcodebuild-args  ""               "extra command line args to pass to lldb xcodebuild"
    lldb-test-cc                ""               "CC to use for building LLDB testsuite test inferiors.  Defaults to just-built, in-tree clang.  If set to 'host-toolchain', sets it to same as host-cc."
    lldb-test-with-curses       ""               "run test lldb test runner using curses terminal control"
    lldb-no-debugserver         ""               "delete debugserver after building it, and don't try to codesign it"
    lldb-use-system-debugserver ""               "don't try to codesign debugserver, and use the system's debugserver instead"
    llvm-build-type             "Debug"          "the CMake build variant for LLVM and Clang (Debug, RelWithDebInfo, Release, MinSizeRel).  Defaults to Debug."
    llvm-enable-assertions      "1"              "enable assertions in LLVM and Clang"
    swift-build-type            "Debug"          "the CMake build variant for Swift"
    swift-enable-assertions     "1"              "enable assertions in Swift"
    swift-analyze-code-coverage "not-merged"     "Code coverage analysis mode for Swift (false, not-merged, merged). Defaults to false if the argument is not present, and not-merged if the argument is present without a modifier."
    swift-enable-lto            "0"              "enable LTO compilation of just Swift."
    llvm-enable-lto             "0"              "enable LTO compilation of LLVM/Clang."
    swift-stdlib-build-type     "Debug"          "the CMake build variant for Swift"
    swift-stdlib-enable-assertions "1"           "enable assertions in Swift"
    swift-stdlib-enable-reflection-metadata "0"  "build the Swift stdlib and overlays with remote reflection metadata"
    swift-stdlib-enable-resilience "0"           "build the Swift stdlib and overlays with resilience enabled"
    swift-stdlib-sil-serialize-all "1"           "build the Swift stdlib and overlays with all method bodies serialized"
    lldb-build-type             "Debug"          "the CMake build variant for LLDB"
    llbuild-build-type          "Debug"          "the CMake build variant for llbuild"
    foundation-build-type       "Debug"          "the build variant for Foundation"
    llbuild-enable-assertions   "1"              "enable assertions in llbuild"
    enable-asan                 ""               "enable Address Sanitizer"
    enable-ubsan                ""               "enable Undefined Behavior Sanitizer"
    cmake                       ""               "path to the cmake binary"
    distcc                      ""               "use distcc in pump mode"
    build-runtime-with-host-compiler   "1"       "use the host c++ compiler to build everything"
    user-config-args            ""               "User-supplied arguments to cmake when used to do configuration"
    cmake-generator             "Unix Makefiles" "kind of build system to generate; see output of 'cmake --help' for choices"
    verbose-build               ""               "print the commands executed during the build"
    install-prefix              ""               "installation prefix"
    toolchain-prefix            ""               "the path to the .xctoolchain directory that houses the install prefix path"
    install-destdir             ""               "the path to use as the filesystem root for the installation"
    install-symroot             ""               "the path to install debug symbols into"
    swift-install-components    ""               "a semicolon-separated list of Swift components to install"
    llvm-install-components    ""                "a semicolon-separated list of LLVM components to install"
    installable-package         ""               "the path to the archive of the installation directory"
    test-installable-package    ""               "whether to run post-packaging tests on the produced package"
    reconfigure                 ""               "force a CMake configuration run even if CMakeCache.txt already exists"
    swift-sdks                  ""               "build target binaries only for specified SDKs (semicolon-separated list)"
    swift-primary-variant-sdk   ""               "default SDK for target binaries"
    swift-primary-variant-arch  ""               "default arch for target binaries"
    skip-ios                    ""               "set to skip everything iOS-related"
    skip-tvos                   ""               "set to skip everything tvOS-related"
    skip-watchos                ""               "set to skip everything watchOS-related"
    skip-build-cmark            ""               "set to skip building CommonMark"
    skip-build-llvm             ""               "set to skip building LLVM/Clang"
    skip-build-swift            ""               "set to skip building Swift"
    skip-build-linux            ""               "set to skip building Swift stdlibs for Linux"
    skip-build-freebsd          ""               "set to skip building Swift stdlibs for FreeBSD"
    skip-build-cygwin           ""               "set to skip building Swift stdlibs for Cygwin"
    skip-build-osx              ""               "set to skip building Swift stdlibs for OSX"
    skip-build-ios              ""               "set to skip building Swift stdlibs for iOS"
    skip-build-ios-device       ""               "set to skip building Swift stdlibs for iOS devices (i.e. build simulators only)"
    skip-build-ios-simulator    ""               "set to skip building Swift stdlibs for iOS simulators (i.e. build devices only)"
    skip-build-tvos             ""               "set to skip building Swift stdlibs for tvOS"
    skip-build-tvos-device      ""               "set to skip building Swift stdlibs for tvOS devices (i.e. build simulators only)"
    skip-build-tvos-simulator   ""               "set to skip building Swift stdlibs for tvOS simulators (i.e. build devices only)"
    skip-build-watchos          ""               "set to skip building Swift stdlibs for Apple watchOS"
    skip-build-watchos-device   ""               "set to skip building Swift stdlibs for Apple watchOS devices (i.e. build simulators only)"
    skip-build-watchos-simulator ""              "set to skip building Swift stdlibs for Apple watchOS simulators (i.e. build devices only)"
    skip-build-android          ""               "set to skip building Swift stdlibs for Android"
    skip-build-lldb             ""               "set to skip building LLDB"
    skip-build-llbuild          ""               "set to skip building llbuild"
    skip-build-swiftpm          ""               "set to skip building swiftpm"
    skip-build-xctest           ""               "set to skip building xctest"
    skip-build-foundation       ""               "set to skip building foundation"
    skip-build-libdispatch      ""               "set to skip building libdispatch"
    skip-build-benchmarks       ""               "set to skip building Swift Benchmark Suite"
    skip-test-cmark             ""               "set to skip testing CommonMark"
    skip-test-lldb              ""               "set to skip testing lldb"
    skip-test-swift             ""               "set to skip testing Swift"
    skip-test-llbuild           ""               "set to skip testing llbuild"
    skip-test-swiftpm           ""               "set to skip testing swiftpm"
    skip-test-xctest            ""               "set to skip testing xctest"
    skip-test-foundation        ""               "set to skip testing foundation"
    skip-test-libdispatch       ""               "set to skip testing libdispatch"
    skip-test-linux             ""               "set to skip testing Swift stdlibs for Linux"
    skip-test-freebsd           ""               "set to skip testing Swift stdlibs for FreeBSD"
    skip-test-cygwin            ""               "set to skip testing Swift stdlibs for Cygwin"
    skip-test-osx               ""               "set to skip testing Swift stdlibs for OSX"
    skip-test-ios-simulator     ""               "set to skip testing Swift stdlibs for iOS simulators (i.e. test devices only)"
    skip-test-ios-host          ""               "set to skip testing the host parts of the iOS toolchain"
    skip-test-tvos-simulator    ""               "set to skip testing Swift stdlibs for tvOS simulators (i.e. test devices only)"
    skip-test-tvos-host         ""               "set to skip testing the host parts of the tvOS toolchain"
    skip-test-watchos-simulator  ""              "set to skip testing Swift stdlibs for Apple watchOS simulators (i.e. test devices only)"
    skip-test-watchos-host      ""               "set to skip testing the host parts of the watchOS toolchain"
    validation-test             "0"              "set to run the validation test suite"
    long-test                   "0"              "set to run the long test suite"
    skip-test-benchmarks        ""               "set to skip running Swift Benchmark Suite"
    skip-test-optimized         ""               "set to skip testing the test suite in optimized mode"
    stress-test-sourcekit       ""               "set to run the stress-SourceKit target"
    workspace                   "${HOME}/src"    "source directory containing llvm, clang, swift"
    enable-llvm-assertions      "1"              "set to enable llvm assertions"
    build-llvm                  "1"              "set to 1 to build LLVM and Clang"
    build-swift-tools           "1"              "set to 1 to build Swift host tools"
    build-swift-stdlib          "1"              "set to 1 to build the Swift standard library"
    build-swift-stdlib-unittest-extra "0"        "set to 1 to build optional StdlibUnittest components"
    build-swift-sdk-overlay     "1"              "set to 1 to build the Swift SDK overlay"
    build-swift-static-stdlib   "0"              "set to 1 to build static versions of the Swift standard library and SDK overlay"
    build-swift-examples        "1"              "set to 1 to build examples"
    build-serialized-stdlib-unittest "0"         "set to 1 to build the StdlibUnittest module with -sil-serialize-all"
    build-sil-debugging-stdlib  "0"              "set to 1 to build the Swift standard library with -gsil to enable debugging and profiling on SIL level"
    source-tree-includes-tests  "1"              "set to 0 to allow the build to proceed when 'test' directory is missing (required for B&I builds)"
    native-llvm-tools-path      ""               "directory that contains LLVM tools that are executable on the build machine"
    native-clang-tools-path     ""               "directory that contains Clang tools that are executable on the build machine"
    native-swift-tools-path     ""               "directory that contains Swift tools that are executable on the build machine"
    compiler-vendor             "none"           "compiler vendor name [none,apple]"
    clang-user-visible-version  "3.8.0"          "user-visible version of the embedded Clang and LLVM compilers"
    swift-user-visible-version  "3.0"            "user-visible version of the Swift language"
    swift-compiler-version      ""               "string that indicates a compiler version for Swift"
    clang-compiler-version      ""               "string that indicates a compiler version for Clang"
    embed-bitcode-section       "0"              "embed an LLVM bitcode section in stdlib/overlay binaries for supported platforms"
    darwin-crash-reporter-client ""              "whether to enable CrashReporter integration"
    darwin-stdlib-install-name-dir ""            "the directory of the install_name for standard library dylibs"
    install-cmark               ""               "whether to install cmark"
    install-swift               ""               "whether to install Swift"
    install-lldb                ""               "whether to install LLDB"
    install-llbuild             ""               "whether to install llbuild"
    install-swiftpm             ""               "whether to install swiftpm"
    install-xctest              ""               "whether to install xctest"
    install-foundation          ""               "whether to install foundation"
    install-libdispatch         ""               "whether to install libdispatch"
    darwin-install-extract-symbols ""            "whether to extract symbols with dsymutil during installations"
    host-target                 ""               "The host target. LLVM, Clang, and Swift will be built for this target. The built LLVM and Clang will be used to compile Swift for the cross-compilation targets. **This argument is required**"
    stdlib-deployment-targets   ""               "space-separated list of targets to compile or cross-compile the Swift standard library for"
    cross-compile-tools-deployment-targets ""    "space-separated list of targets to cross-compile host Swift tools for"
    skip-merge-lipo-cross-compile-tools ""       "set to skip running merge-lipo after installing cross-compiled host Swift tools"
    darwin-deployment-version-osx     "10.9"     "minimum deployment target version for OS X"
    darwin-deployment-version-ios     "7.0"      "minimum deployment target version for iOS"
    darwin-deployment-version-tvos    "9.0"      "minimum deployment target version for tvOS"
    darwin-deployment-version-watchos "2.0"      "minimum deployment target version for watchOS"

    extra-cmake-options         ""               "Extra options to pass to CMake for all targets"
    extra-swift-args            ""               "Extra arguments to pass to swift modules which match regex. Assumed to be a flattened cmake list consisting of [module_regexp, args, module_regexp, args, ...]"
    sil-verify-all              "0"              "If enabled, run the SIL verifier after each transform when building Swift files during this build process"
    swift-enable-ast-verifier   "1"              "If enabled, and the assertions are enabled, the built Swift compiler will run the AST verifier every time it is invoked"
    swift-runtime-enable-leak-checker   "0"              "Enable leaks checking routines in the runtime"
    use-gold-linker             ""               "Enable using the gold linker"
    darwin-toolchain-bundle-identifier ""        "CFBundleIdentifier for xctoolchain info plist"
    darwin-toolchain-display-name      ""        "Display Name for xctoolcain info plist"
    darwin-toolchain-name              ""        "Directory name for xctoolchain"
    darwin-toolchain-version           ""        "Version for xctoolchain info plist and installer pkg"
    darwin-toolchain-application-cert  ""        "Application Cert name to codesign xctoolchain"
    darwin-toolchain-installer-cert    ""        "Installer Cert name to create installer pkg"
    darwin-toolchain-installer-package ""        "The path to installer pkg"
    build-jobs                         ""        "The number of parallel build jobs to use"
    darwin-toolchain-alias             ""        "Swift alias for toolchain"
    android-ndk                        ""        "An absolute path to the NDK that will be used as a libc implementation for Android builds"
    android-ndk-version                ""        "A version of the NDK to use when building for Android. Currently only 21 or above is supported"
    android-ndk-toolchain-version      ""        "A version of the toolchain to use when building for Android. Use 4.8 for 32-bit builds, 4.9 for 64-bit builds"
    android-icu-uc                     ""        "Path to a directory containing libicuuc.so"
    android-icu-uc-include             ""        "Path to a directory containing headers for libicuuc"
    android-icu-i18n                   ""        "Path to a directory containing libicui18n.so"
    android-icu-i18n-include           ""        "Path to a directory containing headers libicui18n"
    export-compile-commands            ""        "set to generate JSON compilation databases for each build product"
)

function toupper() {
    echo "$@" | tr '[:lower:]' '[:upper:]'
}

function to_varname() {
    toupper "${1//-/_}"
}

function join_array_with_delimiter() {
    # $1 is the delimiter
    local IFS="$1"
    shift
    echo "$*"
}

function set_lldb_build_mode() {
    LLDB_BUILD_MODE="CustomSwift-${LLDB_BUILD_TYPE}"
}

function system_memory_in_bytes() {
    case "$(uname -s -m)" in
        Darwin\ x86_64)
            sysctl hw.memsize | cut -f 2 -d " "
            ;;
        *)
            echo "Unknown operating system"
            exit 1
            ;;
    esac
}

function float_min() {
    local LHS=$1
    local RHS=$2
    if (( $(echo "${LHS} < ${RHS}" | bc -l) )); then
        echo ${LHS}
    else
        echo ${RHS}
    fi
}

function num_llvm_parallel_lto_link_jobs() {
    case "$(uname -s -m)" in
        Darwin\ x86_64)
            # Currently with -gline-tables-only clang is ~3.5GB on Darwin. Use
            # the formula GB Memory/3.5GB to get the number of parallel link
            # threads we can support.
            local NUM_MEMORY_THREADS=$(echo $(system_memory_in_bytes)/1000000000.0/3.5 | bc)
            echo $(float_min "${NUM_MEMORY_THREADS}" "${BUILD_JOBS}")
            ;;
        *)
            echo "Unknown operating system"
            exit 1
            ;;
    esac
}

function num_swift_parallel_lto_link_jobs() {
    case "$(uname -s -m)" in
        Darwin\ x86_64)
            # Currently with -gline-tables-only swift is ~5-6GB on Darwin. Use
            # the formula GB Memory/6GB to get the number of parallel link
            # threads we can support.
            local NUM_MEMORY_THREADS=$(echo $(system_memory_in_bytes)/1000000000/6.0 | bc)
            echo $(float_min "${NUM_MEMORY_THREADS}" "${BUILD_JOBS}")
            ;;
        *)
            echo "Unknown operating system"
            exit 1
            ;;
    esac
}

function set_deployment_target_based_options() {
    llvm_cmake_options=()
    swift_cmake_options=()
    cmark_cmake_options=()
    swiftpm_bootstrap_options=()

    case ${deployment_target} in
        linux-x86_64)
            SWIFT_HOST_VARIANT_ARCH="x86_64"
            ;;
        linux-armv6)
            # ARM targets require the gold linker
            USE_GOLD_LINKER=1
            SWIFT_HOST_VARIANT_ARCH="armv6"
            ;;
        linux-armv7)
            # ARM targets require the gold linker
            USE_GOLD_LINKER=1
            SWIFT_HOST_VARIANT_ARCH="armv7"
            ;;
        linux-aarch64)
            # ARM targets require the gold linker
            USE_GOLD_LINKER=1
            SWIFT_HOST_VARIANT_ARCH="aarch64"
            ;;
        freebsd-x86_64)
            SWIFT_HOST_VARIANT_ARCH="x86_64"
            ;;
        linux-powerpc64)
            SWIFT_HOST_VARIANT_ARCH="powerpc64"
            ;;
        linux-powerpc64le)
            SWIFT_HOST_VARIANT_ARCH="powerpc64le"
            ;;
        cygwin-x86_64)
            SWIFT_HOST_VARIANT_ARCH="x86_64"
            ;;
        macosx-* | iphoneos-* | iphonesimulator-* | \
          appletvos-* | appletvsimulator-* | \
            watchos-* | watchsimulator-*)
            case ${deployment_target} in
                macosx-x86_64)
                    xcrun_sdk_name="macosx"
                    llvm_host_triple="x86_64-apple-macosx${DARWIN_DEPLOYMENT_VERSION_OSX}"
                    llvm_target_arch=""
                    cmake_osx_deployment_target="${DARWIN_DEPLOYMENT_VERSION_OSX}"
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                        -DCMAKE_OSX_DEPLOYMENT_TARGET="${cmake_osx_deployment_target}"
                    )
                    swiftpm_bootstrap_options=(
                        --sysroot="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                iphonesimulator-i386)
                    xcrun_sdk_name="iphonesimulator"
                    llvm_host_triple="i386-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    llvm_target_arch="X86"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="iphonesimulator"
                        -DSWIFT_HOST_VARIANT_SDK="IOS_SIMULATOR"
                        -DSWIFT_HOST_VARIANT_ARCH="i386"
                    )
                    ;;
                iphonesimulator-x86_64)
                    xcrun_sdk_name="iphonesimulator"
                    llvm_host_triple="x86_64-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    llvm_target_arch="X86"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="iphonesimulator"
                        -DSWIFT_HOST_VARIANT_SDK="IOS_SIMULATOR"
                        -DSWIFT_HOST_VARIANT_ARCH="x86_64"
                    )
                    ;;
                iphoneos-armv7)
                    xcrun_sdk_name="iphoneos"
                    llvm_host_triple="armv7-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    llvm_target_arch="ARM"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="iphoneos"
                        -DSWIFT_HOST_VARIANT_SDK="IOS"
                        -DSWIFT_HOST_VARIANT_ARCH="armv7"
                    )
                    ;;
                iphoneos-armv7s)
                    xcrun_sdk_name="iphoneos"
                    llvm_host_triple="armv7s-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    llvm_target_arch="ARM"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="iphoneos"
                        -DSWIFT_HOST_VARIANT_SDK="IOS"
                        -DSWIFT_HOST_VARIANT_ARCH="armv7s"
                    )
                    ;;
                iphoneos-arm64)
                    xcrun_sdk_name="iphoneos"
                    llvm_host_triple="arm64-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    llvm_target_arch="AArch64"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="iphoneos"
                        -DSWIFT_HOST_VARIANT_SDK="IOS"
                        -DSWIFT_HOST_VARIANT_ARCH="arm64"
                    )
                    ;;
                appletvsimulator-x86_64)
                    xcrun_sdk_name="appletvsimulator"
                    llvm_host_triple="x86_64-apple-tvos${DARWIN_DEPLOYMENT_VERSION_TVOS}"
                    llvm_target_arch="X86"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="appletvsimulator"
                        -DSWIFT_HOST_VARIANT_SDK="TVOS_SIMULATOR"
                        -DSWIFT_HOST_VARIANT_ARCH="x86_64"
                    )
                    ;;
                appletvos-arm64)
                    xcrun_sdk_name="appletvos"
                    llvm_host_triple="arm64-apple-tvos${DARWIN_DEPLOYMENT_VERSION_TVOS}"
                    llvm_target_arch="AArch64"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="appletvos"
                        -DSWIFT_HOST_VARIANT_SDK="TVOS"
                        -DSWIFT_HOST_VARIANT_ARCH="arm64"
                    )
                    ;;
                watchsimulator-i386)
                    xcrun_sdk_name="watchsimulator"
                    llvm_host_triple="i386-apple-watchos${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
                    llvm_target_arch="X86"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="watchsimulator"
                        -DSWIFT_HOST_VARIANT_SDK="WATCHOS_SIMULATOR"
                        -DSWIFT_HOST_VARIANT_ARCH="i386"
                    )
                    ;;
                watchos-armv7k)
                    xcrun_sdk_name="watchos"
                    llvm_host_triple="armv7k-apple-watchos${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
                    llvm_target_arch="ARM"
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${deployment_target})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    swift_cmake_options=(
                        -DSWIFT_HOST_VARIANT="watchos"
                        -DSWIFT_HOST_VARIANT_SDK="WATCHOS"
                        -DSWIFT_HOST_VARIANT_ARCH="armv7k"
                    )
                    ;;
                *)
                    echo "Unknown deployment target"
                    exit 1
                    ;;
            esac

            llvm_cmake_options=(
                -DCMAKE_OSX_DEPLOYMENT_TARGET:STRING="${cmake_osx_deployment_target}"
                -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                -DLLVM_HOST_TRIPLE:STRING="${llvm_host_triple}"
                -DLLVM_ENABLE_LIBCXX:BOOL=TRUE
                -DLLVM_TOOL_COMPILER_RT_BUILD:BOOL="$(false_true ${SKIP_COMPILER_RT})"
                -DCOMPILER_RT_ENABLE_IOS:BOOL="$(false_true ${SKIP_IOS})"
                -DCOMPILER_RT_ENABLE_WATCHOS:BOOL=FALSE
                -DCOMPILER_RT_ENABLE_TVOS:BOOL=FALSE
            )
            if [[ $(true_false "${LLVM_ENABLE_LTO}") = "TRUE" ]]; then
                if [[ $(cmake_needs_to_specify_standard_computed_defaults) = "TRUE" ]]; then
                    llvm_cmake_options=(
                        "${llvm_cmake_options[@]}"
                        "-DCMAKE_C_STANDARD_COMPUTED_DEFAULT=AppleClang"
                        "-DCMAKE_CXX_STANDARD_COMPUTED_DEFAULT=AppleClang"
                    )
                fi

                lvm_cmake_options=(
                    "${llvm_cmake_options[@]}"
                    "-DCMAKE_C_FLAGS=-O2 -flto -gline-tables-only -fno-stack-protector "
                    "-DCMAKE_CXX_FLAGS=-O2 -flto -gline-tables-only -fno-stack-protector "
                    "-DCMAKE_C_FLAGS_RELWITHDEBINFO=-O2 -flto -gline-tables-only -fno-stack-protector "
                    "-DCMAKE_CXX_FLAGS_RELWITHDEBINFO=-O2 -flto -gline-tables-only -fno-stack-protector "
                    "-DLLVM_PARALLEL_LINK_JOBS=$(num_llvm_parallel_lto_link_jobs)"
                )
            fi

            if [[ $(true_false "${SWIFT_ENABLE_LTO}") = "TRUE" ]]; then
                if [[ $(cmake_needs_to_specify_standard_computed_defaults) = "TRUE" ]]; then
                    swift_cmake_options=(
                        "${swift_cmake_options[@]}"
                        "-DCMAKE_C_STANDARD_COMPUTED_DEFAULT=AppleClang"
                        "-DCMAKE_CXX_STANDARD_COMPUTED_DEFAULT=AppleClang"
                        "-DSWIFT_PARALLEL_LINK_JOBS=$(num_swift_parallel_lto_link_jobs)"
                    )
                fi
            fi

            swift_cmake_options=(
                "${swift_cmake_options[@]}"
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_OSX="${DARWIN_DEPLOYMENT_VERSION_OSX}"
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_IOS="${DARWIN_DEPLOYMENT_VERSION_IOS}"
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_TVOS="${DARWIN_DEPLOYMENT_VERSION_TVOS}"
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_WATCHOS="${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
                -DLLVM_ENABLE_LIBCXX:BOOL=TRUE
            )

            if [[ "${llvm_target_arch}" ]] ; then
                llvm_cmake_options=(
                    "${llvm_cmake_options[@]}"
                    -DLLVM_TARGET_ARCH="${llvm_target_arch}"
                )
            fi

            ;;
        *)
            echo "Unknown compiler deployment target: ${deployment_target}"
            exit 1
            ;;
    esac

}

# Set up an "associative array" of settings for error checking, and set
# (or unset) each corresponding variable to its default value
# If the Mac's bash were not stuck in the past, we could "declare -A" an
# associative array, but instead we have to hack it by defining variables
# declare -A IS_KNOWN_SETTING
for ((i = 0; i < ${#KNOWN_SETTINGS[@]}; i += 3)); do
    setting="${KNOWN_SETTINGS[i]}"

    default_value="${KNOWN_SETTINGS[$((i+1))]}"

    varname="$(to_varname "${setting}")"    # upcase the setting name to get the variable
    eval "${varname}_IS_KNOWN_SETTING=1"

    if [[ "${default_value}" ]] ; then
        # For an explanation of the backslash see http://stackoverflow.com/a/9715377
        eval ${varname}=$\default_value
    else
        unset ${varname}
    fi
done

COMMAND_NAME="$(basename "$0")"

# Print instructions for using this script to stdout
usage() {
    echo "Usage: ${COMMAND_NAME} [--help|-h] [ --SETTING=VALUE | --SETTING VALUE | --SETTING ]*"
    echo
    echo "  Available settings. Each setting corresponds to a variable,"
    echo "  obtained by upcasing its name, in this script.  A variable"
    echo "  with no default listed here will be unset in the script if"
    echo "  not explicitly specified.  A setting passed in the 3rd form"
    echo "  will set its corresponding variable to \"1\"."
    echo

    setting_list="
 | |Setting| Default|Description
 | |-------| -------|-----------
"

    for ((i = 0; i < ${#KNOWN_SETTINGS[@]}; i += 3)); do
        setting_list+="\
 | |--${KNOWN_SETTINGS[i]}| ${KNOWN_SETTINGS[$((i+1))]}|${KNOWN_SETTINGS[$((i+2))]}
"
    done
    echo "${setting_list}" | column -x -s'|' -t
    echo
    echo "Note: when using the form --SETTING VALUE, VALUE must not begin "
    echo "      with a hyphen."
    echo "Note: the \"--release\" option creates a pre-packaged combination"
    echo "      of settings used by the buildbot."
    echo
    echo "Cross-compiling Swift host tools"
    echo "  When building cross-compiled tools, it first builds for the native"
    echo "  build host machine. Then it proceeds to build the specified cross-compile"
    echo "  targets. It currently builds the requested variants of stdlib each"
    echo "  time around, so once for the native build, then again each time for"
    echo "  the cross-compile tool targets."
    echo
    echo "  When installing cross-compiled tools, it first installs each target"
    echo "  arch into a separate subdirectory under install-destdir, since you"
    echo "  can cross-compile for multiple targets at the same time. It then runs"
    echo "  recursive-lipo to produce fat binaries by merging the cross-compiled"
    echo "  targets, installing the merged result into the expected location of"
    echo "  install-destdir. After that, any remaining steps to extract dsyms and"
    echo "  create an installable package operates on install-destdir as normal."
}

# Scan all command-line arguments
while [[ "$1" ]] ; do
    case "$1" in
        -h | --help )
            usage
            exit
            ;;

        --* )
            dashless="${1:2}"

            # drop suffix beginning with the first "="
            setting="${dashless%%=*}"

            # compute the variable to set
            varname="$(to_varname "${setting}")"

            # check to see if this is a known option
            known_var_name="${varname}_IS_KNOWN_SETTING"
            if [[ ! "${!known_var_name}" ]] ; then
                echo "Error: Unknown setting: ${setting}" 1>&2
                usage 1>&2
                exit 1
            fi

            # find the intended value
            if [[ "${dashless}" == *=* ]] ; then              # if there's an '=', the value
                value="${dashless#*=}"                        #   is everything after the first '='
            elif [[ "$2" ]] && [[ "${2:0:1}" != "-" ]] ; then # else if the next parameter exists
                value="$2"                                    #   but isn't an option, use that
                shift
            else                                              # otherwise, the value is 1
                value=1
            fi

            # For explanation of backslash see http://stackoverflow.com/a/9715377
            eval ${varname}=$\value
            ;;

        *)
            usage
            exit 1
    esac
    shift
done

if [[ "${SKIP_IOS}" ]] ; then
    SKIP_BUILD_IOS=1
    SKIP_BUILD_IOS_DEVICE=1
    SKIP_BUILD_IOS_SIMULATOR=1
    SKIP_TEST_IOS_HOST=1
    SKIP_TEST_IOS_SIMULATOR=1
fi

if [[ "${SKIP_TVOS}" ]] ; then
    SKIP_BUILD_TVOS=1
    SKIP_BUILD_TVOS_DEVICE=1
    SKIP_BUILD_TVOS_SIMULATOR=1
    SKIP_TEST_TVOS_HOST=1
    SKIP_TEST_TVOS_SIMULATOR=1
fi

if [[ "${SKIP_WATCHOS}" ]] ; then
    SKIP_BUILD_WATCHOS=1
    SKIP_BUILD_WATCHOS_DEVICE=1
    SKIP_BUILD_WATCHOS_SIMULATOR=1
    SKIP_TEST_WATCHOS_HOST=1
    SKIP_TEST_WATCHOS_SIMULATOR=1
fi

if [[ "${SKIP_BUILD_IOS}" ]] ; then
    SKIP_BUILD_IOS=1
    SKIP_BUILD_IOS_DEVICE=1
    SKIP_BUILD_IOS_SIMULATOR=1
    SKIP_TEST_IOS_HOST=1
    SKIP_TEST_IOS_SIMULATOR=1
fi

if [[ "${SKIP_BUILD_TVOS}" ]] ; then
    SKIP_BUILD_TVOS=1
    SKIP_BUILD_TVOS_DEVICE=1
    SKIP_BUILD_TVOS_SIMULATOR=1
    SKIP_TEST_TVOS_HOST=1
    SKIP_TEST_TVOS_SIMULATOR=1
fi

if [[ "${SKIP_BUILD_WATCHOS}" ]] ; then
    SKIP_BUILD_WATCHOS=1
    SKIP_BUILD_WATCHOS_DEVICE=1
    SKIP_BUILD_WATCHOS_SIMULATOR=1
    SKIP_TEST_WATCHOS_HOST=1
    SKIP_TEST_WATCHOS_SIMULATOR=1
fi

if [[ "${SKIP_BUILD_IOS_DEVICE}" ]] ; then
    SKIP_BUILD_IOS_DEVICE=1
fi

if [[ "${SKIP_BUILD_TVOS_DEVICE}" ]] ; then
    SKIP_BUILD_TVOS_DEVICE=1
fi

if [[ "${SKIP_BUILD_WATCHOS_DEVICE}" ]] ; then
    SKIP_BUILD_WATCHOS_DEVICE=1
fi

if [[ "${SKIP_BUILD_IOS_SIMULATOR}" ]] ; then
    SKIP_BUILD_IOS_SIMULATOR=1
    SKIP_TEST_IOS_SIMULATOR=1
fi

if [[ "${SKIP_BUILD_TVOS_SIMULATOR}" ]] ; then
    SKIP_BUILD_TVOS_SIMULATOR=1
    SKIP_TEST_TVOS_SIMULATOR=1
fi

if [[ "${SKIP_BUILD_WATCHOS_SIMULATOR}" ]] ; then
    SKIP_BUILD_WATCHOS_SIMULATOR=1
    SKIP_TEST_WATCHOS_SIMULATOR=1
fi

# FIXME: We currently do not support cross-compiling swift with compiler-rt.
if [[ "${CROSS_COMPILE_TOOLS_DEPLOYMENT_TARGETS}" ]]; then
    SKIP_COMPILER_RT=1
fi

# WORKSPACE, BUILD_DIR and INSTALLABLE_PACKAGE must be absolute paths
case "${WORKSPACE}" in
    /*) ;;
    *)
        echo "workspace must be an absolute path (was '${WORKSPACE}')"
        exit 1
        ;;
esac
case "${BUILD_DIR}" in
    /*) ;;
    "")
        echo "the --build-dir option is required"
        usage
        exit 1
        ;;
    *)
        echo "build-dir must be an absolute path (was '${BUILD_DIR}')"
        exit 1
        ;;
esac
case "${INSTALLABLE_PACKAGE}" in
    /*) ;;
    "") ;;
    *)
        echo "installable-package must be an absolute path (was '${INSTALLABLE_PACKAGE}')"
        exit 1
        ;;
esac

# WORKSPACE must exist
if [ ! -e "${WORKSPACE}" ] ; then
    echo "Workspace does not exist (tried ${WORKSPACE})"
    exit 1
fi

# FIXME: HOST_CC and CMAKE are set, and their presence is validated by,
#        utils/build-script. These checks are redundant, but must remain until
#        build-script-impl is merged completely with utils/build-script.
#        For additional information, see: https://bugs.swift.org/browse/SR-237
if [ -z "${HOST_CC}" ] ; then
    echo "Can't find clang.  Please install clang-3.5 or a later version."
    exit 1
fi
if [ -z "${CMAKE}" ] ; then
    echo "Environment variable CMAKE must be specified."
    exit 1
fi

function xcrun_find_tool() {
  xcrun --sdk macosx --toolchain "${DARWIN_XCRUN_TOOLCHAIN}" --find "$@"
}

function not() {
    if [[ ! "$1" ]] ; then
        echo 1
    fi
}

function true_false() {
    case "$1" in
        false | FALSE | 0 | "")
            echo "FALSE"
            ;;
        true | TRUE | 1)
            echo "TRUE"
            ;;
        *)
            echo "true_false: unknown value: $1" >&2
            exit 1
            ;;
    esac
}

function false_true() {
    if [[ $(true_false "$1") = "TRUE" ]]; then
        echo "FALSE"
    else
        echo "TRUE"
    fi
}

function cmake_version() {
    echo $("${CMAKE}" --version | grep "cmake version" | cut -f 3 -d " ")
}

function cmake_needs_to_specify_standard_computed_defaults() {
    if [[ $(cmake_version) = "3.4.0" ]]; then
        echo "TRUE"
    else
        echo "FALSE"
    fi
}

function copy_swift_stdlib_tool_substitute() {
    if [ ! -f "$1" ] ; then
        echo "--- Copy swift-stdlib-tool ---"
        set -x
        cp "${SWIFT_SOURCE_DIR}/utils/swift-stdlib-tool-substitute" "$1"
        { set +x; } 2>/dev/null
    fi
}

function make_relative_symlink() {
    local SOURCE=$1
    local TARGET=$2
    local TARGET_DIR=$(dirname $2)
    local RELATIVE_SOURCE=$(python -c "import os.path; print(os.path.relpath(\""${SOURCE}"\", \""${TARGET_DIR}"\"))")
    ln -sf "${RELATIVE_SOURCE}" "${TARGET}"
}

# A list of deployment targets to cross-compile the Swift host tools for.
# We can't run the resulting binaries on the build machine.
CROSS_TOOLS_DEPLOYMENT_TARGETS=()

# Sanitize the list of cross-compilation targets.
for t in ${CROSS_COMPILE_TOOLS_DEPLOYMENT_TARGETS} ; do
    case ${t} in
        iphonesimulator-i386 | iphonesimulator-x86_64 | \
        iphoneos-arm64 | iphoneos-armv7 | iphoneos-armv7s | \
        appletvos-arm64 | appletvsimulator-x86_64 | \
        watchos-armv7k | watchsimulator-i386)
            CROSS_TOOLS_DEPLOYMENT_TARGETS=(
                "${CROSS_TOOLS_DEPLOYMENT_TARGETS[@]}"
                "${t}"
            )
            ;;
        *)
            echo "Unknown deployment target: ${t}"
            exit 1
            ;;
    esac
done

function is_cross_tools_deployment_target() {
    local deployment_target="$1"
    for t in "${CROSS_TOOLS_DEPLOYMENT_TARGETS[@]}" ; do
        if [ "${deployment_target}" == "${t}" ] ; then
            echo 1
        fi
    done
}

#
# Calculate source directories for each product.
#
NINJA_SOURCE_DIR="${WORKSPACE}/ninja"
SWIFT_SOURCE_DIR="${WORKSPACE}/swift"
LLVM_SOURCE_DIR="${WORKSPACE}/llvm"
CMARK_SOURCE_DIR="${WORKSPACE}/cmark"
LLDB_SOURCE_DIR="${WORKSPACE}/lldb"
LLBUILD_SOURCE_DIR="${WORKSPACE}/llbuild"
SWIFTPM_SOURCE_DIR="${WORKSPACE}/swiftpm"
XCTEST_SOURCE_DIR="${WORKSPACE}/swift-corelibs-xctest"
FOUNDATION_SOURCE_DIR="${WORKSPACE}/swift-corelibs-foundation"
LIBDISPATCH_SOURCE_DIR="${WORKSPACE}/swift-corelibs-libdispatch"

if [[ ! -d ${CMARK_SOURCE_DIR} ]]; then
    echo "Couldn't find cmark source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_LLBUILD}" && ! -d ${LLBUILD_SOURCE_DIR} ]]; then
    echo "Couldn't find llbuild source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_SWIFTPM}" && ! -d ${SWIFTPM_SOURCE_DIR} ]]; then
    echo "Couldn't find swiftpm source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_XCTEST}" && ! -d ${XCTEST_SOURCE_DIR} ]]; then
    echo "Couldn't find XCTest source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_FOUNDATION}" && ! -d ${FOUNDATION_SOURCE_DIR} ]]; then
    echo "Couldn't find Foundation source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_LIBDISPATCH}" && ! -d ${LIBDISPATCH_SOURCE_DIR} ]]; then
    echo "Couldn't find libdispatch source directory."
    exit 1
fi

# Symlink clang into the llvm tree.
CLANG_SOURCE_DIR="${LLVM_SOURCE_DIR}/tools/clang"
if [ ! -e "${WORKSPACE}/clang" ] ; then
    # If llvm/tools/clang is already a directory, use that and skip the symlink.
    if [ ! -d "${CLANG_SOURCE_DIR}" ] ; then
        echo "Can't find source directory for clang (tried ${WORKSPACE}/clang and ${CLANG_SOURCE_DIR})"
        exit 1
    fi
fi
if [ ! -d "${CLANG_SOURCE_DIR}" ] ; then
    make_relative_symlink "${WORKSPACE}/clang" "${CLANG_SOURCE_DIR}"
fi

# Symlink compiler-rt into the llvm tree, if it exists.
COMPILER_RT_SOURCE_DIR="${LLVM_SOURCE_DIR}/projects/compiler-rt"
if [ -e "${WORKSPACE}/compiler-rt" ] ; then
    if [ ! -d "${COMPILER_RT_SOURCE_DIR}" ] ; then
        make_relative_symlink "${WORKSPACE}/compiler-rt" "${COMPILER_RT_SOURCE_DIR}"
    fi
fi

PRODUCTS=(cmark llvm swift)
if [[ ! "${SKIP_BUILD_LLDB}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" lldb)
fi
if [[ ! "${SKIP_BUILD_LLBUILD}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" llbuild)
fi
if [[ ! "${SKIP_BUILD_SWIFTPM}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" swiftpm)
fi
if [[ ! "${SKIP_BUILD_LIBDISPATCH}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" libdispatch)
fi
# XCTest has a dependency on Foundation, so Foundation must be added to the
# list of build products first.
if [[ ! "${SKIP_BUILD_FOUNDATION}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" foundation)
fi
if [[ ! "${SKIP_BUILD_XCTEST}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" xctest)
fi

SWIFT_STDLIB_TARGETS=()
SWIFT_BENCHMARK_TARGETS=()
SWIFT_RUN_BENCHMARK_TARGETS=()
SWIFT_TEST_TARGETS=()
STDLIB_DEPLOYMENT_TARGETS=($STDLIB_DEPLOYMENT_TARGETS)
for deployment_target in "${STDLIB_DEPLOYMENT_TARGETS[@]}"; do
    build_for_this_target=1
    test_this_target=1
    test_host_only=
    build_benchmark_this_target=
    test_benchmark_this_target=
    case ${deployment_target} in
        linux-*)
            build_for_this_target=$(not ${SKIP_BUILD_LINUX})
            test_this_target=$(not ${SKIP_TEST_LINUX})
            ;;
        freebsd-*)
            build_for_this_target=$(not ${SKIP_BUILD_FREEBSD})
            test_this_target=$(not ${SKIP_TEST_FREEBSD})
            ;;
        cygwin-*)
            build_for_this_target=$(not ${SKIP_BUILD_CYGWIN})
            test_this_target=$(not ${SKIP_TEST_CYGWIN})
            ;;
        macosx-*)
            build_for_this_target=$(not ${SKIP_BUILD_OSX})
            test_this_target=$(not ${SKIP_TEST_OSX})
            build_benchmark_this_target=$(not ${SKIP_BUILD_OSX})
            test_benchmark_this_target=$(not ${SKIP_BUILD_OSX})
            ;;
        iphoneos-*)
            build_for_this_target=$(not ${SKIP_BUILD_IOS_DEVICE})
            if [[ ! "${SKIP_TEST_IOS_HOST}" ]] ; then
                test_host_only=1
            else
                test_this_target=
            fi
            build_benchmark_this_target=$(not ${SKIP_BUILD_IOS_DEVICE})
            ;;
        iphonesimulator-*)
            build_for_this_target=$(not ${SKIP_BUILD_IOS_SIMULATOR})
            test_this_target=$(not ${SKIP_TEST_IOS_SIMULATOR})
            ;;
        appletvos-*)
            build_for_this_target=$(not ${SKIP_BUILD_TVOS_DEVICE})
            if [[ ! "${SKIP_TEST_TVOS_HOST}" ]] ; then
                test_host_only=1
            else
                test_this_target=
            fi
            build_benchmark_this_target=$(not ${SKIP_BUILD_TVOS_DEVICE})
            ;;
        appletvsimulator-*)
            build_for_this_target=$(not ${SKIP_BUILD_TVOS_SIMULATOR})
            test_this_target=$(not ${SKIP_TEST_TVOS_SIMULATOR})
            ;;
        watchos-*)
            build_for_this_target=$(not ${SKIP_BUILD_WATCHOS_DEVICE})
            if [[ ! "${SKIP_TEST_WATCHOS_HOST}" ]] ; then
                test_host_only=1
            else
                test_this_target=
            fi
            build_benchmark_this_target=$(not ${SKIP_BUILD_WATCHOS_DEVICE})
            ;;
        watchsimulator-*)
            build_for_this_target=$(not ${SKIP_BUILD_WATCHOS_SIMULATOR})
            test_this_target=$(not ${SKIP_TEST_WATCHOS_SIMULATOR})
            ;;
        android-*)
            build_for_this_target=$(not ${SKIP_BUILD_ANDROID})
            # FIXME: Allow Android host tests to be enabled/disabled by the
            #        build script.
            test_this_target=
            ;;
        *)
            echo "Unknown compiler deployment target: ${deployment_target}"
            exit 1
            ;;
    esac
    if [[ "${build_for_this_target}" ]] ; then
        if [[ "${BUILD_SWIFT_STDLIB_UNITTEST_EXTRA}" == "1" ]] ; then
            SWIFT_STDLIB_TARGETS+=("swift-stdlib-${deployment_target}")
        else
            if [[ "${VALIDATION_TEST}" == "1" ]] ; then
                SWIFT_STDLIB_TARGETS+=("swift-stdlib-${deployment_target}")
            else
                SWIFT_STDLIB_TARGETS+=("swift-test-stdlib-${deployment_target}")
            fi
        fi
    fi
    if [[ "${build_benchmark_this_target}" ]] ; then
        SWIFT_BENCHMARK_TARGETS+=("swift-benchmark-${deployment_target}")
        if [[ $(not ${SKIP_TEST_BENCHMARK}) ]] ; then
          SWIFT_RUN_BENCHMARK_TARGETS+=("check-swift-benchmark-${deployment_target}")
        fi
    fi
    if [[ "${test_this_target}" ]] ; then
        test_target_suffix=""
        if [[ -n "${test_host_only}" ]] ; then
            test_target_suffix="-non-executable"
        fi

        test_subset_target_suffix=""
        if [[ "${VALIDATION_TEST}" == "1" ]] ; then
            if [[ "${LONG_TEST}" == "1" ]] ; then
                test_subset_target_suffix="-all"
            else
                test_subset_target_suffix="-validation"
            fi
        else
            if [[ "${LONG_TEST}" == "1" ]] ; then
                test_subset_target_suffix="-only_long"
            fi
        fi
        SWIFT_TEST_TARGETS+=("check-swift${test_subset_target_suffix}${test_target_suffix}-${deployment_target}")
        if [[ $(not ${SKIP_TEST_OPTIMIZED}) && ! -n "${test_host_only}" ]] ; then
            SWIFT_TEST_TARGETS+=("check-swift${test_subset_target_suffix}-optimize-${deployment_target}")
        fi
    fi
done

echo "Building the standard library for: ${SWIFT_STDLIB_TARGETS[@]}"
if [[ "${SWIFT_TEST_TARGETS[@]}" ]] && ! [[ "${SKIP_TEST_SWIFT}" ]]; then
    echo "Running Swift tests for: ${SWIFT_TEST_TARGETS[@]}"
fi
if ! [[ "${SKIP_TEST_BENCHMARKS}" ]] &&
   [[ "${SWIFT_RUN_BENCHMARK_TARGETS[@]}" ]] &&
   ! [[ "${SKIP_TEST_BENCHMARK}" ]]; then
    echo "Running Swift benchmarks for: ${SWIFT_RUN_BENCHMARK_TARGETS[@]}"
fi
echo

# CMake options used for all targets, including LLVM/Clang
COMMON_CMAKE_OPTIONS=(
    -G "${CMAKE_GENERATOR}"
)

COMMON_C_FLAGS=""
SANITIZERS=()
if [[ "${ENABLE_ASAN}" ]] ; then
    SANITIZERS=(
        "${SANITIZERS[@]}"
        "Address"
    )
fi

if [[ "${ENABLE_UBSAN}" ]] ; then
    SANITIZERS=(
        "${SANITIZERS[@]}"
        "Undefined"
    )
fi

if [[ -n "${SANITIZERS[@]}" ]] ; then
    COMMON_CMAKE_OPTIONS=(
        "${COMMON_CMAKE_OPTIONS[@]}"
        -DLLVM_USE_SANITIZER=$(join_array_with_delimiter ";" "${SANITIZERS[@]}")
    )
fi

if [[ "${EXPORT_COMPILE_COMMANDS}" ]] ; then
    COMMON_CMAKE_OPTIONS=(
        "${COMMON_CMAKE_OPTIONS[@]}"
        -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
    )
fi

if [[ "${EXTRA_CMAKE_OPTIONS}" ]] ; then
    for cmake_opt in $(echo "${EXTRA_CMAKE_OPTIONS}" | tr "," "\n")
    do
        COMMON_CMAKE_OPTIONS=(
            "${COMMON_CMAKE_OPTIONS[@]}"
            "${cmake_opt}"
        )
    done
fi

if [[ "${DISTCC}" ]] ; then
    # On some platforms, 'pump' may be unrelated to distcc, in which case it's
    # called 'distcc-pump'.
    DISTCC_PUMP="$(which distcc-pump || which pump)"
    COMMON_CMAKE_OPTIONS=(
        "${COMMON_CMAKE_OPTIONS[@]}"
        -DCMAKE_C_COMPILER:PATH="$(which distcc)"
        -DCMAKE_C_COMPILER_ARG1="${HOST_CC}"
        -DCMAKE_CXX_COMPILER:PATH="$(which distcc)"
        -DCMAKE_CXX_COMPILER_ARG1="${HOST_CXX}"
    )
else
    COMMON_CMAKE_OPTIONS=(
        "${COMMON_CMAKE_OPTIONS[@]}"
        -DCMAKE_C_COMPILER:PATH="${HOST_CC}"
        -DCMAKE_CXX_COMPILER:PATH="${HOST_CXX}"
    )
fi


CMAKE_JOBS="${BUILD_JOBS}"
if [[ "${DISTCC}" ]] ; then
    CMAKE_JOBS="$(distcc -j)"
fi

case "${CMAKE_GENERATOR}" in
    Ninja)
        BUILD_ARGS="${BUILD_ARGS} -j${CMAKE_JOBS}"
        if [[ "${VERBOSE_BUILD}" ]] ; then
            BUILD_ARGS="${BUILD_ARGS} -v"
        fi
        ;;
    'Unix Makefiles')
        BUILD_ARGS="${BUILD_ARGS} -j${CMAKE_JOBS}"
        if [[ "${VERBOSE_BUILD}" ]] ; then
            BUILD_ARGS="${BUILD_ARGS} VERBOSE=1"
        fi
        ;;
    Xcode)
        # -parallelizeTargets is an unsupported flag from the Xcode 3 days,
        # but since we're not using proper Xcode 4 schemes, this is the
        # only way to get target-level parallelism.
        BUILD_ARGS="${BUILD_ARGS} -parallelizeTargets"
        BUILD_ARGS="${BUILD_ARGS} -jobs ${CMAKE_JOBS}"
        BUILD_TARGET_FLAG="-target"
        COMMON_CMAKE_OPTIONS=(
            "${COMMON_CMAKE_OPTIONS[@]}"
            -DCMAKE_CONFIGURATION_TYPES="Debug;Release;MinSizeRel;RelWithDebInfo"
        )

        # FIXME: We currently do not support building compiler-rt with the
        # Xcode generator.
        SKIP_COMPILER_RT=1
        ;;
esac

if [[ "${CLANG_COMPILER_VERSION}" ]] ; then
    major_version=$(echo "${CLANG_COMPILER_VERSION}" | sed -e 's/\([0-9]*\).*/\1/')
    minor_version=$(echo "${CLANG_COMPILER_VERSION}" | sed -e 's/[^.]*\.\([0-9]*\).*/\1/')
    patch_version=$(echo "${CLANG_COMPILER_VERSION}" | sed -e 's/[^.]*\.[^.]*\.\([0-9]*\)/\1/')
    COMMON_CMAKE_OPTIONS=(
        "${COMMON_CMAKE_OPTIONS[@]}"
        -DLLVM_VERSION_MAJOR:STRING="${major_version}"
        -DLLVM_VERSION_MINOR:STRING="${minor_version}"
        -DLLVM_VERSION_PATCH:STRING="${patch_version}"
    )
fi

function build_directory() {
    deployment_target=$1
    product=$2
    echo "${BUILD_DIR}/${product}-${deployment_target}"
}

function build_directory_bin() {
    deployment_target=$1
    product=$2
    root="$(build_directory ${deployment_target} ${product})"
    if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
        case ${product} in
            cmark)
                echo "${root}/${CMARK_BUILD_TYPE}/bin"
                ;;
            llvm)
                echo "${root}/${LLVM_BUILD_TYPE}/bin"
                ;;
            swift)
                echo "${root}/${SWIFT_BUILD_TYPE}/bin"
                ;;
            lldb)
                ;;
            llbuild)
                echo "${root}/${LLBUILD_BUILD_TYPE}/bin"
                ;;
            swiftpm)
                echo "${root}/${SWIFTPM_BUILD_TYPE}/bin"
                ;;
            xctest)
                echo "${root}/${XCTEST_BUILD_TYPE}/bin"
                ;;
            foundation)
                echo "${root}/${FOUNDATION_BUILD_TYPE}/bin"
                ;;
            libdispatch)
                echo "${root}/bin"
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac
    else
        echo "${root}/bin"
    fi
}

function is_cmake_release_build_type() {
    if [[ "$1" == "Release" || "$1" == "RelWithDebInfo" ]] ; then
        echo 1
    fi
}

function common_cross_c_flags() {
    echo -n "${COMMON_C_FLAGS}"

    case $1 in
        iphonesimulator-i386)
            echo "-arch i386 -mios-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphonesimulator-x86_64)
            echo "-arch x86_64 -mios-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphoneos-armv7)
            echo "-arch armv7 -miphoneos-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphoneos-armv7s)
            echo "-arch armv7s -miphoneos-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphoneos-arm64)
            echo "-arch arm64 -miphoneos-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        appletvsimulator-x86_64)
            echo "-arch x86_64 -mtvos-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_TVOS}"
            ;;
        appletvos-arm64)
            echo "-arch arm64 -mtvos-version-min=${DARWIN_DEPLOYMENT_VERSION_TVOS}"
            ;;
        watchsimulator-i386)
            echo "-arch i386 -mwatchos-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
            ;;
        watchos-armv7k)
            echo "-arch armv7k -mwatchos-version-min=${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
            ;;
        android-armv7)
            echo "-arch armv7"
            ;;
    esac
}

function llvm_c_flags() {
    echo -n " $(common_cross_c_flags $1)"
    if [[ $(is_cmake_release_build_type "${LLVM_BUILD_TYPE}") ]] ; then
        echo -n " -fno-stack-protector"
    fi
}

function cmark_c_flags() {
    echo -n " $(common_cross_c_flags $1)"
    if [[ $(is_cmake_release_build_type "${CMARK_BUILD_TYPE}") ]] ; then
        echo -n " -fno-stack-protector"
    fi
}

function swift_c_flags() {
    # Don't pass common_cross_c_flags to Swift because CMake code in the Swift
    # project is itself aware of cross-compilation for the host tools and
    # standard library.
    echo -n "${COMMON_C_FLAGS}"
    if [[ $(is_cmake_release_build_type "${SWIFT_BUILD_TYPE}") ]] ; then
        echo -n " -fno-stack-protector"
    fi
}

function cmake_config_opt() {
    product=$1
    if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
        # CMake automatically adds --target ALL_BUILD if we don't pass this.
        echo "--target ZERO_CHECK "
        case ${product} in
            cmark)
                echo "--config ${CMARK_BUILD_TYPE}"
                ;;
            llvm)
                echo "--config ${LLVM_BUILD_TYPE}"
                ;;
            swift)
                echo "--config ${SWIFT_BUILD_TYPE}"
                ;;
            lldb)
                ;;
            llbuild)
                echo "--config ${LLBUILD_BUILD_TYPE}"
                ;;
            swiftpm)
                echo "--config ${SWIFTPM_BUILD_TYPE}"
                ;;
            xctest)
                echo "--config ${XCTEST_BUILD_TYPE}"
                ;;
            foundation)
                echo "--config ${FOUNDATION_BUILD_TYPE}"
                ;;            
            libdispatch)
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac
    fi
}

function set_swiftpm_bootstrap_command() {
    SWIFTC_BIN="$(build_directory_bin ${deployment_target} swift)/swiftc"
    LLBUILD_BIN="$(build_directory_bin ${deployment_target} llbuild)/swift-build-tool"
    if [[ ! "${SKIP_BUILD_FOUNDATION}" && ! "${SKIP_BUILD_XCTEST}" ]] ; then
        FOUNDATION_BUILD_DIR=$(build_directory ${deployment_target} foundation)
        XCTEST_BUILD_DIR=$(build_directory ${deployment_target} xctest)
    fi
    if [ ! -e "${LLBUILD_BIN}" ]; then
        echo "Error: Cannot build swiftpm without llbuild (swift-build-tool)."
        exit 1
    fi
    swiftpm_bootstrap_command=("${SWIFTPM_SOURCE_DIR}/Utilities/bootstrap" "${swiftpm_bootstrap_options[@]}")
    if [[ "${VERBOSE_BUILD}" ]] ; then
        swiftpm_bootstrap_command+=(-v)
    fi
    swiftpm_bootstrap_command+=(
        --swiftc="${SWIFTC_BIN}"
        --sbt="${LLBUILD_BIN}"
        --build="${build_dir}")
    if [[ ! "${SKIP_BUILD_FOUNDATION}" && ! "${SKIP_BUILD_XCTEST}" ]] ; then
        swiftpm_bootstrap_command+=(
            --foundation="${FOUNDATION_BUILD_DIR}/Foundation"
            --xctest="${XCTEST_BUILD_DIR}")
    fi
}

mkdir -p "${BUILD_DIR}"

#
# Build Ninja
#
if [[ "${BUILD_NINJA}" ]] ; then
    build_dir=$(build_directory build ninja)
    if [ ! -f "${build_dir}/ninja" ] ; then
        if [ ! -d "${NINJA_SOURCE_DIR}" ] ; then
          echo "Can't find source directory for ninja (tried ${NINJA_SOURCE_DIR})"
          exit 1
        fi

        # Ninja can only be built in-tree.  Copy the source tree to the build
        # directory.
        set -x
        rm -rf "${build_dir}"
        cp -r "${NINJA_SOURCE_DIR}" "${build_dir}"
        if [[ $(uname -s) == "Darwin" ]]; then
          (cd "${build_dir}" && \
            env CXX=$(xcrun --sdk macosx -find clang++) \
                CFLAGS="-isysroot $(xcrun --sdk macosx --show-sdk-path) -mmacosx-version-min=${DARWIN_DEPLOYMENT_VERSION_OSX}" \
                LDFLAGS="-mmacosx-version-min=${DARWIN_DEPLOYMENT_VERSION_OSX}" \
                python ./configure.py --bootstrap)
          { set +x; } 2>/dev/null
        else
          (cd "${build_dir}" && python ./configure.py --bootstrap)
          { set +x; } 2>/dev/null
        fi
    fi
    NINJA_BIN="${build_dir}/ninja"
    COMMON_CMAKE_OPTIONS=(
        "${COMMON_CMAKE_OPTIONS[@]}"
        -DCMAKE_MAKE_PROGRAM=${NINJA_BIN}
    )
fi

#
# Configure and build each product
#
# Start with native deployment targets because the resulting tools are used during cross-compilation.
for deployment_target in "${HOST_TARGET}" "${CROSS_TOOLS_DEPLOYMENT_TARGETS[@]}"; do
    set_deployment_target_based_options

    case "${COMPILER_VENDOR}" in
        none)
            ;;
        apple)
            llvm_cmake_options=(
                "${llvm_cmake_options[@]}"
                -DCLANG_VENDOR=Apple
                -DCLANG_VENDOR_UTI=com.apple.compilers.llvm.clang
                -DPACKAGE_VERSION="${CLANG_USER_VISIBLE_VERSION}"
            )
            swift_cmake_options=(
                "${swift_cmake_options[@]}"
                -DSWIFT_VENDOR=Apple
                -DSWIFT_VENDOR_UTI=com.apple.compilers.llvm.swift
                -DSWIFT_VERSION="${SWIFT_USER_VISIBLE_VERSION}"
                -DSWIFT_COMPILER_VERSION="${SWIFT_COMPILER_VERSION}"
            )
            ;;
        *)
            echo "unknown compiler vendor"
            exit 1
            ;;
    esac

    llvm_cmake_options=(
        "${llvm_cmake_options[@]}"
        -DCMAKE_INSTALL_PREFIX:PATH="${INSTALL_PREFIX}"
        -DINTERNAL_INSTALL_PREFIX="local"
    )

    if [[ "${CLANG_COMPILER_VERSION}" ]] ; then
        llvm_cmake_options=(
            "${llvm_cmake_options[@]}"
            -DCLANG_REPOSITORY_STRING="clang-${CLANG_COMPILER_VERSION}"
        )
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DCLANG_COMPILER_VERSION="${CLANG_COMPILER_VERSION}"
            -DSWIFT_COMPILER_VERSION="${SWIFT_COMPILER_VERSION}"
        )
    fi
    if [[ "${SWIFT_COMPILER_VERSION}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_COMPILER_VERSION="${SWIFT_COMPILER_VERSION}"
        )
    fi
    if [[ "${DARWIN_TOOLCHAIN_VERSION}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DDARWIN_TOOLCHAIN_VERSION="${DARWIN_TOOLCHAIN_VERSION}"
        )
    fi

    if [[ "${ENABLE_ASAN}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_SOURCEKIT_USE_INPROC_LIBRARY:BOOL=TRUE
        )
    fi

    if [[ "${DARWIN_CRASH_REPORTER_CLIENT}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_RUNTIME_CRASH_REPORTER_CLIENT:BOOL=TRUE
        )
    fi

    swift_cmake_options=(
        "${swift_cmake_options[@]}"
        -DSWIFT_DARWIN_XCRUN_TOOLCHAIN:STRING="${DARWIN_XCRUN_TOOLCHAIN}"
    )

    if [[ "${DARWIN_STDLIB_INSTALL_NAME_DIR}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_DARWIN_STDLIB_INSTALL_NAME_DIR:STRING="${DARWIN_STDLIB_INSTALL_NAME_DIR}"
        )
    fi

    if [[ "${EXTRA_SWIFT_ARGS}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_EXPERIMENTAL_EXTRA_REGEXP_FLAGS="${EXTRA_SWIFT_ARGS}"
        )
    fi

    swift_cmake_options=(
        "${swift_cmake_options[@]}"
        -DSWIFT_AST_VERIFIER:BOOL=$(true_false "${SWIFT_ENABLE_AST_VERIFIER}")
        -DSWIFT_SIL_VERIFY_ALL:BOOL=$(true_false "${SIL_VERIFY_ALL}")
        -DSWIFT_RUNTIME_ENABLE_LEAK_CHECKER:BOOL=$(true_false "${SWIFT_RUNTIME_ENABLE_LEAK_CHECKER}")
    )

    for product in "${PRODUCTS[@]}"; do
        unset skip_build
        build_dir=$(build_directory ${deployment_target} ${product})
        build_targets=(all)
        cmake_options=("${COMMON_CMAKE_OPTIONS[@]}")

        # Add in gold linker support if requested.
        if [[ "${USE_GOLD_LINKER}" ]]; then
            echo "${product}: using gold linker"
            if [[ "${product}" != "swift" ]]; then
                # All other projects override the linker flags to add in
                # gold linker support.
                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_EXE_LINKER_FLAGS:STRING="-fuse-ld=gold"
                    -DCMAKE_SHARED_LINKER_FLAGS:STRING="-fuse-ld=gold"
                )
            fi
        else
            echo "${product}: using standard linker"
        fi

        PRODUCT=$(toupper ${product})
        llvm_build_dir=$(build_directory ${deployment_target} llvm)
        module_cache="${build_dir}/module-cache"
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DCMAKE_INSTALL_PREFIX:PATH="${INSTALL_PREFIX}"
            -DLLVM_CONFIG:PATH="$(build_directory_bin ${deployment_target} llvm)/llvm-config"
            -D${PRODUCT}_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
            -D${PRODUCT}_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
            -D${PRODUCT}_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
            -D${PRODUCT}_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
            -D${PRODUCT}_PATH_TO_CMARK_SOURCE:PATH="${CMARK_SOURCE_DIR}"
            -D${PRODUCT}_PATH_TO_CMARK_BUILD:PATH="$(build_directory ${deployment_target} cmark)"
        )

        if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
            swift_cmake_options=(
                "${swift_cmake_options[@]-}"
                -D${PRODUCT}_CMARK_LIBRARY_DIR:PATH=$(build_directory ${deployment_target} cmark)/src/${CMARK_BUILD_TYPE}
            )
        else
            swift_cmake_options=(
                "${swift_cmake_options[@]-}"
                -D${PRODUCT}_CMARK_LIBRARY_DIR:PATH=$(build_directory ${deployment_target} cmark)/src
            )
        fi

        case ${product} in
            cmark)
                cmake_options=(
                  "${cmake_options[@]}"
                  -DCMAKE_BUILD_TYPE:STRING="${LLVM_BUILD_TYPE}"
                  "${cmark_cmake_options[@]}"
                  "${CMARK_SOURCE_DIR}"
                )
                skip_build=${SKIP_BUILD_CMARK}
                build_targets=(all)

                ;;

            llvm)
                if [ "${BUILD_LLVM}" == "0" ] ; then
                    build_targets=(clean)
                fi
                if [ "${SKIP_BUILD_LLVM}" ] ; then
                    # We can't skip the build completely because the standalone
                    # build of Swift depend on these.
                    build_targets=(llvm-config llvm-tblgen clang-headers)
                fi

                # Note: we set the variable:
                #
                # LLVM_TOOL_SWIFT_BUILD
                #
                # below because this script builds swift separately, and people
                # often have reasons to symlink the swift directory into
                # llvm/tools, e.g. to build LLDB.
                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_C_FLAGS="$(llvm_c_flags ${deployment_target})"
                    -DCMAKE_CXX_FLAGS="$(llvm_c_flags ${deployment_target})"
                    -DCMAKE_BUILD_TYPE:STRING="${LLVM_BUILD_TYPE}"
                    -DLLVM_ENABLE_ASSERTIONS:BOOL=$(true_false "${LLVM_ENABLE_ASSERTIONS}")
                    -DLLVM_TOOL_SWIFT_BUILD:BOOL=NO
                    -DLLVM_TARGETS_TO_BUILD="${LLVM_TARGETS_TO_BUILD}"
                    -DLLVM_INCLUDE_TESTS:BOOL=$(true_false "${SOURCE_TREE_INCLUDES_TESTS}")
                    -LLVM_INCLUDE_DOCS:BOOL=TRUE
                    "${llvm_cmake_options[@]}"
                    "${LLVM_SOURCE_DIR}"
                )
                if [[ $(is_cross_tools_deployment_target ${deployment_target}) ]] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DLLVM_TABLEGEN=$(build_directory "${HOST_TARGET}" llvm)/bin/llvm-tblgen
                        -DCLANG_TABLEGEN=$(build_directory "${HOST_TARGET}" llvm)/bin/clang-tblgen
                    )
                fi

                ;;

            swift)
                cmake_options=("${COMMON_CMAKE_OPTIONS[@]}")
                if [[ "${USE_GOLD_LINKER}" ]]; then
                    # Swift will selectively use the gold linker on all
                    # parts except building the standard library.  We
                    # let the Swift cmake setup figure out how to apply
                    # that.
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_ENABLE_GOLD_LINKER=TRUE
                    )
                fi

                if [[ ! "${SKIP_BUILD_ANDROID}" ]]; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_ANDROID_NDK_PATH:STRING="${ANDROID_NDK}"
                        -DSWIFT_ANDROID_NDK_TOOLCHAIN_VERSION:STRING="${ANDROID_NDK_TOOLCHAIN_VERSION}"
                        -DSWIFT_ANDROID_SDK_PATH:STRING="${ANDROID_NDK}/platforms/android-${ANDROID_NDK_VERSION}/arch-arm"
                        -DSWIFT_ANDROID_ICU_UC:STRING="${ANDROID_ICU_UC}"
                        -DSWIFT_ANDROID_ICU_UC_INCLUDE:STRING="${ANDROID_ICU_UC_INCLUDE}"
                        -DSWIFT_ANDROID_ICU_I18N:STRING="${ANDROID_ICU_I18N}"
                        -DSWIFT_ANDROID_ICU_I18N_INCLUDE:STRING="${ANDROID_ICU_I18N_INCLUDE}"
                    )
                fi

                native_llvm_tools_path=""
                native_clang_tools_path=""
                native_swift_tools_path=""
                if [[ $(is_cross_tools_deployment_target ${deployment_target}) ]] ; then
                    # Don't build benchmarks and tests when building cross compiler.
                    build_perf_testsuite_this_time=false
                    build_tests_this_time=false

                    native_llvm_tools_path="$(build_directory "${HOST_TARGET}" llvm)/bin"
                    native_clang_tools_path="$(build_directory "${HOST_TARGET}" llvm)/bin"
                    native_swift_tools_path="$(build_directory "${HOST_TARGET}" swift)/bin"

                    cmake_options=(
                        "${cmake_options[@]}"
                        -DLLVM_TOOLS_BINARY_DIR:PATH=$(build_directory ${deployment_target} llvm)/bin
                        -DLLVM_LIBRARY_DIR:PATH=$(build_directory ${deployment_target} llvm)/lib
                        -DLLVM_MAIN_INCLUDE_DIR:PATH=$(build_directory ${deployment_target} llvm)/include
                        -DLLVM_BINARY_DIR:PATH=$(build_directory ${deployment_target} llvm)
                        -DLLVM_MAIN_SRC_DIR:PATH="${LLVM_SOURCE_DIR}"
                    )
                else
                    build_perf_testsuite_this_time=$(true_false "$(not ${SKIP_BUILD_BENCHMARKS})")
                    build_tests_this_time=${SOURCE_TREE_INCLUDES_TESTS}
                fi

                # Command-line parameters override any autodetection that we
                # might have done.
                if [[ "${NATIVE_LLVM_TOOLS_PATH}" ]] ; then
                    native_llvm_tools_path="${NATIVE_LLVM_TOOLS_PATH}"
                fi
                if [[ "${NATIVE_CLANG_TOOLS_PATH}" ]] ; then
                    native_clang_tools_path="${NATIVE_CLANG_TOOLS_PATH}"
                fi
                if [[ "${NATIVE_SWIFT_TOOLS_PATH}" ]] ; then
                    native_swift_tools_path="${NATIVE_SWIFT_TOOLS_PATH}"
                fi

                if [ "${BUILD_LLVM}" == "0" ] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DLLVM_TOOLS_BINARY_DIR:PATH=/tmp/dummy
                        -DLLVM_LIBRARY_DIR:PATH="${build_dir}"
                        -DLLVM_MAIN_INCLUDE_DIR:PATH=/tmp/dummy
                        -DLLVM_BINARY_DIR:PATH=$(build_directory ${deployment_target} llvm)
                        -DLLVM_MAIN_SRC_DIR:PATH="${LLVM_SOURCE_DIR}"
                    )
                fi

                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_C_FLAGS="$(swift_c_flags ${deployment_target})"
                    -DCMAKE_CXX_FLAGS="$(swift_c_flags ${deployment_target})"
                    -DCMAKE_BUILD_TYPE:STRING="${SWIFT_BUILD_TYPE}"
                    -DLLVM_ENABLE_ASSERTIONS:BOOL=$(true_false "${SWIFT_ENABLE_ASSERTIONS}")
                    -DSWIFT_ANALYZE_CODE_COVERAGE:STRING=$(toupper "${SWIFT_ANALYZE_CODE_COVERAGE}")
                    -DSWIFT_STDLIB_BUILD_TYPE:STRING="${SWIFT_STDLIB_BUILD_TYPE}"
                    -DSWIFT_STDLIB_ASSERTIONS:BOOL=$(true_false "${SWIFT_STDLIB_ENABLE_ASSERTIONS}")
                    -DSWIFT_STDLIB_ENABLE_REFLECTION_METADATA:BOOL=$(true_false "${SWIFT_STDLIB_ENABLE_REFLECTION_METADATA}")
                    -DSWIFT_STDLIB_ENABLE_RESILIENCE:BOOL=$(true_false "${SWIFT_STDLIB_ENABLE_RESILIENCE}")
                    -DSWIFT_STDLIB_SIL_SERIALIZE_ALL:BOOL=$(true_false "${SWIFT_STDLIB_SIL_SERIALIZE_ALL}")
                    -DSWIFT_NATIVE_LLVM_TOOLS_PATH:STRING="${native_llvm_tools_path}"
                    -DSWIFT_NATIVE_CLANG_TOOLS_PATH:STRING="${native_clang_tools_path}"
                    -DSWIFT_NATIVE_SWIFT_TOOLS_PATH:STRING="${native_swift_tools_path}"
                    -DSWIFT_BUILD_TOOLS:BOOL=$(true_false "${BUILD_SWIFT_TOOLS}")
                    -DSWIFT_BUILD_STDLIB:BOOL=$(true_false "${BUILD_SWIFT_STDLIB}")
                    -DSWIFT_SERIALIZE_STDLIB_UNITTEST:BOOL=$(true_false "${BUILD_SERIALIZED_STDLIB_UNITTEST}")
                    -DSWIFT_STDLIB_SIL_DEBUGGING:BOOL=$(true_false "${BUILD_SIL_DEBUGGING_STDLIB}")
                    -DSWIFT_BUILD_SDK_OVERLAY:BOOL=$(true_false "${BUILD_SWIFT_SDK_OVERLAY}")
                    -DSWIFT_BUILD_STATIC_STDLIB:BOOL=$(true_false "${BUILD_SWIFT_STATIC_STDLIB}")
                    -DSWIFT_BUILD_PERF_TESTSUITE:BOOL=$(true_false "${build_perf_testsuite_this_time}")
                    -DSWIFT_BUILD_EXAMPLES:BOOL=$(true_false "${BUILD_SWIFT_EXAMPLES}")
                    -DSWIFT_INCLUDE_TESTS:BOOL=$(true_false "${build_tests_this_time}")
                    -DSWIFT_INSTALL_COMPONENTS:STRING="${SWIFT_INSTALL_COMPONENTS}"
                    -DSWIFT_EMBED_BITCODE_SECTION:BOOL=$(true_false "${EMBED_BITCODE_SECTION}")
                    -DSWIFT_ENABLE_LTO:BOOL=$(true_false "${SWIFT_ENABLE_LTO}")
                    -DSWIFT_BUILD_RUNTIME_WITH_HOST_COMPILER:BOOL=$(true_false "${BUILD_RUNTIME_WITH_HOST_COMPILER}")
                    "${swift_cmake_options[@]}"
                    "${SWIFT_SOURCE_DIR}"
                )
                if [[ "${SWIFT_SDKS}" ]] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_SDKS:STRING="${SWIFT_SDKS}"
                    )
                fi
                if [[ "${SWIFT_PRIMARY_VARIANT_SDK}" ]] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_PRIMARY_VARIANT_SDK:STRING="${SWIFT_PRIMARY_VARIANT_SDK}"
                        -DSWIFT_PRIMARY_VARIANT_ARCH:STRING="${SWIFT_PRIMARY_VARIANT_ARCH}"
                    )
                fi

                build_targets=(all "${SWIFT_STDLIB_TARGETS[@]}")
                if [[ $(true_false "${build_perf_testsuite_this_time}") == "TRUE" ]]; then
                    native_swift_tools_path="$(build_directory_bin macosx-x86_64 swift)"
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_EXEC:STRING="${native_swift_tools_path}/swiftc"
                    )
                    build_targets=("${build_targets[@]}"
                                   "${SWIFT_BENCHMARK_TARGETS[@]}")
                fi
                skip_build=${SKIP_BUILD_SWIFT}
                ;;
            lldb)
                if [ ! -d "${LLDB_SOURCE_DIR}" ]; then
                    echo "error: lldb not found in ${LLDB_SOURCE_DIR}"
                    exit 1
                fi
                if [[ "${CMAKE_GENERATOR}" != "Ninja" ]] ; then
                    echo "error: lldb can only build with ninja"
                    exit 1
                fi
                cmark_build_dir=$(build_directory ${deployment_target} cmark)
                lldb_build_dir=$(build_directory ${deployment_target} lldb)
                swift_build_dir=$(build_directory ${deployment_target} swift)

                # Add any lldb extra cmake arguments here.
                if [ ! -z "${LLDB_EXTRA_CMAKE_ARGS}" ]; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        ${LLDB_EXTRA_CMAKE_ARGS}
                        )
                fi

                # Figure out if we think this is a buildbot build.
                # This will influence the lldb version line.
                if [ ! -z "${JENKINS_HOME}" -a ! -z "${JOB_NAME}" -a ! -z "${BUILD_NUMBER}" ]; then
                    LLDB_IS_BUILDBOT_BUILD=1
                else
                    LLDB_IS_BUILDBOT_BUILD=0
                fi

                # Get the build date
                LLDB_BUILD_DATE=$(date +%Y-%m-%d)

                case "$(uname -s)" in
                    Linux)
                        cmake_options=(
                            "${cmake_options[@]}"
                            -DCMAKE_BUILD_TYPE:STRING="${LLDB_BUILD_TYPE}"
                            -DCMAKE_INSTALL_PREFIX:PATH="${INSTALL_PREFIX}"
                            -DLLDB_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
                            -DLLDB_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
                            -DLLDB_PATH_TO_SWIFT_SOURCE:PATH="${SWIFT_SOURCE_DIR}"
                            -DLLDB_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_SWIFT_BUILD:PATH="${swift_build_dir}"
                            -DLLDB_PATH_TO_CMARK_BUILD:PATH="${cmark_build_dir}"
                            -DLLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            -DLLDB_BUILD_DATE:STRING="\"${LLDB_BUILD_DATE}\""
                            -DLLDB_ALLOW_STATIC_BINDINGS=1
                            "${LLDB_SOURCE_DIR}"
                        )
                        ;;
                    FreeBSD)
                        cmake_options=(
                            "${cmake_options[@]}"
                            -DCMAKE_BUILD_TYPE:STRING="${LLDB_BUILD_TYPE}"
                            -DCMAKE_INSTALL_PREFIX:PATH="${INSTALL_PREFIX}"
                            -DLLDB_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
                            -DLLDB_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
                            -DLLDB_PATH_TO_SWIFT_SOURCE:PATH="${SWIFT_SOURCE_DIR}"
                            -DLLDB_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_SWIFT_BUILD:PATH="${swift_build_dir}"
                            -DLLDB_PATH_TO_CMARK_BUILD:PATH="${cmark_build_dir}"
                            -DLLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            -DLLDB_BUILD_DATE:STRING="\"${LLDB_BUILD_DATE}\""
                            -DLLDB_ALLOW_STATIC_BINDINGS=1
                            "${LLDB_SOURCE_DIR}"
                        )
                        ;;
                    CYGWIN_NT-10.0)
                        cmake_options=(
                            "${cmake_options[@]}"
                            -DCMAKE_BUILD_TYPE:STRING="${LLDB_BUILD_TYPE}"
                            -DCMAKE_INSTALL_PREFIX:PATH="${INSTALL_PREFIX}"
                            -DLLDB_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
                            -DLLDB_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
                            -DLLDB_PATH_TO_SWIFT_SOURCE:PATH="${SWIFT_SOURCE_DIR}"
                            -DLLDB_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_SWIFT_BUILD:PATH="${swift_build_dir}"
                            -DLLDB_PATH_TO_CMARK_BUILD:PATH="${cmark_build_dir}"
                            -DLLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            -DLLDB_BUILD_DATE:STRING="\"${LLDB_BUILD_DATE}\""
                            -DLLDB_ALLOW_STATIC_BINDINGS=1
                            "${LLDB_SOURCE_DIR}"
                        )
                        ;;
                    Darwin)
                        # Set up flags to pass to xcodebuild
                        lldb_xcodebuild_options=(
                            LLDB_PATH_TO_LLVM_SOURCE="${LLVM_SOURCE_DIR}"
                            LLDB_PATH_TO_CLANG_SOURCE="${CLANG_SOURCE_DIR}"
                            LLDB_PATH_TO_SWIFT_SOURCE="${SWIFT_SOURCE_DIR}"
                            LLDB_PATH_TO_LLVM_BUILD="${llvm_build_dir}"
                            LLDB_PATH_TO_CLANG_BUILD="${llvm_build_dir}"
                            LLDB_PATH_TO_SWIFT_BUILD="${swift_build_dir}"
                            LLDB_PATH_TO_CMARK_BUILD="${cmark_build_dir}"
                            LLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            LLDB_BUILD_DATE="\"${LLDB_BUILD_DATE}\""
                            SYMROOT="${lldb_build_dir}"
                            OBJROOT="${lldb_build_dir}"
                            ${LLDB_EXTRA_XCODEBUILD_ARGS}
                        )
                        if [[ "${LLDB_NO_DEBUGSERVER}" ]] ; then
                            lldb_xcodebuild_options=(
                                "${lldb_xcodebuild_options[@]}"
                                DEBUGSERVER_DISABLE_CODESIGN="1"
                                DEBUGSERVER_DELETE_AFTER_BUILD="1"
                            )
                        fi
                        if [[ "${LLDB_USE_SYSTEM_DEBUGSERVER}" ]] ; then
                            lldb_xcodebuild_options=(
                                "${lldb_xcodebuild_options[@]}"
                                DEBUGSERVER_USE_FROM_SYSTEM="1"
                            )
                        fi
                        set_lldb_build_mode
                        pushd ${LLDB_SOURCE_DIR}
                        xcodebuild -target desktop -configuration ${LLDB_BUILD_MODE} ${lldb_xcodebuild_options[@]}
                        popd
                        continue
                        ;;
                esac
                ;;
            llbuild)
                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_INSTALL_PREFIX:PATH="${INSTALL_PREFIX}"
                    -DLIT_EXECUTABLE:PATH="${LLVM_SOURCE_DIR}/utils/lit/lit.py"
                    -DFILECHECK_EXECUTABLE:PATH="$(build_directory_bin ${deployment_target} llvm)/FileCheck"
                    -DCMAKE_BUILD_TYPE:STRING="${LLBUILD_BUILD_TYPE}"
                    -DLLVM_ENABLE_ASSERTIONS:BOOL=$(true_false "${LLBUILD_ENABLE_ASSERTIONS}")
                    "${LLBUILD_SOURCE_DIR}"
                )
                ;;
            swiftpm)
                set_swiftpm_bootstrap_command
                set -x
                "${swiftpm_bootstrap_command[@]}"
                { set +x; } 2>/dev/null
                
                # swiftpm installs itself with a bootstrap method. No further cmake building is performed.
                continue
                ;;
            xctest)
                SWIFTC_BIN="$(build_directory_bin ${deployment_target} swift)/swiftc"
                XCTEST_BUILD_DIR=$(build_directory ${deployment_target} xctest)
                if [[ "$(uname -s)" == "Darwin" ]] ; then
                    # xcodebuild requires swift-stdlib-tool to build a Swift
                    # framework. This is normally present when building XCTest
                    # via a packaged .xctoolchain, but here we are using the
                    # swiftc that was just built--no toolchain exists yet. As a
                    # result, we must copy swift-stdlib-tool ourselves.
                    copy_swift_stdlib_tool_substitute "$(build_directory_bin ${deployment_target} swift)/swift-stdlib-tool"

                    set -x
                    xcodebuild \
                        -workspace "${XCTEST_SOURCE_DIR}"/XCTest.xcworkspace \
                        -scheme SwiftXCTest \
                        SWIFT_EXEC="${SWIFTC_BIN}" \
                        SWIFT_LINK_OBJC_RUNTIME=YES \
                        SYMROOT="${XCTEST_BUILD_DIR}" \
                        OBJROOT="${XCTEST_BUILD_DIR}"
                    { set +x; } 2>/dev/null
                else
                    FOUNDATION_BUILD_DIR=$(build_directory ${deployment_target} foundation)
                    set -x
                    # FIXME: Use XCTEST_BUILD_TYPE (which is never properly
                    #        set) to build either --debug or --release.
                    "${XCTEST_SOURCE_DIR}"/build_script.py \
                        --swiftc="${SWIFTC_BIN}" \
                        --build-dir="${XCTEST_BUILD_DIR}" \
                        --foundation-build-dir="${FOUNDATION_BUILD_DIR}/Foundation"
                    { set +x; } 2>/dev/null
                fi

                # XCTest builds itself and doesn't rely on cmake
                continue
                ;;
            foundation)
                # The configuration script requires knowing about XCTest's
                # location for building and running the tests. Note that XCTest
                # is not yet built at this point.
                XCTEST_BUILD_DIR=$(build_directory ${deployment_target} xctest)
                SWIFTC_BIN="$(build_directory_bin ${deployment_target} swift)/swiftc"
                SWIFT_BIN="$(build_directory_bin ${deployment_target} swift)/swift"
                SWIFT_BUILD_PATH="$(build_directory ${deployment_target} swift)"
                LLVM_BIN="$(build_directory_bin ${deployment_target} llvm)"
                NINJA_BIN="ninja"

                # Staging: require opt-in for building with dispatch
                if [[ ! "${SKIP_BUILD_LIBDISPATCH}" ]] ; then
                    LIBDISPATCH_BUILD_DIR="$(build_directory ${deployment_target} libdispatch)"
                    LIBDISPATCH_BUILD_ARGS="-DLIBDISPATCH_SOURCE_DIR=${LIBDISPATCH_SOURCE_DIR} -DLIBDISPATCH_BUILD_DIR=${LIBDISPATCH_BUILD_DIR}"
                fi

                if [[ "${USE_GOLD_LINKER}" ]]; then
                    SWIFT_USE_LINKER="-fuse-ld=gold"
                fi

                if [[ "${BUILD_NINJA}" ]]; then
                    NINJA_BUILD_DIR=$(build_directory build ninja)
                    NINJA_BIN="${NINJA_BUILD_DIR}/ninja"
                fi
                
                set -x
                pushd "${FOUNDATION_SOURCE_DIR}"
                SWIFTC="${SWIFTC_BIN}" CLANG="${LLVM_BIN}"/clang SWIFT="${SWIFT_BIN}" \
                      SDKROOT="${SWIFT_BUILD_PATH}" BUILD_DIR="${build_dir}" DSTROOT="${INSTALL_DESTDIR}" PREFIX="${INSTALL_PREFIX}" ./configure "${FOUNDATION_BUILD_TYPE}" -DXCTEST_BUILD_DIR=${XCTEST_BUILD_DIR} $LIBDISPATCH_BUILD_ARGS
                ${NINJA_BIN}
                popd
                { set +x; } 2>/dev/null

                # Foundation builds itself and doesn't use cmake
                continue
                ;;
            libdispatch)
                LIBDISPATCH_BUILD_DIR=$(build_directory ${deployment_target} ${product})
                SWIFT_BUILD_PATH="$(build_directory ${deployment_target} swift)"

                set -x
                if [[ ! -f "${LIBDISPATCH_BUILD_DIR}"/config.status ]]; then
                    # First time building; need to run autotools and configure
                    mkdir -p "${LIBDISPATCH_BUILD_DIR}"
                    pushd "${LIBDISPATCH_SOURCE_DIR}"
                    autoreconf -fvi
                    popd
                    pushd "${LIBDISPATCH_BUILD_DIR}"
                    "${LIBDISPATCH_SOURCE_DIR}"/configure --prefix="${INSTALL_DESTDIR}"/"${INSTALL_PREFIX}" --with-swift-toolchain="${SWIFT_BUILD_PATH}"
                    popd
                fi
                pushd "${LIBDISPATCH_BUILD_DIR}"
                make
                cd tests
                make build-tests
                popd
                { set +x; } 2>/dev/null

                # libdispatch builds itself and doesn't use cmake
                continue
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac

        # Clean the product-local module cache.
        rm -rf "${module_cache}"
        mkdir -p "${module_cache}"

        # Compute the generator output file to check for, to determine if we
        # must reconfigure. We only handle Ninja for now.
        #
        # This is important for ensuring that if a CMake configuration fails in
        # CI, that we will still be willing to rerun the configuration process.
        generator_output_path=""
        if [[ "${CMAKE_GENERATOR}" == "Ninja" ]] ; then
            generator_output_path="${build_dir}/build.ninja"
        fi

        # Configure if necessary.
        if [[  "${RECONFIGURE}" || ! -f "${build_dir}/CMakeCache.txt" || \
                    ( ! -z "${generator_output_path}" && ! -f "${generator_output_path}" ) ]] ; then
            mkdir -p "${build_dir}"
            set -x
            (cd "${build_dir}" && "${CMAKE}" "${cmake_options[@]}" ${USER_CONFIG_ARGS})
            { set +x; } 2>/dev/null
        fi

        # Build.
        if [[ ! "${skip_build}" ]]; then
            if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
                # Xcode generator uses "ALL_BUILD" instead of "all".
                # Also, xcodebuild uses -target instead of bare names.
                build_targets=("${build_targets[@]/all/ALL_BUILD}")
                build_targets=("${build_targets[@]/#/${BUILD_TARGET_FLAG} }")

                # Xcode can't restart itself if it turns out we need to reconfigure.
                # Do an advance build to handle that.
                set -x
                ${DISTCC_PUMP} "${CMAKE}" --build "${build_dir}" $(cmake_config_opt ${product})
                { set +x; } 2>/dev/null
            fi

            set -x
            ${DISTCC_PUMP} "${CMAKE}" --build "${build_dir}" $(cmake_config_opt ${product}) -- ${BUILD_ARGS} ${build_targets[@]}
            { set +x; } 2>/dev/null
        fi

        # When we are building LLVM create symlinks to the c++ headers.
        if [[ "${product}" == "llvm" ]]; then
            set -x

            # Find the location of the c++ header dir.
            if [[ "$(uname -s)" == "Darwin" ]] ; then
              HOST_CXX_DIR=$(dirname ${HOST_CXX})
              HOST_CXX_HEADERS_DIR="$HOST_CXX_DIR/../../usr/include/c++"
            else # Linux
              HOST_CXX_HEADERS_DIR="/usr/include/c++"
            fi

            # Find the path in which the local clang build is expecting to find
            # the c++ header files.
            BUILT_CXX_INCLUDE_DIR="$llvm_build_dir/include"

            echo "symlinking the system headers ($HOST_CXX_HEADERS_DIR) into the local clang build directory ($BUILT_CXX_INCLUDE_DIR)."
            ln -s -f "$HOST_CXX_HEADERS_DIR" "$BUILT_CXX_INCLUDE_DIR"
            { set +x; } 2>/dev/null
        fi
    done
done
# END OF BUILD PHASE

# Trap function to print the current test configuration when tests fail.
# This is a function so the text is not unnecessarily displayed when running -x.
tests_busted ()
{
    echo "*** Failed while running tests for $1 $2"
}

for deployment_target in "${STDLIB_DEPLOYMENT_TARGETS[@]}"; do
    case ${deployment_target} in
        linux-* | freebsd-* | macosx-* | cygwin-*)
            # OK, we can run tests directly.
            ;;
        iphoneos-* | iphonesimulator-* | appletvos-* | appletvsimulator-* | watchos-* | watchsimulator-* | android-* )
            # FIXME: remove this
            # echo "Don't know how to run tests for ${deployment_target}"
            continue
            ;;
        *)
            echo "Unknown compiler deployment target: ${deployment_target}"
            exit 1
            ;;
    esac

    # Run the tests for each product
    for product in "${PRODUCTS[@]}"; do
        case ${product} in
            cmark)
                if [[ "${SKIP_TEST_CMARK}" ]]; then
                    continue
                fi
                executable_target=api_test
                results_targets=(test)
                if [[ "${CMAKE_GENERATOR}" == "Xcode" ]]; then
                    # Xcode generator uses "RUN_TESTS" instead of "test".
                    results_targets=(RUN_TESTS)
                fi
                ;;
            llvm)
                continue # We don't test LLVM
                ;;
            swift)
                executable_target=
                results_targets=
                if ! [[ "${SKIP_TEST_SWIFT}" ]]; then
                    executable_target=SwiftUnitTests
                    results_targets=("${SWIFT_TEST_TARGETS[@]}")
                    if [[ "${STRESS_TEST_SOURCEKIT}" ]]; then
                        results_targets=(
                            "${results_targets[@]}"
                            stress-SourceKit
                        )
                    fi
                fi
                if ! [[ "${SKIP_TEST_BENCHMARKS}" ]]; then
                    results_targets=(
                        "${results_targets[@]}"
                        "${SWIFT_RUN_BENCHMARK_TARGETS[@]}"
                    )
                fi
                if [[ -z "${results_targets[@]}" ]]; then
                    continue
                fi
                ;;
            lldb)
                if [[ "${SKIP_TEST_LLDB}" ]]; then
                    continue
                fi
                lldb_build_dir=$(build_directory ${deployment_target} lldb)
                swift_build_dir=$(build_directory ${deployment_target} swift)
                # Setup lldb executable path
                if [[ "$(uname -s)" == "Darwin" ]] ; then
                    lldb_executable="${lldb_build_dir}"/${LLDB_BUILD_MODE}/lldb
                else
                    lldb_executable="${lldb_build_dir}"/bin/lldb
                fi

                results_dir="${lldb_build_dir}/test-results"
                mkdir -p "${results_dir}"
                pushd "${results_dir}"

                # Handle test results formatter
                if [[ "${LLDB_TEST_WITH_CURSES}" ]]; then
                    # Setup the curses results formatter.
                    LLDB_FORMATTER_OPTS="\
                                       --results-formatter lldbsuite.test.curses_results.Curses \
                                       --results-file /dev/stdout"
                else
                    LLDB_FORMATTER_OPTS="\
                                       --results-formatter lldbsuite.test.xunit_formatter.XunitFormatter \
                                       --results-file ${results_dir}/results.xml \
                                       -O--xpass=ignore"
                    # Setup the xUnit results formatter.
                    if [[ "$(uname -s)" != "Darwin" ]] ; then
                        # On non-Darwin, we ignore skipped tests entirely
                        # so that they don't pollute our xUnit results with
                        # non-actionable content.
                        LLDB_FORMATTER_OPTS="${LLDB_FORMATTER_OPTS} -O-ndsym -O-rdebugserver -O-rlibc\\\\+\\\\+ -O-rlong.running -O-rbenchmarks -O-rrequires.one?.of.darwin"
                    fi
                fi

                # figure out which C/C++ compiler we should use for building test inferiors.
                if [[ "${LLDB_TEST_CC}" == "host-toolchain" ]]; then
                    # Use the host toolchain: i.e. the toolchain specified by HOST_CC
                    LLDB_DOTEST_CC_OPTS="-C ${HOST_CC}"
                elif [[ -n "${LLDB_TEST_CC}" ]]; then
                    # Use exactly the compiler path specified by the user.
                    LLDB_DOTEST_CC_OPTS="-C ${LLDB_TEST_CC}"
                else
                    # Use the clang that was just built in the tree.
                    LLDB_DOTEST_CC_OPTS="-C ${llvm_build_dir}"/bin/clang
                fi
                
                SWIFTCC="${swift_build_dir}/bin/swiftc" SWIFTLIBS="${swift_build_dir}/lib/swift" "${LLDB_SOURCE_DIR}"/test/dotest.py --executable "${lldb_executable}" --rerun-all-issues ${LLDB_DOTEST_CC_OPTS} ${LLDB_FORMATTER_OPTS}
                popd
                continue
                ;;
            llbuild)
                if [[ "${SKIP_TEST_LLBUILD}" ]]; then
                    continue
                fi
                results_targets=("test")
                executable_target=""
                ;;
            swiftpm)
                if [[ "${SKIP_TEST_SWIFTPM}" ]]; then
                    continue
                fi
                echo "--- Running tests for ${product} ---"
                set -x
                "${swiftpm_bootstrap_command[@]}" test
                { set +x; } 2>/dev/null
                # As swiftpm tests itself, we break early here.
                continue
                ;;
            xctest)
                if [[ "${SKIP_TEST_XCTEST}" ]]; then
                    continue
                fi
                echo "--- Running tests for ${product} ---"
                SWIFTC_BIN="$(build_directory_bin ${deployment_target} swift)/swiftc"
                if [[ "$(uname -s)" == "Darwin" ]] ; then
                    set -x
                    xcodebuild \
                        -workspace "${XCTEST_SOURCE_DIR}"/XCTest.xcworkspace \
                        -scheme SwiftXCTestFunctionalTests \
                        SWIFT_EXEC="${SWIFTC_BIN}" \
                        SWIFT_LINK_OBJC_RUNTIME=YES \
                        SYMROOT="${XCTEST_BUILD_DIR}" \
                        OBJROOT="${XCTEST_BUILD_DIR}"
                    { set +x; } 2>/dev/null
                else
                    FOUNDATION_BUILD_DIR=$(build_directory ${deployment_target} foundation)
                    XCTEST_BUILD_DIR=$(build_directory ${deployment_target} xctest)
                    set -x
                    "${XCTEST_SOURCE_DIR}"/build_script.py test \
                        --swiftc="${SWIFTC_BIN}" \
                        --foundation-build-dir="${FOUNDATION_BUILD_DIR}/Foundation" \
                        "${XCTEST_BUILD_DIR}"
                    { set +x; } 2>/dev/null
                fi
                echo "--- Finished tests for ${product} ---"
                continue
                ;;
            foundation)
                if [[ "${SKIP_TEST_FOUNDATION}" ]]; then
                    continue
                fi
                echo "--- Running tests for ${product} ---"
                set -x
                build_dir=$(build_directory ${deployment_target} ${product})
                XCTEST_BUILD_DIR=$(build_directory ${deployment_target} xctest)
                pushd "${FOUNDATION_SOURCE_DIR}"
                ${NINJA_BIN} TestFoundation
                LD_LIBRARY_PATH="${INSTALL_DESTDIR}"/"${INSTALL_PREFIX}"/lib/swift/:"${build_dir}/Foundation":"${XCTEST_BUILD_DIR}":${LD_LIBRARY_PATH} "${build_dir}"/TestFoundation/TestFoundation
                popd
                { set +x; } 2>/dev/null
                echo "--- Finished tests for ${product} ---"
                continue
                ;;
            libdispatch)
                if [[ "${SKIP_TEST_LIBDISPATCH}" ]]; then
                    continue
                fi
                LIBDISPATCH_BUILD_DIR=$(build_directory ${deployment_target} ${product})
                echo "--- Running tests for ${product} ---"
                set -x
                pushd "${LIBDISPATCH_BUILD_DIR}"
                make check
                popd
                { set +x; } 2>/dev/null
                echo "--- Finished tests for ${product} ---"
                continue
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac

        trap "tests_busted ${product} ''" ERR
        build_dir=$(build_directory ${deployment_target} ${product})
        build_cmd=("${CMAKE}" --build "${build_dir}" $(cmake_config_opt ${product}) -- ${BUILD_ARGS})

        if [[ "${executable_target}" != "" ]]; then
            echo "--- Building tests for ${product} ---"
            set -x
            ${DISTCC_PUMP} "${build_cmd[@]}" ${BUILD_TARGET_FLAG} "${executable_target}"
            { set +x; } 2>/dev/null
        fi

        echo "--- Running tests for ${product} ---"
        for target in "${results_targets[@]}"; do
            if [[ "${target}" != "" ]]; then
                echo "--- ${target} ---"
                trap "tests_busted ${product} '(${target})'" ERR
                if [[ "${CMAKE_GENERATOR}" == Ninja ]] && !( "${build_cmd[@]}" --version 2>&1 | grep -i -q llbuild ); then
                    # Ninja buffers command output to avoid scrambling the output
                    # of parallel jobs, which is awesome... except that it
                    # interferes with the progress meter when testing.  Instead of
                    # executing ninja directly, have it dump the commands it would
                    # run, strip Ninja's progress prefix with sed, and tell the
                    # shell to execute that.
                    sh -c "set -x && $("${build_cmd[@]}" -n -v ${target} | sed -e 's/[^]]*] //')"
                else
                    set -x
                    "${build_cmd[@]}" ${BUILD_TARGET_FLAG} ${target}
                    { set +x; } 2>/dev/null
                fi
                echo "-- ${target} finished --"
            fi
        done

        trap - ERR
        echo "--- Finished tests for ${product} ---"
    done
done

for deployment_target in "${HOST_TARGET}" "${CROSS_TOOLS_DEPLOYMENT_TARGETS[@]}"; do
    set_deployment_target_based_options

    for product in "${PRODUCTS[@]}"; do

        INSTALL_TARGETS="install"

        case ${product} in
            cmark)
                if [[ -z "${INSTALL_CMARK}" ]] ; then
                    continue
                fi
                ;;
            llvm)
                if [[ -z "${LLVM_INSTALL_COMPONENTS}" ]] ; then
                    continue
                fi
                INSTALL_TARGETS=install-$(echo ${LLVM_INSTALL_COMPONENTS} | sed -E 's/;/ install-/g')
                ;;
            swift)
                if [[ -z "${INSTALL_SWIFT}" ]] ; then
                    continue
                fi
                ;;
            lldb)
                if [[ -z "${INSTALL_LLDB}" ]] ; then
                    continue
                fi
                case "$(uname -s)" in
                    Linux)
                        ;;
                    FreeBSD)
                        ;;
                    CYGWIN_NT-10.0)
                        ;;
                    Darwin)
                        set_lldb_build_mode
                        pushd ${LLDB_SOURCE_DIR}
                        xcodebuild -target toolchain -configuration ${LLDB_BUILD_MODE} install ${lldb_xcodebuild_options[@]} DSTROOT="${INSTALL_DESTDIR}" LLDB_TOOLCHAIN_PREFIX="${TOOLCHAIN_PREFIX}"
                        popd
                        continue
                        ;;
                esac
                ;;
            llbuild)
                if [[ -z "${INSTALL_LLBUILD}" ]] ; then
                    continue
                fi
                INSTALL_TARGETS=install-swift-build-tool
                ;;
            swiftpm)
                if [[ -z "${INSTALL_SWIFTPM}" ]] ; then
                    continue
                fi
                if [[ -z "${INSTALL_DESTDIR}" ]] ; then
                    echo "error: --install-destdir is required"
                    exit 1
                fi

                echo "--- Installing ${product} ---"
                set -x
                "${swiftpm_bootstrap_command[@]}" --prefix="${INSTALL_DESTDIR}"/"${INSTALL_PREFIX}" install
                { set +x; } 2>/dev/null
                # As swiftpm bootstraps the installation itself, we break early here.
                continue
                ;;
            xctest)
                if [[ -z "${INSTALL_XCTEST}" ]] ; then
                    continue
                fi
                if [[ -z "${INSTALL_DESTDIR}" ]] ; then
                    echo "error: --install-destdir is required"
                    exit 1
                fi
                case "$(uname -s)" in
                    Linux)
                        LIB_TARGET="linux"
                        ;;
                    FreeBSD)
                        LIB_TARGET="freebsd"
                        ;;
                    CYGWIN_NT-10.0)
                        LIB_TARGET="windows"
                        ;;
                    *)
                        echo "error: --install-xctest is not supported on this platform"
                        exit 1
                        ;;
                esac

                echo "--- Installing ${product} ---"
                XCTEST_BUILD_DIR=$(build_directory ${deployment_target} xctest)
                XCTEST_INSTALL_PREFIX="${INSTALL_DESTDIR}/${INSTALL_PREFIX}/lib/swift/${LIB_TARGET}"
                # Note that installing directly to /usr/lib/swift usually
                # requires root permissions.
                set -x
                "${XCTEST_SOURCE_DIR}"/build_script.py install \
                    --library-install-path="${XCTEST_INSTALL_PREFIX}" \
                    --module-install-path="${XCTEST_INSTALL_PREFIX}"/"${SWIFT_HOST_VARIANT_ARCH}" \
                    "${XCTEST_BUILD_DIR}"
                { set +x; } 2>/dev/null

                # As XCTest installation is self-contained, we break early here.
                continue
                ;;
            foundation)
                if [[ -z "${INSTALL_FOUNDATION}" ]] ; then
                    continue
                fi
                echo "--- Installing ${product} ---"
                build_dir=$(build_directory ${deployment_target} ${product})
                set -x
                pushd "${FOUNDATION_SOURCE_DIR}"
                ${NINJA_BIN} install
                popd
                { set +x; } 2>/dev/null

                # As foundation installation is self-contained, we break early here.
                continue
                ;;
            libdispatch)
                if [[ -z "${INSTALL_LIBDISPATCH}" ]] ; then
                    continue
                fi
                echo "--- Installing ${product} ---"
                LIBDISPATCH_BUILD_DIR=$(build_directory ${deployment_target} ${product})
                set -x
                pushd "${LIBDISPATCH_BUILD_DIR}"
                make install
                popd
                { set +x; } 2>/dev/null

                # As libdispatch installation is self-contained, we break early here.
                continue
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac

        if [[ -z "${INSTALL_DESTDIR}" ]] ; then
            echo "error: --install-destdir is required"
            exit 1
        fi

        if [ "${CROSS_COMPILE_TOOLS_DEPLOYMENT_TARGETS}" ] ; then
            # If cross compiling tools, install into a deployment target specific subdirectory.
            if [[ ! "${SKIP_MERGE_LIPO_CROSS_COMPILE_TOOLS}" ]] ; then
                target_install_destdir="${BUILD_DIR}"/intermediate-install/"${deployment_target}"
            else
                target_install_destdir="${INSTALL_DESTDIR}"/"${deployment_target}"
            fi
        else
            target_install_destdir="${INSTALL_DESTDIR}"
        fi

        echo "--- Installing ${product} ---"
        build_dir=$(build_directory ${deployment_target} ${product})

        set -x

        DESTDIR="${target_install_destdir}" "${CMAKE}" --build "${build_dir}" -- ${INSTALL_TARGETS}
        { set +x; } 2>/dev/null
    done

done

if [[ "${CROSS_COMPILE_TOOLS_DEPLOYMENT_TARGETS}" ]] && [[ ! "${SKIP_MERGE_LIPO_CROSS_COMPILE_TOOLS}" ]] ; then
    echo "--- Merging and running lipo for ${CROSS_TOOLS_DEPLOYMENT_TARGETS[@]} ---"
    lipo_src_dirs=()
    for deployment_target in "${CROSS_TOOLS_DEPLOYMENT_TARGETS[@]}"; do
        lipo_src_dirs=(
            "${lipo_src_dirs[@]}"
            "${BUILD_DIR}"/intermediate-install/"${deployment_target}"
        )
    done
    "${SWIFT_SOURCE_DIR}"/utils/recursive-lipo --lipo=$(xcrun_find_tool lipo) --copy-subdirs="${INSTALL_PREFIX}/lib/swift ${INSTALL_PREFIX}/lib/swift_static" --destination="${INSTALL_DESTDIR}" ${lipo_src_dirs[@]}
fi

if [[ "${DARWIN_INSTALL_EXTRACT_SYMBOLS}" ]] ; then
    set -x
    # Copy executables and shared libraries from the INSTALL_DESTDIR to
    # INSTALL_SYMROOT and run dsymutil on them.
    (cd "${INSTALL_DESTDIR}" &&
     find ./"${TOOLCHAIN_PREFIX}" -perm -0111 -type f -print | cpio -pdm "${INSTALL_SYMROOT}")

    # Run dsymutil on executables and shared libraries.
    #
    # Exclude shell scripts.
    (cd "${INSTALL_SYMROOT}" &&
     find ./"${TOOLCHAIN_PREFIX}" -perm -0111 -type f -print | \
       grep -v swift-stdlib-tool | \
       grep -v crashlog.py | \
       grep -v symbolication.py | \
       xargs -n 1 -P ${BUILD_JOBS} $(xcrun_find_tool dsymutil))

    # Strip executables, shared libraries and static libraries in
    # INSTALL_DESTDIR.
    find "${INSTALL_DESTDIR}"/"${TOOLCHAIN_PREFIX}" \
      \( -perm -0111 -or -name "*.a" \) -type f -print | \
      xargs -n 1 -P ${BUILD_JOBS} $(xcrun_find_tool strip) -S

    { set +x; } 2>/dev/null
fi

if [[ "${INSTALLABLE_PACKAGE}" ]] ; then
    echo "--- Creating installable package ---"
    echo "-- Package file: ${INSTALLABLE_PACKAGE} --"
    if [[ "$(uname -s)" == "Darwin" ]] ; then
      copy_swift_stdlib_tool_substitute "${INSTALL_DESTDIR}/${INSTALL_PREFIX}/bin/swift-stdlib-tool"
      
      # Create plist for xctoolchain.
      echo "-- Create Info.plist --"
      PLISTBUDDY_BIN="/usr/libexec/PlistBuddy"

      DARWIN_TOOLCHAIN_INSTALL_LOCATION="/Library/Developer/Toolchains/${DARWIN_TOOLCHAIN_NAME}.xctoolchain"
      DARWIN_TOOLCHAIN_INFO_PLIST="${INSTALL_DESTDIR}/${TOOLCHAIN_PREFIX}/Info.plist"
      DARWIN_TOOLCHAIN_REPORT_URL="https://bugs.swift.org/"

      echo "-- Removing: ${DARWIN_TOOLCHAIN_INFO_PLIST}"
      rm -f ${DARWIN_TOOLCHAIN_INFO_PLIST}

      ${PLISTBUDDY_BIN} -c "Add DisplayName string '${DARWIN_TOOLCHAIN_DISPLAY_NAME}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
      ${PLISTBUDDY_BIN} -c "Add Version string '${DARWIN_TOOLCHAIN_VERSION}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
      ${PLISTBUDDY_BIN} -c "Add CFBundleIdentifier string '${DARWIN_TOOLCHAIN_BUNDLE_IDENTIFIER}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
      ${PLISTBUDDY_BIN} -c "Add ReportProblemURL string '${DARWIN_TOOLCHAIN_REPORT_URL}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
      ${PLISTBUDDY_BIN} -c "Add Aliases array" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
      ${PLISTBUDDY_BIN} -c "Add Aliases:0 string '${DARWIN_TOOLCHAIN_ALIAS}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
      chmod a+r "${DARWIN_TOOLCHAIN_INFO_PLIST}"

      if [[ "${DARWIN_TOOLCHAIN_APPLICATION_CERT}" ]] ; then
        echo "-- Codesign xctoolchain --"
        "${SWIFT_SOURCE_DIR}/utils/toolchain-codesign" "${DARWIN_TOOLCHAIN_APPLICATION_CERT}" "${INSTALL_DESTDIR}/${TOOLCHAIN_PREFIX}" 
      fi
      if [[ "${DARWIN_TOOLCHAIN_INSTALLER_PACKAGE}" ]] ; then
        echo "-- Create Installer --"
        "${SWIFT_SOURCE_DIR}/utils/toolchain-installer" "${INSTALL_DESTDIR}/${TOOLCHAIN_PREFIX}" "${DARWIN_TOOLCHAIN_BUNDLE_IDENTIFIER}" \
        "${DARWIN_TOOLCHAIN_INSTALLER_CERT}" "${DARWIN_TOOLCHAIN_INSTALLER_PACKAGE}" "${DARWIN_TOOLCHAIN_INSTALL_LOCATION}" \
        "${DARWIN_TOOLCHAIN_VERSION}" "${SWIFT_SOURCE_DIR}/utils/darwin-installer-scripts"
      fi 

      (cd "${INSTALL_DESTDIR}" &&
        tar -c -z -f "${INSTALLABLE_PACKAGE}" "${TOOLCHAIN_PREFIX/#\/}")
    else
      (cd "${INSTALL_DESTDIR}" &&
        tar -c -z -f "${INSTALLABLE_PACKAGE}" --owner=0 --group=0 "${INSTALL_PREFIX/#\/}")
    fi
    if [[ "${TEST_INSTALLABLE_PACKAGE}" ]] ; then
        PKG_TESTS_SOURCE_DIR="${WORKSPACE}/swift-integration-tests"
        PKG_TESTS_SANDBOX_PARENT="$(build_directory swift_package_sandbox none)"

        if [[ "$(uname -s)" == "Darwin" ]] ; then
            PKG_TESTS_SANDBOX="${PKG_TESTS_SANDBOX_PARENT}"/"${TOOLCHAIN_PREFIX}"
        else # Linux
            PKG_TESTS_SANDBOX="${PKG_TESTS_SANDBOX_PARENT}"
        fi

        LIT_EXECUTABLE_PATH="${LLVM_SOURCE_DIR}/utils/lit/lit.py"
        FILECHECK_EXECUTABLE_PATH="$(build_directory_bin ${deployment_target} llvm)/FileCheck"
        echo "-- Test Installable Package --"
        set -x
        rm -rf "${PKG_TESTS_SANDBOX_PARENT}"
        mkdir -p "${PKG_TESTS_SANDBOX}"
        pushd "${PKG_TESTS_SANDBOX_PARENT}"
        tar xzf "${INSTALLABLE_PACKAGE}"
        popd

        (cd "${PKG_TESTS_SOURCE_DIR}" &&
                python "${LIT_EXECUTABLE_PATH}" . -sv --param package-path="${PKG_TESTS_SANDBOX}" --param filecheck="${FILECHECK_EXECUTABLE_PATH}")
        { set +x; } 2>/dev/null
    fi
fi

