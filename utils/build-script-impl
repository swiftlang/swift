#!/usr/bin/env bash
#===--- build-script-impl - Implementation details of build-script ---------===#
#
## This source file is part of the Swift.org open source project
##
## Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
## Licensed under Apache License v2.0 with Runtime Library Exception
##
## See http://swift.org/LICENSE.txt for license information
## See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
#===------------------------------------------------------------------------===#

#
# This script is an implementation detail of other build scripts and should not
# be called directly.
#
# Note: This script will NOT auto-clean before building.
#

set -o pipefail
set -e

umask 0022

#
# Options that can be "configured" by editing this file.
#
# These options are not exposed as command line options on purpose.  If you
# need to change any of these, you should do so on trunk or in a branch.
#

LLVM_TARGETS_TO_BUILD="X86;ARM;AArch64;PowerPC;SystemZ"

#
# End of configurable options.
#

# Declare the set of known settings along with each one's description
#
# If you add a user-settable variable, add it to this list.
#
# A default value of "" indicates that the corresponding variable
# will remain unset unless set explicitly.
#
# skip-* parameters do not affect the configuration (CMake parameters).
# You can turn them on and off in different invocations of the script for the
# same build directory.
#
# build-* parameters affect the CMake configuration (enable/disable those
# components).
#
# Each variable name is re-exported into this script in uppercase, where dashes
# are substituted by underscores. For example, `swift-install-components` is
# referred to as `SWIFT_INSTALL_COMPONENTS` in the remainder of this script.
KNOWN_SETTINGS=(
    # name                      default          description
    build-args                  ""               "arguments to the build tool; defaults to -j8 when CMake generator is \"Unix Makefiles\""
    build-dir                   ""               "out-of-tree build directory; default is in-tree. **This argument is required**"
    host-cc                     ""               "the path to CC, the 'clang' compiler for the host platform. **This argument is required**"
    host-cxx                    ""               "the path to CXX, the 'clang++' compiler for the host platform. **This argument is required**"
    darwin-xcrun-toolchain      "default"        "the name of the toolchain to use on Darwin"
    ninja-bin                   ""               "the path to Ninja tool"
    cmark-build-type            "Debug"          "the CMake build variant for CommonMark (Debug, RelWithDebInfo, Release, MinSizeRel).  Defaults to Debug."
    lldb-extra-cmake-args       ""               "extra command line args to pass to lldb cmake"
    lldb-extra-xcodebuild-args  ""               "extra command line args to pass to lldb xcodebuild"
    lldb-test-cc                ""               "CC to use for building LLDB testsuite test inferiors.  Defaults to just-built, in-tree clang.  If set to 'host-toolchain', sets it to same as host-cc."
    lldb-test-with-curses       ""               "run test lldb test runner using curses terminal control"
    lldb-no-debugserver         ""               "delete debugserver after building it, and don't try to codesign it"
    lldb-use-system-debugserver ""               "don't try to codesign debugserver, and use the system's debugserver instead"
    llvm-build-type             "Debug"          "the CMake build variant for LLVM and Clang (Debug, RelWithDebInfo, Release, MinSizeRel).  Defaults to Debug."
    llvm-enable-assertions      "1"              "enable assertions in LLVM and Clang"
    swift-build-type            "Debug"          "the CMake build variant for Swift"
    swift-enable-assertions     "1"              "enable assertions in Swift"
    swift-analyze-code-coverage "not-merged"     "Code coverage analysis mode for Swift (false, not-merged, merged). Defaults to false if the argument is not present, and not-merged if the argument is present without a modifier."
    swift-enable-lto            "0"              "enable LTO compilation of just Swift."
    llvm-enable-lto             "0"              "enable LTO compilation of LLVM/Clang."
    swift-stdlib-build-type     "Debug"          "the CMake build variant for Swift"
    swift-stdlib-enable-assertions "1"           "enable assertions in Swift"
    swift-stdlib-enable-resilience "0"           "build the Swift stdlib and overlays with resilience enabled"
    swift-stdlib-sil-serialize-all "1"           "build the Swift stdlib and overlays with all method bodies serialized"
    lldb-build-type             "Debug"          "the CMake build variant for LLDB"
    llbuild-build-type          "Debug"          "the CMake build variant for llbuild"
    foundation-build-type       "Debug"          "the build variant for Foundation"
    llbuild-enable-assertions   "1"              "enable assertions in llbuild"
    enable-asan                 ""               "enable Address Sanitizer"
    enable-ubsan                ""               "enable Undefined Behavior Sanitizer"
    cmake                       ""               "path to the cmake binary"
    distcc                      ""               "use distcc in pump mode"
    distcc-pump                 ""               "the path to distcc pump executable. This argument is required if distcc is set."
    build-runtime-with-host-compiler   "1"       "use the host c++ compiler to build everything"
    cmake-generator             "Unix Makefiles" "kind of build system to generate; see output of 'cmake --help' for choices"
    verbose-build               ""               "print the commands executed during the build"
    install-prefix              ""               "installation prefix"
    toolchain-prefix            ""               "the path to the .xctoolchain directory that houses the install prefix path"
    install-destdir             ""               "the path to use as the filesystem root for the installation"
    install-symroot             ""               "the path to install debug symbols into"
    swift-install-components    ""               "a semicolon-separated list of Swift components to install"
    llvm-install-components    ""                "a semicolon-separated list of LLVM components to install"
    installable-package         ""               "the path to the archive of the installation directory"
    test-installable-package    ""               "whether to run post-packaging tests on the produced package"
    reconfigure                 ""               "force a CMake configuration run even if CMakeCache.txt already exists"
    swift-primary-variant-sdk   ""               "default SDK for target binaries"
    swift-primary-variant-arch  ""               "default arch for target binaries"
    skip-build-cmark            ""               "set to skip building CommonMark"
    skip-build-llvm             ""               "set to skip building LLVM/Clang"
    skip-build-swift            ""               "set to skip building Swift"
    skip-build-lldb             ""               "set to skip building LLDB"
    skip-build-llbuild          ""               "set to skip building llbuild"
    skip-build-swiftpm          ""               "set to skip building swiftpm"
    skip-build-xctest           ""               "set to skip building xctest"
    skip-build-foundation       ""               "set to skip building foundation"
    skip-build-libdispatch      ""               "set to skip building libdispatch"
    skip-build-benchmarks       ""               "set to skip building Swift Benchmark Suite"
    skip-test-cmark             ""               "set to skip testing CommonMark"
    skip-test-lldb              ""               "set to skip testing lldb"
    skip-test-swift             ""               "set to skip testing Swift"
    skip-test-llbuild           ""               "set to skip testing llbuild"
    skip-test-swiftpm           ""               "set to skip testing swiftpm"
    skip-test-xctest            ""               "set to skip testing xctest"
    skip-test-foundation        ""               "set to skip testing foundation"
    skip-test-libdispatch       ""               "set to skip testing libdispatch"
    validation-test             "0"              "set to run the validation test suite"
    long-test                   "0"              "set to run the long test suite"
    skip-test-benchmarks        ""               "set to skip running Swift Benchmark Suite"
    skip-test-optimized         ""               "set to skip testing the test suite in optimized mode"
    stress-test-sourcekit       ""               "set to run the stress-SourceKit target"
    workspace                   "${HOME}/src"    "source directory containing llvm, clang, swift"
    enable-llvm-assertions      "1"              "set to enable llvm assertions"
    build-llvm                  "1"              "set to 1 to build LLVM and Clang"
    build-swift-tools           "1"              "set to 1 to build Swift host tools"
    build-swift-stdlib          "1"              "set to 1 to build the Swift standard library"
    build-swift-stdlib-unittest-extra "0"        "set to 1 to build optional StdlibUnittest components"
    build-swift-sdk-overlay     "1"              "set to 1 to build the Swift SDK overlay"
    build-swift-static-stdlib   "0"              "set to 1 to build static versions of the Swift standard library and SDK overlay"
    build-swift-examples        "1"              "set to 1 to build examples"
    build-serialized-stdlib-unittest "0"         "set to 1 to build the StdlibUnittest module with -sil-serialize-all"
    build-sil-debugging-stdlib  "0"              "set to 1 to build the Swift standard library with -gsil to enable debugging and profiling on SIL level"
    check-incremental-compilation "0"            "set to 1 to compile swift libraries multiple times to check if incremental compilation works"
    source-tree-includes-tests  "1"              "set to 0 to allow the build to proceed when 'test' directory is missing (required for B&I builds)"
    native-llvm-tools-path      ""               "directory that contains LLVM tools that are executable on the build machine"
    native-clang-tools-path     ""               "directory that contains Clang tools that are executable on the build machine"
    native-swift-tools-path     ""               "directory that contains Swift tools that are executable on the build machine"
    compiler-vendor             "none"           "compiler vendor name [none,apple]"
    clang-user-visible-version  "3.8.0"          "user-visible version of the embedded Clang and LLVM compilers"
    swift-user-visible-version  "3.0"            "user-visible version of the Swift language"
    swift-compiler-version      ""               "string that indicates a compiler version for Swift"
    clang-compiler-version      ""               "string that indicates a compiler version for Clang"
    embed-bitcode-section       "0"              "embed an LLVM bitcode section in stdlib/overlay binaries for supported platforms"
    darwin-crash-reporter-client ""              "whether to enable CrashReporter integration"
    darwin-stdlib-install-name-dir ""            "the directory of the install_name for standard library dylibs"
    install-cmark               ""               "whether to install cmark"
    install-swift               ""               "whether to install Swift"
    install-lldb                ""               "whether to install LLDB"
    install-llbuild             ""               "whether to install llbuild"
    install-swiftpm             ""               "whether to install swiftpm"
    install-xctest              ""               "whether to install xctest"
    install-foundation          ""               "whether to install foundation"
    install-libdispatch         ""               "whether to install libdispatch"
    darwin-install-extract-symbols ""            "whether to extract symbols with dsymutil during installations"
    host-target                 ""               "The host target. LLVM, Clang, and Swift will be built for this target. The built LLVM and Clang will be used to compile Swift for the cross-compilation targets. **This argument is required**"
    stdlib-deployment-targets   ""               "space-separated list of targets to configure the Swift standard library to be compiled or cross-compiled for"
    build-stdlib-deployment-targets "all"        "space-separated list that determines which of the configured targets to build the Swift standard library for, or 'all' (default) or 'none'"
    test-stdlib-deployment-targets   "none"      "space-separated list that determines which of the configured targets to build the Swift standard library tests for, or 'all' or 'none' (default)"
    cross-compile-hosts         ""               "space-separated list of targets to cross-compile host Swift tools for"
    cross-compile-with-host-tools  ""            "set to use the clang we build for the host to then build the cross-compile hosts"
    cross-compile-install-prefixes      ""       "semicolon-separated list of install prefixes to use for the cross-compiled hosts. The list expands, so if there are more cross-compile hosts than prefixes, unmatched hosts use the last prefix in the list"
    skip-merge-lipo-cross-compile-tools ""       "set to skip running merge-lipo after installing cross-compiled host Swift tools"
    darwin-deployment-version-osx     "10.9"     "minimum deployment target version for OS X"
    darwin-deployment-version-ios     "7.0"      "minimum deployment target version for iOS"
    darwin-deployment-version-tvos    "9.0"      "minimum deployment target version for tvOS"
    darwin-deployment-version-watchos "2.0"      "minimum deployment target version for watchOS"
    extra-cmake-options         ""               "Extra options to pass to CMake for all targets"
    extra-swift-args            ""               "Extra arguments to pass to swift modules which match regex. Assumed to be a flattened cmake list consisting of [module_regexp, args, module_regexp, args, ...]"
    sil-verify-all              "0"              "If enabled, run the SIL verifier after each transform when building Swift files during this build process"
    swift-enable-ast-verifier   "1"              "If enabled, and the assertions are enabled, the built Swift compiler will run the AST verifier every time it is invoked"
    swift-runtime-enable-leak-checker   "0"              "Enable leaks checking routines in the runtime"
    use-gold-linker             ""               "Enable using the gold linker"
    darwin-toolchain-bundle-identifier ""        "CFBundleIdentifier for xctoolchain info plist"
    darwin-toolchain-display-name      ""        "Display Name for xctoolcain info plist"
    darwin-toolchain-display-name-short ""       "Display Name with out date for xctoolchain info plist"
    darwin-toolchain-name              ""        "Directory name for xctoolchain"
    darwin-toolchain-version           ""        "Version for xctoolchain info plist and installer pkg"
    darwin-toolchain-application-cert  ""        "Application Cert name to codesign xctoolchain"
    darwin-toolchain-installer-cert    ""        "Installer Cert name to create installer pkg"
    darwin-toolchain-installer-package ""        "The path to installer pkg"
    build-jobs                         ""        "The number of parallel build jobs to use"
    darwin-toolchain-alias             ""        "Swift alias for toolchain"
    android-ndk                        ""        "An absolute path to the NDK that will be used as a libc implementation for Android builds"
    android-api-level                  ""        "The Android API level to target when building for Android. Currently only 21 or above is supported"
    android-ndk-gcc-version            ""        "The GCC version to use when building for Android. Currently only 4.9 is supported"
    android-icu-uc                     ""        "Path to a directory containing libicuuc.so"
    android-icu-uc-include             ""        "Path to a directory containing headers for libicuuc"
    android-icu-i18n                   ""        "Path to a directory containing libicui18n.so"
    android-icu-i18n-include           ""        "Path to a directory containing headers libicui18n"
    check-args-only                    ""        "set to check all arguments are known. Exit with status 0 if success, non zero otherwise"
    common-cmake-options               ""        "CMake options used for all targets, including LLVM/Clang"
    # TODO: Remove this some time later.
    user-config-args            ""               "**Renamed to --extra-cmake-options**: User-supplied arguments to cmake when used to do configuration."
)

function toupper() {
    echo "$@" | tr '[:lower:]' '[:upper:]'
}

function true_false() {
    case "$1" in
        false | FALSE | 0 | "")
            echo "FALSE"
            ;;
        true | TRUE | 1)
            echo "TRUE"
            ;;
        *)
            echo "true_false: unknown value: $1" >&2
            exit 1
            ;;
    esac
}

function to_varname() {
    toupper "${1//-/_}"
}

function set_lldb_build_mode() {
    LLDB_BUILD_MODE="CustomSwift-${LLDB_BUILD_TYPE}"
}

function system_memory_in_bytes() {
    case "$(uname -s -m)" in
        Darwin\ x86_64)
            sysctl hw.memsize | cut -f 2 -d " "
            ;;
        *)
            echo "Unknown operating system"
            exit 1
            ;;
    esac
}

function float_min() {
    local LHS=$1
    local RHS=$2
    if (( $(echo "${LHS} < ${RHS}" | bc -l) )); then
        echo ${LHS}
    else
        echo ${RHS}
    fi
}

function num_llvm_parallel_lto_link_jobs() {
    case "$(uname -s -m)" in
        Darwin\ x86_64)
            # *WARNING! HEURISTIC!*
            #
            # Use the formula (GB Memory - 3)/6.0GB to get the number of
            # parallel link threads we can support. This gives the OS 3 GB of
            # room to work with.
            #
            # This is a bit conservative, but I have found that this number
            # prevents me from swapping on my test machine.
            local NUM_MEMORY_THREADS=$(echo \( $(system_memory_in_bytes)/1000000000.0 - 3.0 \) / 6.0 | bc)
            echo $(float_min "${NUM_MEMORY_THREADS}" "${BUILD_JOBS}")
            ;;
        *)
            echo "Unknown operating system"
            exit 1
            ;;
    esac
}

function num_swift_parallel_lto_link_jobs() {
    case "$(uname -s -m)" in
        Darwin\ x86_64)
            # *WARNING! HEURISTIC!*
            #
            # Use the formula (GB Memory - 3)/8.0GB to get the number of
            # parallel link threads we can support. This gives the OS 3 GB of
            # room to work with.
            #
            # This is a bit conservative, but I have found that this number
            # prevents me from swapping on my test machine.
            local NUM_MEMORY_THREADS=$(echo \( $(system_memory_in_bytes)/1000000000 - 3.0 \) / 8.0 | bc)
            echo $(float_min "${NUM_MEMORY_THREADS}" "${BUILD_JOBS}")
            ;;
        *)
            echo "Unknown operating system"
            exit 1
            ;;
    esac
}

function set_build_options_for_host() {
    llvm_cmake_options=()
    swift_cmake_options=()
    cmark_cmake_options=()
    swiftpm_bootstrap_options=()
    SWIFT_HOST_VARIANT=
    SWIFT_HOST_VARIANT_SDK=
    SWIFT_HOST_VARIANT_ARCH=
    SWIFT_HOST_TRIPLE=
    USE_GOLD_LINKER=
    local host="$1"

    # Hosts which can be cross-compiled must specify:
    # SWIFT_HOST_TRIPLE and llvm_target_arch (as well as usual HOST_VARIANT flags)
    
    case ${host} in
        freebsd-x86_64)
            SWIFT_HOST_VARIANT="freebsd"
            SWIFT_HOST_VARIANT_SDK="FREEBSD"
            SWIFT_HOST_VARIANT_ARCH="x86_64"
            ;;
        cygwin-x86_64)
            SWIFT_HOST_VARIANT="windows"
            SWIFT_HOST_VARIANT_SDK="CYGWIN"
            SWIFT_HOST_VARIANT_ARCH="x86_64"
            ;;
        linux-*)
            SWIFT_HOST_VARIANT="linux"
            SWIFT_HOST_VARIANT_SDK="LINUX"
            USE_GOLD_LINKER=1
            case ${host} in
                linux-x86_64)
                    SWIFT_HOST_VARIANT_ARCH="x86_64"
                    ;;
                linux-armv6)
                    SWIFT_HOST_VARIANT_ARCH="armv6"
                    SWIFT_HOST_TRIPLE="armv6-linux-gnueabihf"
                    llvm_target_arch="ARM"
                    ;;
                linux-armv7)
                    SWIFT_HOST_VARIANT_ARCH="armv7"
                    SWIFT_HOST_TRIPLE="armv7-linux-gnueabihf"
                    llvm_target_arch="ARM"
                    ;;
                linux-aarch64)
                    SWIFT_HOST_VARIANT_ARCH="aarch64"
                    ;;
                linux-powerpc64)
                    SWIFT_HOST_VARIANT_ARCH="powerpc64"
                    ;;
                linux-powerpc64le)
                    SWIFT_HOST_VARIANT_ARCH="powerpc64le"
                    ;;
                linux-s390x)
                    SWIFT_HOST_VARIANT_ARCH="s390x"
                    ;;
                esac
        ;;
        macosx-* | iphoneos-* | iphonesimulator-* | \
          appletvos-* | appletvsimulator-* | \
            watchos-* | watchsimulator-*)
            case ${host} in
                macosx-x86_64)
                    xcrun_sdk_name="macosx"
                    llvm_target_arch=""
                    SWIFT_HOST_TRIPLE="x86_64-apple-macosx${DARWIN_DEPLOYMENT_VERSION_OSX}"
                    SWIFT_HOST_VARIANT="macosx"
                    SWIFT_HOST_VARIANT_SDK="OSX"
                    SWIFT_HOST_VARIANT_ARCH="x86_64"

                    cmake_osx_deployment_target="${DARWIN_DEPLOYMENT_VERSION_OSX}"
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                        -DCMAKE_OSX_DEPLOYMENT_TARGET="${cmake_osx_deployment_target}"
                    )
                    swiftpm_bootstrap_options=(
                        --sysroot="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                iphonesimulator-i386)
                    xcrun_sdk_name="iphonesimulator"
                    llvm_target_arch="X86"
                    SWIFT_HOST_TRIPLE="i386-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    SWIFT_HOST_VARIANT="iphonesimulator"
                    SWIFT_HOST_VARIANT_SDK="IOS_SIMULATOR"
                    SWIFT_HOST_VARIANT_ARCH="i386"

                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                iphonesimulator-x86_64)
                    xcrun_sdk_name="iphonesimulator"
                    llvm_target_arch="X86"
                    SWIFT_HOST_TRIPLE="x86_64-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    SWIFT_HOST_VARIANT="iphonesimulator"
                    SWIFT_HOST_VARIANT_SDK="IOS_SIMULATOR"
                    SWIFT_HOST_VARIANT_ARCH="x86_64"
                    
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                iphoneos-armv7)
                    xcrun_sdk_name="iphoneos"
                    llvm_target_arch="ARM"
                    SWIFT_HOST_TRIPLE="armv7-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    SWIFT_HOST_VARIANT="iphoneos"
                    SWIFT_HOST_VARIANT_SDK="IOS"
                    SWIFT_HOST_VARIANT_ARCH="armv7"
                    
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                iphoneos-armv7s)
                    xcrun_sdk_name="iphoneos"
                    llvm_target_arch="ARM"
                    SWIFT_HOST_TRIPLE="armv7s-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    SWIFT_HOST_VARIANT="iphoneos"
                    SWIFT_HOST_VARIANT_SDK="IOS"
                    SWIFT_HOST_VARIANT_ARCH="armv7s"

                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                iphoneos-arm64)
                    xcrun_sdk_name="iphoneos"
                    llvm_target_arch="AArch64"
                    SWIFT_HOST_TRIPLE="arm64-apple-ios${DARWIN_DEPLOYMENT_VERSION_IOS}"
                    SWIFT_HOST_VARIANT="iphoneos"
                    SWIFT_HOST_VARIANT_SDK="IOS"
                    SWIFT_HOST_VARIANT_ARCH="arm64"

                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                appletvsimulator-x86_64)
                    xcrun_sdk_name="appletvsimulator"
                    llvm_target_arch="X86"
                    SWIFT_HOST_TRIPLE="x86_64-apple-tvos${DARWIN_DEPLOYMENT_VERSION_TVOS}"
                    SWIFT_HOST_VARIANT="appletvsimulator"
                    SWIFT_HOST_VARIANT_SDK="TVOS_SIMULATOR"
                    SWIFT_HOST_VARIANT_ARCH="x86_64"
                    
                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                appletvos-arm64)
                    xcrun_sdk_name="appletvos"
                    llvm_target_arch="AArch64"
                    SWIFT_HOST_TRIPLE="arm64-apple-tvos${DARWIN_DEPLOYMENT_VERSION_TVOS}"
                    SWIFT_HOST_VARIANT="appletvos"
                    SWIFT_HOST_VARIANT_SDK="TVOS"
                    SWIFT_HOST_VARIANT_ARCH="arm64"

                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                watchsimulator-i386)
                    xcrun_sdk_name="watchsimulator"
                    llvm_target_arch="X86"
                    SWIFT_HOST_TRIPLE="i386-apple-watchos${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
                    SWIFT_HOST_VARIANT="watchsimulator"
                    SWIFT_HOST_VARIANT_SDK="WATCHOS_SIMULATOR"
                    SWIFT_HOST_VARIANT_ARCH="i386"

                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                watchos-armv7k)
                    xcrun_sdk_name="watchos"
                    llvm_target_arch="ARM"
                    SWIFT_HOST_TRIPLE="armv7k-apple-watchos${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
                    SWIFT_HOST_VARIANT="watchos"
                    SWIFT_HOST_VARIANT_SDK="WATCHOS"
                    SWIFT_HOST_VARIANT_ARCH="armv7k"

                    cmake_osx_deployment_target=""
                    cmark_cmake_options=(
                        -DCMAKE_C_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_CXX_FLAGS="$(cmark_c_flags ${host})"
                        -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                    )
                    ;;
                *)
                    echo "Unknown host for swift tools: ${host}"
                    exit 1
                    ;;
            esac

            llvm_cmake_options=(
                -DCMAKE_OSX_DEPLOYMENT_TARGET:STRING="${cmake_osx_deployment_target}"
                -DCMAKE_OSX_SYSROOT:PATH="$(xcrun --sdk ${xcrun_sdk_name} --show-sdk-path)"
                -DLLVM_ENABLE_LIBCXX:BOOL=TRUE
                -DLLVM_TOOL_COMPILER_RT_BUILD:BOOL="$(false_true ${SKIP_COMPILER_RT})"
                -DLLVM_BUILD_EXTERNAL_COMPILER_RT:BOOL="$(false_true ${SKIP_COMPILER_RT})"
                -DCOMPILER_RT_ENABLE_IOS:BOOL=FALSE
                -DCOMPILER_RT_ENABLE_WATCHOS:BOOL=FALSE
                -DCOMPILER_RT_ENABLE_TVOS:BOOL=FALSE
                -DSANITIZER_MIN_OSX_VERSION="${cmake_osx_deployment_target}"
            )
            if [[ $(true_false "${LLVM_ENABLE_LTO}") = "TRUE" ]]; then
                if [[ $(cmake_needs_to_specify_standard_computed_defaults) = "TRUE" ]]; then
                    llvm_cmake_options+=(
                        "-DCMAKE_C_STANDARD_COMPUTED_DEFAULT=AppleClang"
                        "-DCMAKE_CXX_STANDARD_COMPUTED_DEFAULT=AppleClang"
                    )
                fi

                llvm_cmake_options+=(
                    "-DLLVM_PARALLEL_LINK_JOBS=$(num_llvm_parallel_lto_link_jobs)"
                )
            fi

            if [[ $(true_false "${SWIFT_ENABLE_LTO}") = "TRUE" ]]; then
                if [[ $(cmake_needs_to_specify_standard_computed_defaults) = "TRUE" ]]; then
                    swift_cmake_options+=(
                        "-DCMAKE_C_STANDARD_COMPUTED_DEFAULT=AppleClang"
                        "-DCMAKE_CXX_STANDARD_COMPUTED_DEFAULT=AppleClang"
                    )
                fi
                swift_cmake_options+=(
                    "-DSWIFT_PARALLEL_LINK_JOBS=$(num_swift_parallel_lto_link_jobs)"
                )
            fi

            swift_cmake_options+=(
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_OSX="${DARWIN_DEPLOYMENT_VERSION_OSX}"
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_IOS="${DARWIN_DEPLOYMENT_VERSION_IOS}"
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_TVOS="${DARWIN_DEPLOYMENT_VERSION_TVOS}"
                -DSWIFT_DARWIN_DEPLOYMENT_VERSION_WATCHOS="${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
                -DLLVM_ENABLE_LIBCXX:BOOL=TRUE
            )
            ;;
        *)
            echo "Unknown host tools target: ${host}"
            exit 1
            ;;
    esac

    if [[ "${llvm_target_arch}" ]] ; then
        llvm_cmake_options+=(
            -DLLVM_TARGET_ARCH="${llvm_target_arch}"
        )
    fi

    # For cross-compilable hosts, we need to know the triple
    # and it must be the same for both LLVM and Swift

    if [[ "${SWIFT_HOST_TRIPLE}" ]] ; then
        llvm_cmake_options+=(
            -DLLVM_HOST_TRIPLE:STRING="${SWIFT_HOST_TRIPLE}"
        )
        swift_cmake_options+=(
            -DSWIFT_HOST_TRIPLE:STRING="${SWIFT_HOST_TRIPLE}"
        )
    fi
    swift_cmake_options+=(
        -DSWIFT_HOST_VARIANT="${SWIFT_HOST_VARIANT}"
        -DSWIFT_HOST_VARIANT_SDK="${SWIFT_HOST_VARIANT_SDK}"
        -DSWIFT_HOST_VARIANT_ARCH="${SWIFT_HOST_VARIANT_ARCH}"
    )
}

# Set up an "associative array" of settings for error checking, and set
# (or unset) each corresponding variable to its default value
# If the Mac's bash were not stuck in the past, we could "declare -A" an
# associative array, but instead we have to hack it by defining variables
# declare -A IS_KNOWN_SETTING
for ((i = 0; i < ${#KNOWN_SETTINGS[@]}; i += 3)); do
    setting="${KNOWN_SETTINGS[i]}"

    default_value="${KNOWN_SETTINGS[$((i+1))]}"

    varname="$(to_varname "${setting}")"    # upcase the setting name to get the variable
    eval "${varname}_IS_KNOWN_SETTING=1"

    if [[ "${default_value}" ]] ; then
        # For an explanation of the backslash see http://stackoverflow.com/a/9715377
        eval ${varname}=$\default_value
    else
        unset ${varname}
    fi
done

COMMAND_NAME="$(basename "$0")"

# Print instructions for using this script to stdout
usage() {
    echo "Usage: ${COMMAND_NAME} [--help|-h] [ --SETTING=VALUE | --SETTING VALUE | --SETTING ]*"
    echo
    echo "  Available settings. Each setting corresponds to a variable,"
    echo "  obtained by upcasing its name, in this script.  A variable"
    echo "  with no default listed here will be unset in the script if"
    echo "  not explicitly specified.  A setting passed in the 3rd form"
    echo "  will set its corresponding variable to \"1\"."
    echo

    setting_list="
 | |Setting| Default|Description
 | |-------| -------|-----------
"

    for ((i = 0; i < ${#KNOWN_SETTINGS[@]}; i += 3)); do
        setting_list+="\
 | |--${KNOWN_SETTINGS[i]}| ${KNOWN_SETTINGS[$((i+1))]}|${KNOWN_SETTINGS[$((i+2))]}
"
    done
    echo "${setting_list}" | column -x -s'|' -t
    echo
    echo "Note: when using the form --SETTING VALUE, VALUE must not begin "
    echo "      with a hyphen."
    echo "Note: the \"--release\" option creates a pre-packaged combination"
    echo "      of settings used by the buildbot."
    echo
    echo "Cross-compiling Swift host tools"
    echo "  When building cross-compiled tools, it first builds for the native"
    echo "  build host machine. Then it proceeds to build the specified cross-compile"
    echo "  targets. It currently builds the requested variants of stdlib each"
    echo "  time around, so once for the native build, then again each time for"
    echo "  the cross-compile tool targets."
    echo
    echo "  When installing cross-compiled tools, it first installs each target"
    echo "  arch into a separate subdirectory under install-destdir, since you"
    echo "  can cross-compile for multiple targets at the same time. It then runs"
    echo "  recursive-lipo to produce fat binaries by merging the cross-compiled"
    echo "  targets, installing the merged result into the expected location of"
    echo "  install-destdir. After that, any remaining steps to extract dsyms and"
    echo "  create an installable package operates on install-destdir as normal."
}

# Scan all command-line arguments
while [[ "$1" ]] ; do
    case "$1" in
        -h | --help )
            usage
            exit
            ;;

        --* )
            dashless="${1:2}"

            # drop suffix beginning with the first "="
            setting="${dashless%%=*}"

            # compute the variable to set
            varname="$(to_varname "${setting}")"

            # check to see if this is a known option
            known_var_name="${varname}_IS_KNOWN_SETTING"
            if [[ ! "${!known_var_name}" ]] ; then
                echo "Error: Unknown setting: ${setting}" 1>&2
                usage 1>&2
                exit 1
            fi

            # find the intended value
            if [[ "${dashless}" == *=* ]] ; then              # if there's an '=', the value
                value="${dashless#*=}"                        #   is everything after the first '='
            elif [[ "$2" ]] && [[ "${2:0:1}" != "-" ]] ; then # else if the next parameter exists
                value="$2"                                    #   but isn't an option, use that
                shift
            else                                              # otherwise, the value is 1
                value=1
            fi

            # For explanation of backslash see http://stackoverflow.com/a/9715377
            eval ${varname}=$\value
            ;;

        *)
            echo "Error: Invalid argument: $1" 1>&2
            usage 1>&2
            exit 1
    esac
    shift
done

# TODO: Rename this argument
LOCAL_HOST=$HOST_TARGET

# TODO: Remove this some time later.
if [[ "${USER_CONFIG_ARGS}" ]]; then
    echo "Error: --user-config-args is renamed to --extra-cmake-options." 1>&2
    exit 1
fi

if [[ "${CHECK_ARGS_ONLY}" ]]; then
    exit 0
fi

# FIXME: We currently do not support building compiler-rt with the
# Xcode generator.
if [[ "${CMAKE_GENERATOR}" == "Xcode" ]]; then
    SKIP_COMPILER_RT=1
fi

# FIXME: We currently do not support cross-compiling swift with compiler-rt.
if [[ "${CROSS_COMPILE_HOSTS}" ]]; then
    SKIP_COMPILER_RT=1
fi

# WORKSPACE, BUILD_DIR and INSTALLABLE_PACKAGE must be absolute paths
case "${WORKSPACE}" in
    /*) ;;
    *)
        echo "workspace must be an absolute path (was '${WORKSPACE}')"
        exit 1
        ;;
esac
case "${BUILD_DIR}" in
    /*) ;;
    "")
        echo "the --build-dir option is required"
        usage
        exit 1
        ;;
    *)
        echo "build-dir must be an absolute path (was '${BUILD_DIR}')"
        exit 1
        ;;
esac
case "${INSTALLABLE_PACKAGE}" in
    /*) ;;
    "") ;;
    *)
        echo "installable-package must be an absolute path (was '${INSTALLABLE_PACKAGE}')"
        exit 1
        ;;
esac

# WORKSPACE must exist
if [ ! -e "${WORKSPACE}" ] ; then
    echo "Workspace does not exist (tried ${WORKSPACE})"
    exit 1
fi

# FIXME: HOST_CC and CMAKE are set, and their presence is validated by,
#        utils/build-script. These checks are redundant, but must remain until
#        build-script-impl is merged completely with utils/build-script.
#        For additional information, see: https://bugs.swift.org/browse/SR-237
if [ -z "${HOST_CC}" ] ; then
    echo "Can't find clang.  Please install clang-3.5 or a later version."
    exit 1
fi
if [ -z "${CMAKE}" ] ; then
    echo "Environment variable CMAKE must be specified."
    exit 1
fi

function xcrun_find_tool() {
  xcrun --sdk macosx --toolchain "${DARWIN_XCRUN_TOOLCHAIN}" --find "$@"
}

function not() {
    if [[ ! "$1" ]] ; then
        echo 1
    fi
}

function join { 
    local IFS="$1"; shift; echo "$*"; 
}

function false_true() {
    if [[ $(true_false "$1") = "TRUE" ]]; then
        echo "FALSE"
    else
        echo "TRUE"
    fi
}

function cmake_version() {
    echo $("${CMAKE}" --version | grep "cmake version" | cut -f 3 -d " ")
}

function cmake_needs_to_specify_standard_computed_defaults() {
    if [[ $(cmake_version) = "3.4.0" ]]; then
        echo "TRUE"
    else
        echo "FALSE"
    fi
}

function copy_swift_stdlib_tool_substitute() {
    if [ ! -f "$1" ] ; then
        echo "--- Copy swift-stdlib-tool ---"
        set -x
        cp "${SWIFT_SOURCE_DIR}/utils/swift-stdlib-tool-substitute" "$1"
        { set +x; } 2>/dev/null
    fi
}

function make_relative_symlink() {
    local SOURCE=$1
    local TARGET=$2
    local TARGET_DIR=$(dirname $2)
    local RELATIVE_SOURCE=$(python -c "import os.path; print(os.path.relpath(\""${SOURCE}"\", \""${TARGET_DIR}"\"))")
    ln -sf "${RELATIVE_SOURCE}" "${TARGET}"
}

# Sanitize the list of cross-compilation targets.
#
# In the Build/Host/Target paradigm:
# - "LOCAL_HOST" is Build (local machine running this script)
# - "CROSS_COMPILE_HOSTS" are the Hosts (implicitly includes LOCAL_HOST)
# - "STDLIB_DEPLOYMENT_TARGETS" are the Targets (for configuration)
# - "BUILD_STDLIB_DEPLOYMENT_TARGETS" are the Targets to build in this invocation

CROSS_COMPILE_HOSTS=($CROSS_COMPILE_HOSTS)
for t in ${CROSS_COMPILE_HOSTS} ; do
    case ${t} in
        iphone* | appletv* | watchos* | linux-armv6 | linux-armv7 )
            ;;
        *)
            echo "Unknown host to cross-compile for: ${t}"
            exit 1
            ;;
    esac
done

ALL_HOSTS=("${LOCAL_HOST}" "${CROSS_COMPILE_HOSTS[@]}")

function has_cross_compile_hosts() {
    if [[ ${#ALL_HOSTS[@]} -gt 1 ]]; then
        echo "1"
    fi
}

# We install in to host-specific directories when building more than one host.
# Other users will expect their products at INSTALL_DESTDIR.
function get_host_install_destdir() {
   local host="$1"

    if [[ $(has_cross_compile_hosts) ]]; then
        # If cross compiling tools, install into a host-specific subdirectory.
        if [[ $(should_include_host_in_lipo ${host}) ]]; then
            # If this is one of the hosts we should lipo, install in to a temporary subdirectory.
            local host_install_destdir="${BUILD_DIR}/intermediate-install/${host}"
        else
            local host_install_destdir="${INSTALL_DESTDIR}/${host}"
        fi
    else
        local host_install_destdir="${INSTALL_DESTDIR}"
    fi

    echo "${host_install_destdir}/" # Should always end in a '/'; it's a directory.
}

function splitSemicolonDelimitedInstallPrefixes() {
    local IFS=";"; CROSS_COMPILE_INSTALL_PREFIXES=($CROSS_COMPILE_INSTALL_PREFIXES)
}
splitSemicolonDelimitedInstallPrefixes

function get_host_install_prefix() {
    local host="$1"
   
    if [[ $(is_cross_tools_host ${host}) ]] && [[ ${#CROSS_COMPILE_INSTALL_PREFIXES[@]} -gt 0 ]]; then

        # Find the host's index in CROSS_COMPILE_HOSTS.
        for i in "${!CROSS_COMPILE_HOSTS[@]}"; do
           if [[ "${CROSS_COMPILE_HOSTS[$i]}" == "${host}" ]]; then
               local host_index=i
           fi
        done

        if [[ ${host_index} -lt ${#CROSS_COMPILE_INSTALL_PREFIXES[@]} ]]; then
            local host_install_prefix="${CROSS_COMPILE_INSTALL_PREFIXES[${host_index}]}"
        else
            # If there is no explicit install prefix for this host, use the last one
            # in the list.
            local host_install_prefix="${CROSS_COMPILE_INSTALL_PREFIXES[${#CROSS_COMPILE_INSTALL_PREFIXES[@]}-1]}"
        fi
    else
        local host_install_prefix="${INSTALL_PREFIX}"
    fi

    echo "${host_install_prefix}/" # Should always end in a '/'; it's a directory.
}

function is_cross_tools_host() {
    local host="$1"
    for t in "${CROSS_COMPILE_HOSTS[@]}" ; do
        if [ "${host}" == "${t}" ] ; then
            echo 1
        fi
    done
}

# When building cross-compilers for these hosts,
# merge all of their contents together with lipo
function should_include_host_in_lipo() {
    local host="$1"
    if [[ $(has_cross_compile_hosts) ]] && [[ -z "${SKIP_MERGE_LIPO_CROSS_COMPILE_TOOLS}" ]]; then
        case ${host} in 
            iphone* | appletv* | watchos* )
                echo 1
                ;;
        esac
    fi
}

function host_has_darwin_symbols() {
    local host="$1"
    case ${host} in 
        macosx* | iphone* | appletv* | watchos* )
            echo 1
            ;;
    esac
}

function get_stdlib_targets_for_host() {

# FIXME: STDLIB_DEPLOYMENT_TARGETS argument assumed to apply when Host == Build
# Cross-compile Hosts are only built with their native standard libraries.
# To fix this, we would need to pass in a list of stdlib targets _per host_,
# and the SWIFT_SDKS parameters would need to be able to capture both the SDK 
# and architecture of each stdlib target -- currently it only captures the SDK.
#
# We turn these targets in to SWIFT_SDKS in `calculate_targets_for_host()`
    
    if [[ $(is_cross_tools_host $1) ]] ; then
        echo "$1"
    else
        echo "${STDLIB_DEPLOYMENT_TARGETS[@]}"
    fi
}

function should_build_stdlib_target() {
    local stdlib_target=$1
    local host=$2

    if [[ "${BUILD_STDLIB_DEPLOYMENT_TARGETS}" == "all" ]]; then
        echo 1
    elif [[ "${BUILD_STDLIB_DEPLOYMENT_TARGETS}" == "none" ]]; then
        return
    else
        # Only build the stdlib targets in 'build-stdlib-deployment-targets'
        local build_list=($BUILD_STDLIB_DEPLOYMENT_TARGETS)
        for t in "${build_list[@]}"; do
            if [[ "${t}" == "${stdlib_target}" ]]; then
                echo 1
            fi
        done
        # As with 'stdlib-deployment-targets', 'build-stdlib-deployment-targets'
        # only applies to the LOCAL_HOST. For cross-tools hosts, always allow
        # their one-and-only stdlib-target to build.
        if [[ $(is_cross_tools_host ${host}) ]] && [[ "${stdlib_target}" == "${host}" ]]; then
            echo 1
        fi
    fi
}

function should_test_stdlib_target() {
    local stdlib_target=$1
    local host=$2

    if [[ "${TEST_STDLIB_DEPLOYMENT_TARGETS}" == "all" ]]; then
        echo 1
    elif [[ "${TEST_STDLIB_DEPLOYMENT_TARGETS}" == "none" ]]; then
        return
    else
        # Only test the stdlib targets in 'test-stdlib-deployment-targets'
        local test_list=($TEST_STDLIB_DEPLOYMENT_TARGETS)
        for t in "${test_list[@]}"; do
            if [[ "${t}" == "${stdlib_target}" ]]; then
                echo 1
            fi
        done
        # As with 'stdlib-deployment-targets', 'test-stdlib-deployment-targets'
        # only applies to the LOCAL_HOST. For cross-tools hosts, always test
        # their one-and-only stdlib-target.
        if [[ $(is_cross_tools_host ${host}) ]] && [[ "${stdlib_target}" == "${host}" ]]; then
            echo 1
        fi
    fi
}

#
# Calculate source directories for each product.
#
NINJA_SOURCE_DIR="${WORKSPACE}/ninja"
SWIFT_SOURCE_DIR="${WORKSPACE}/swift"
LLVM_SOURCE_DIR="${WORKSPACE}/llvm"
CMARK_SOURCE_DIR="${WORKSPACE}/cmark"
LLDB_SOURCE_DIR="${WORKSPACE}/lldb"
LLBUILD_SOURCE_DIR="${WORKSPACE}/llbuild"
SWIFTPM_SOURCE_DIR="${WORKSPACE}/swiftpm"
XCTEST_SOURCE_DIR="${WORKSPACE}/swift-corelibs-xctest"
FOUNDATION_SOURCE_DIR="${WORKSPACE}/swift-corelibs-foundation"
LIBDISPATCH_SOURCE_DIR="${WORKSPACE}/swift-corelibs-libdispatch"

if [[ ! -d ${CMARK_SOURCE_DIR} ]]; then
    echo "Couldn't find cmark source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_LLBUILD}" && ! -d ${LLBUILD_SOURCE_DIR} ]]; then
    echo "Couldn't find llbuild source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_SWIFTPM}" && ! -d ${SWIFTPM_SOURCE_DIR} ]]; then
    echo "Couldn't find swiftpm source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_XCTEST}" && ! -d ${XCTEST_SOURCE_DIR} ]]; then
    echo "Couldn't find XCTest source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_FOUNDATION}" && ! -d ${FOUNDATION_SOURCE_DIR} ]]; then
    echo "Couldn't find Foundation source directory."
    exit 1
fi

if [[ ! "${SKIP_BUILD_LIBDISPATCH}" && ! -d ${LIBDISPATCH_SOURCE_DIR} ]]; then
    echo "Couldn't find libdispatch source directory."
    exit 1
fi

# Symlink clang into the llvm tree.
CLANG_SOURCE_DIR="${LLVM_SOURCE_DIR}/tools/clang"
if [ ! -e "${WORKSPACE}/clang" ] ; then
    # If llvm/tools/clang is already a directory, use that and skip the symlink.
    if [ ! -d "${CLANG_SOURCE_DIR}" ] ; then
        echo "Can't find source directory for clang (tried ${WORKSPACE}/clang and ${CLANG_SOURCE_DIR})"
        exit 1
    fi
fi
if [ ! -d "${CLANG_SOURCE_DIR}" ] ; then
    make_relative_symlink "${WORKSPACE}/clang" "${CLANG_SOURCE_DIR}"
fi

# Symlink compiler-rt into the llvm tree, if it exists.
COMPILER_RT_SOURCE_DIR="${LLVM_SOURCE_DIR}/projects/compiler-rt"
if [ -e "${WORKSPACE}/compiler-rt" ] ; then
    if [ ! -d "${COMPILER_RT_SOURCE_DIR}" ] ; then
        make_relative_symlink "${WORKSPACE}/compiler-rt" "${COMPILER_RT_SOURCE_DIR}"
    fi
fi

PRODUCTS=(cmark llvm swift)
if [[ ! "${SKIP_BUILD_LLDB}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" lldb)
fi
if [[ ! "${SKIP_BUILD_LLBUILD}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" llbuild)
fi
if [[ ! "${SKIP_BUILD_LIBDISPATCH}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" libdispatch)
fi
# SwiftPM and XCTest are dependent on Foundation, so Foundation must be
# added to the list of build products first.
if [[ ! "${SKIP_BUILD_FOUNDATION}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" foundation)
fi
# SwiftPM is dependent on XCTest, so XCTest must be added to the list of
# build products first.
if [[ ! "${SKIP_BUILD_XCTEST}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" xctest)
fi
if [[ ! "${SKIP_BUILD_SWIFTPM}" ]] ; then
     PRODUCTS=("${PRODUCTS[@]}" swiftpm)
fi

function calculate_targets_for_host() {
    local host=$1
    
    SWIFT_STDLIB_TARGETS=()
    SWIFT_SDKS=()
    SWIFT_BENCHMARK_TARGETS=()
    SWIFT_RUN_BENCHMARK_TARGETS=()
    SWIFT_TEST_TARGETS=()

    # Get the list of Target platforms for the Host
    local stdlib_targets=(`echo $(get_stdlib_targets_for_host ${host})`)

    for stdlib_deployment_target in "${stdlib_targets[@]}"; do
        local swift_sdk=
        local is_in_build_list=$(should_build_stdlib_target ${stdlib_deployment_target} ${host})
        local is_in_test_list=$(should_test_stdlib_target ${stdlib_deployment_target} ${host})
        local test_host_only=
        local supports_benchmarks=

        case ${stdlib_deployment_target} in
            linux-*)
                swift_sdk="LINUX"
                ;;
            freebsd-*)
                swift_sdk="FREEBSD"
                ;;
            cygwin-*)
                swift_sdk="CYGWIN"
                ;;
            macosx-*)
                swift_sdk="OSX"
                supports_benchmarks=1
                ;;
            iphoneos-*)
                swift_sdk="IOS"
                if [[ "${is_in_test_list}" ]] ; then
                    test_host_only=1
                fi
                supports_benchmarks=1

                # Never build iOS armv7s benchmarks.
                if [[ "${stdlib_deployment_target}" == "iphoneos-armv7s" ]]; then
                    supports_benchmarks=
                fi
                ;;
            iphonesimulator-*)
                swift_sdk="IOS_SIMULATOR"
                ;;
            appletvos-*)
                swift_sdk="TVOS"
                if [[ "${is_in_test_list}" ]] ; then
                    test_host_only=1
                fi
                supports_benchmarks=1
                ;;
            appletvsimulator-*)
                swift_sdk="TVOS_SIMULATOR"
                ;;
            watchos-*)
                swift_sdk="WATCHOS"
                if [[ "${is_in_test_list}" ]] ; then
                    test_host_only=1
                fi
                supports_benchmarks=1
                ;;
            watchsimulator-*)
                swift_sdk="WATCHOS_SIMULATOR"
                ;;
            android-*)
                swift_sdk="ANDROID"
                ;;
            *)
                echo "Unknown compiler deployment target: ${stdlib_deployment_target}"
                exit 1
                ;;
        esac

        SWIFT_SDKS+=("${swift_sdk}")

        if [[ "${is_in_build_list}" ]]; then

            if [[ "${BUILD_SWIFT_STDLIB_UNITTEST_EXTRA}" == "1" ]] ; then
                SWIFT_STDLIB_TARGETS+=("swift-stdlib-${stdlib_deployment_target}")
            else
                if [[ "${VALIDATION_TEST}" == "1" || "${LONG_TEST}" == "1" ]] ; then
                    SWIFT_STDLIB_TARGETS+=("swift-stdlib-${stdlib_deployment_target}")
                else
                    SWIFT_STDLIB_TARGETS+=("swift-test-stdlib-${stdlib_deployment_target}")
                fi
            fi
            if [[ "${supports_benchmarks}" ]]; then
                SWIFT_BENCHMARK_TARGETS+=("swift-benchmark-${stdlib_deployment_target}")
                if [[ $(not ${SKIP_TEST_BENCHMARK}) ]] ; then
                  SWIFT_RUN_BENCHMARK_TARGETS+=("check-swift-benchmark-${stdlib_deployment_target}")
                fi
            fi
            if [[ "${is_in_test_list}" ]]; then
                test_target_suffix=""
                if [[ -n "${test_host_only}" ]] ; then
                    test_target_suffix="-non-executable"
                fi

                test_subset_target_suffix=""
                if [[ "${VALIDATION_TEST}" == "1" ]] ; then
                    if [[ "${LONG_TEST}" == "1" ]] ; then
                        test_subset_target_suffix="-all"
                    else
                        test_subset_target_suffix="-validation"
                    fi
                else
                    if [[ "${LONG_TEST}" == "1" ]] ; then
                        test_subset_target_suffix="-only_long"
                    fi
                fi
                SWIFT_TEST_TARGETS+=("check-swift${test_subset_target_suffix}${test_target_suffix}-${stdlib_deployment_target}")
                if [[ $(not ${SKIP_TEST_OPTIMIZED}) && ! -n "${test_host_only}" ]] ; then
                    SWIFT_TEST_TARGETS+=("check-swift${test_subset_target_suffix}-optimize-${stdlib_deployment_target}")
                fi
            fi
        fi
    done

    # Filter duplicate SWIFT_SDKs
    # We will get them if building for multiple architecture variants
    SWIFT_SDKS=(`echo "${SWIFT_SDKS[@]}" | tr " " "\n" | sort -u | tr "\n" " "`)
}


COMMON_C_FLAGS=""

# Convert to an array.
eval COMMON_CMAKE_OPTIONS=(${COMMON_CMAKE_OPTIONS})
eval EXTRA_CMAKE_OPTIONS=(${EXTRA_CMAKE_OPTIONS})
eval BUILD_ARGS=(${BUILD_ARGS})

if [[ "${CMAKE_GENERATOR}" == "Xcode" ]]; then
    BUILD_TARGET_FLAG="-target"
fi

function build_directory() {
    host=$1
    product=$2
    echo "${BUILD_DIR}/${product}-${host}"
}

function build_directory_bin() {
    host=$1
    product=$2
    root="$(build_directory ${host} ${product})"
    if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
        case ${product} in
            cmark)
                echo "${root}/${CMARK_BUILD_TYPE}/bin"
                ;;
            llvm)
                echo "${root}/${LLVM_BUILD_TYPE}/bin"
                ;;
            swift)
                echo "${root}/${SWIFT_BUILD_TYPE}/bin"
                ;;
            lldb)
                ;;
            llbuild)
                echo "${root}/${LLBUILD_BUILD_TYPE}/bin"
                ;;
            swiftpm)
                echo "${root}/${SWIFTPM_BUILD_TYPE}/bin"
                ;;
            xctest)
                echo "${root}/${XCTEST_BUILD_TYPE}/bin"
                ;;
            foundation)
                echo "${root}/${FOUNDATION_BUILD_TYPE}/bin"
                ;;
            libdispatch)
                echo "${root}/bin"
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac
    else
        echo "${root}/bin"
    fi
}

function is_cmake_release_build_type() {
    if [[ "$1" == "Release" || "$1" == "RelWithDebInfo" ]] ; then
        echo 1
    fi
}

function common_cross_c_flags() {
    echo -n "${COMMON_C_FLAGS}"

    case $1 in
        iphonesimulator-i386)
            echo "-arch i386 -mios-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphonesimulator-x86_64)
            echo "-arch x86_64 -mios-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphoneos-armv7)
            echo "-arch armv7 -miphoneos-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphoneos-armv7s)
            echo "-arch armv7s -miphoneos-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        iphoneos-arm64)
            echo "-arch arm64 -miphoneos-version-min=${DARWIN_DEPLOYMENT_VERSION_IOS}"
            ;;
        appletvsimulator-x86_64)
            echo "-arch x86_64 -mtvos-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_TVOS}"
            ;;
        appletvos-arm64)
            echo "-arch arm64 -mtvos-version-min=${DARWIN_DEPLOYMENT_VERSION_TVOS}"
            ;;
        watchsimulator-i386)
            echo "-arch i386 -mwatchos-simulator-version-min=${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
            ;;
        watchos-armv7k)
            echo "-arch armv7k -mwatchos-version-min=${DARWIN_DEPLOYMENT_VERSION_WATCHOS}"
            ;;
        android-armv7)
            echo "-arch armv7"
            ;;
    esac
}

function llvm_c_flags() {
    echo -n " $(common_cross_c_flags $1)"
    if [[ $(is_cmake_release_build_type "${LLVM_BUILD_TYPE}") ]] ; then
        echo -n " -fno-stack-protector"
    fi
    if [[ $(true_false "${LLVM_ENABLE_LTO}") = "TRUE" ]] ; then
        echo -n " -gline-tables-only"
    fi
}

function cmark_c_flags() {
    echo -n " $(common_cross_c_flags $1)"
    if [[ $(is_cmake_release_build_type "${CMARK_BUILD_TYPE}") ]] ; then
        echo -n " -fno-stack-protector"
    fi
}

function swift_c_flags() {
    # Don't pass common_cross_c_flags to Swift because CMake code in the Swift
    # project is itself aware of cross-compilation for the host tools and
    # standard library.
    echo -n "${COMMON_C_FLAGS}"
    if [[ $(is_cmake_release_build_type "${SWIFT_BUILD_TYPE}") ]] ; then
        echo -n " -fno-stack-protector"
    fi
}

function cmake_config_opt() {
    product=$1
    if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
        # CMake automatically adds --target ALL_BUILD if we don't pass this.
        echo "--target ZERO_CHECK "
        case ${product} in
            cmark)
                echo "--config ${CMARK_BUILD_TYPE}"
                ;;
            llvm)
                echo "--config ${LLVM_BUILD_TYPE}"
                ;;
            swift)
                echo "--config ${SWIFT_BUILD_TYPE}"
                ;;
            lldb)
                ;;
            llbuild)
                echo "--config ${LLBUILD_BUILD_TYPE}"
                ;;
            swiftpm)
                echo "--config ${SWIFTPM_BUILD_TYPE}"
                ;;
            xctest)
                echo "--config ${XCTEST_BUILD_TYPE}"
                ;;
            foundation)
                echo "--config ${FOUNDATION_BUILD_TYPE}"
                ;;            
            libdispatch)
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac
    fi
}

function set_swiftpm_bootstrap_command() {
    SWIFTC_BIN="$(build_directory_bin ${LOCAL_HOST} swift)/swiftc"
    LLBUILD_BIN="$(build_directory_bin ${LOCAL_HOST} llbuild)/swift-build-tool"
    if [[ ! "${SKIP_BUILD_FOUNDATION}" ]] ; then
        FOUNDATION_BUILD_DIR=$(build_directory ${host} foundation)
        if [[ ! "${SKIP_BUILD_XCTEST}" ]] ; then
            XCTEST_BUILD_DIR=$(build_directory ${host} xctest)
        fi
    fi
    if [ ! -e "${LLBUILD_BIN}" ]; then
        echo "Error: Cannot build swiftpm without llbuild (swift-build-tool)."
        exit 1
    fi
    swiftpm_bootstrap_command=("${SWIFTPM_SOURCE_DIR}/Utilities/bootstrap" "${swiftpm_bootstrap_options[@]}")
    if [[ "${VERBOSE_BUILD}" ]] ; then
        swiftpm_bootstrap_command+=(-v)
    fi
    # FIXME CROSSCOMPILING:
    # SwiftPM needs to be told about the target, sysroot and linker to use
    # when cross-compiling
    swiftpm_bootstrap_command+=(
        --swiftc="${SWIFTC_BIN}"
        --sbt="${LLBUILD_BIN}"
        --build="${build_dir}")
    if [[ ! "${SKIP_BUILD_FOUNDATION}" ]] ; then
        swiftpm_bootstrap_command+=(
            --foundation="${FOUNDATION_BUILD_DIR}/Foundation")
        if [[ ! "${SKIP_BUILD_XCTEST}" ]] ; then
            swiftpm_bootstrap_command+=(
                --xctest="${XCTEST_BUILD_DIR}")
        fi
    fi
}

#
# Configure and build each product
#
# Start with native deployment targets because the resulting tools are used during cross-compilation.

echo "=============================="
echo -e "Building the Swift compiler for: ${ALL_HOSTS[@]}"

for host in "${ALL_HOSTS[@]}"; do

    calculate_targets_for_host $host

    set_build_options_for_host $host

    # Print a summary of the calculated targets
    configured_targets=(`echo $(get_stdlib_targets_for_host ${host})`)
    echo "=============================="
    echo "* Host target: ${host}"
    echo "* Standard Library targets:"
    echo -e "    - Configured         [${#configured_targets[@]}]:\t ${configured_targets[@]}"
    echo -e "    - Build targets      [${#SWIFT_STDLIB_TARGETS[@]}]:\t ${SWIFT_STDLIB_TARGETS[@]}"
    echo -e "    - Benchmark targets  [${#SWIFT_BENCHMARK_TARGETS[@]}]:\t ${SWIFT_BENCHMARK_TARGETS[@]}"
    if [[ "${SWIFT_TEST_TARGETS[@]}" ]] && ! [[ "${SKIP_TEST_SWIFT}" ]]; then
    echo -e "* Running tests for      [${#SWIFT_TEST_TARGETS[@]}]:\t ${SWIFT_TEST_TARGETS[@]}"
    fi
    if ! [[ "${SKIP_TEST_BENCHMARKS}" ]] &&
       [[ "${SWIFT_RUN_BENCHMARK_TARGETS[@]}" ]] &&
       ! [[ "${SKIP_TEST_BENCHMARK}" ]]; then
    echo -e "* Running benchmarks for [${#SWIFT_RUN_BENCHMARK_TARGETS[@]}]:\t ${SWIFT_RUN_BENCHMARK_TARGETS[@]}"
    fi
    echo "=============================="

    case "${COMPILER_VENDOR}" in
        none)
            ;;
        apple)
            llvm_cmake_options=(
                "${llvm_cmake_options[@]}"
                -DCLANG_VENDOR=Apple
                -DCLANG_VENDOR_UTI=com.apple.compilers.llvm.clang
                -DPACKAGE_VERSION="${CLANG_USER_VISIBLE_VERSION}"
            )
            swift_cmake_options=(
                "${swift_cmake_options[@]}"
                -DSWIFT_VENDOR=Apple
                -DSWIFT_VENDOR_UTI=com.apple.compilers.llvm.swift
                -DSWIFT_VERSION="${SWIFT_USER_VISIBLE_VERSION}"
                -DSWIFT_COMPILER_VERSION="${SWIFT_COMPILER_VERSION}"
            )
            ;;
        *)
            echo "unknown compiler vendor"
            exit 1
            ;;
    esac

    llvm_cmake_options=(
        "${llvm_cmake_options[@]}"
        -DCMAKE_INSTALL_PREFIX:PATH="$(get_host_install_prefix ${host})"
        -DINTERNAL_INSTALL_PREFIX="local"
    )

    if [[ "${CLANG_COMPILER_VERSION}" ]] ; then
        llvm_cmake_options=(
            "${llvm_cmake_options[@]}"
            -DCLANG_REPOSITORY_STRING="clang-${CLANG_COMPILER_VERSION}"
        )
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DCLANG_COMPILER_VERSION="${CLANG_COMPILER_VERSION}"
            -DSWIFT_COMPILER_VERSION="${SWIFT_COMPILER_VERSION}"
        )
    fi
    if [[ "${SWIFT_COMPILER_VERSION}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_COMPILER_VERSION="${SWIFT_COMPILER_VERSION}"
        )
    fi
    if [[ "${DARWIN_TOOLCHAIN_VERSION}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DDARWIN_TOOLCHAIN_VERSION="${DARWIN_TOOLCHAIN_VERSION}"
        )
    fi

    if [[ "${ENABLE_ASAN}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_SOURCEKIT_USE_INPROC_LIBRARY:BOOL=TRUE
        )
    fi

    if [[ "${DARWIN_CRASH_REPORTER_CLIENT}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_RUNTIME_CRASH_REPORTER_CLIENT:BOOL=TRUE
        )
    fi

    swift_cmake_options=(
        "${swift_cmake_options[@]}"
        -DSWIFT_DARWIN_XCRUN_TOOLCHAIN:STRING="${DARWIN_XCRUN_TOOLCHAIN}"
    )

    if [[ "${DARWIN_STDLIB_INSTALL_NAME_DIR}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_DARWIN_STDLIB_INSTALL_NAME_DIR:STRING="${DARWIN_STDLIB_INSTALL_NAME_DIR}"
        )
    fi

    if [[ "${EXTRA_SWIFT_ARGS}" ]] ; then
        swift_cmake_options=(
            "${swift_cmake_options[@]}"
            -DSWIFT_EXPERIMENTAL_EXTRA_REGEXP_FLAGS="${EXTRA_SWIFT_ARGS}"
        )
    fi

    swift_cmake_options=(
        "${swift_cmake_options[@]}"
        -DSWIFT_AST_VERIFIER:BOOL=$(true_false "${SWIFT_ENABLE_AST_VERIFIER}")
        -DSWIFT_SIL_VERIFY_ALL:BOOL=$(true_false "${SIL_VERIFY_ALL}")
        -DSWIFT_RUNTIME_ENABLE_LEAK_CHECKER:BOOL=$(true_false "${SWIFT_RUNTIME_ENABLE_LEAK_CHECKER}")
    )

    for product in "${PRODUCTS[@]}"; do
        unset skip_build
        source_dir_var="$(toupper ${product})_SOURCE_DIR"
        source_dir=${!source_dir_var}
        build_dir=$(build_directory ${host} ${product})
        build_targets=(all)

        if [[ $(is_cross_tools_host ${host}) ]] ; then

            if [[ "${CROSS_COMPILE_WITH_HOST_TOOLS}" ]]; then
                # Optionally use the freshly-built host copy of clang to build
                # for foreign hosts.
                COMMON_CMAKE_OPTIONS+=(
                    -DCMAKE_C_COMPILER="$(build_directory ${LOCAL_HOST} llvm)/bin/clang"
                    -DCMAKE_CXX_COMPILER="$(build_directory ${LOCAL_HOST} llvm)/bin/clang++"
                )
            fi

            # CMake can't relink when using Ninja, but that's okay -
            # we don't need a build-local rpath because we can't run cross-compiled products
            if [[ "${CMAKE_GENERATOR}" == "Ninja" ]]; then
                COMMON_CMAKE_OPTIONS+=(
                    -DCMAKE_BUILD_WITH_INSTALL_RPATH="1"
                )
            fi
        fi
        
        cmake_options=("${COMMON_CMAKE_OPTIONS[@]}")

        # Add in gold linker support if requested.
        if [[ "${USE_GOLD_LINKER}" ]]; then
            echo "${product}: using gold linker"
            if [[ "${product}" != "swift" ]]; then
                # All other projects override the linker flags to add in
                # gold linker support.
                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_EXE_LINKER_FLAGS:STRING="-fuse-ld=gold"
                    -DCMAKE_SHARED_LINKER_FLAGS:STRING="-fuse-ld=gold"
                )
            fi
        else
            echo "${product}: using standard linker"
        fi

        llvm_build_dir=$(build_directory ${host} llvm)
        module_cache="${build_dir}/module-cache"

        case ${product} in
            cmark)
                cmake_options=(
                  "${cmake_options[@]}"
                  -DCMAKE_BUILD_TYPE:STRING="${LLVM_BUILD_TYPE}"
                  "${cmark_cmake_options[@]}"
                )
                skip_build=${SKIP_BUILD_CMARK}
                build_targets=(all)
                ;;

            llvm)
                if [ "${BUILD_LLVM}" == "0" ] ; then
                    build_targets=(clean)
                fi
                if [ "${SKIP_BUILD_LLVM}" ] ; then
                    # We can't skip the build completely because the standalone
                    # build of Swift depend on these.
                    build_targets=(llvm-config llvm-tblgen clang-headers)
                fi

                # Note: we set the variable:
                #
                # LLVM_TOOL_SWIFT_BUILD
                #
                # below because this script builds swift separately, and people
                # often have reasons to symlink the swift directory into
                # llvm/tools, e.g. to build LLDB.
                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_C_FLAGS="$(llvm_c_flags ${host})"
                    -DCMAKE_CXX_FLAGS="$(llvm_c_flags ${host})"
                    -DCMAKE_BUILD_TYPE:STRING="${LLVM_BUILD_TYPE}"
                    -DLLVM_ENABLE_ASSERTIONS:BOOL=$(true_false "${LLVM_ENABLE_ASSERTIONS}")
                    -DLLVM_TOOL_SWIFT_BUILD:BOOL=NO
                    -DLLVM_TARGETS_TO_BUILD="${LLVM_TARGETS_TO_BUILD}"
                    -DLLVM_INCLUDE_TESTS:BOOL=$(true_false "${SOURCE_TREE_INCLUDES_TESTS}")
                    -DLLVM_INCLUDE_DOCS:BOOL=TRUE
                    -DLLVM_ENABLE_LTO=$(true_false "${LLVM_ENABLE_LTO}")
                    "${llvm_cmake_options[@]}"
                )
                if [[ $(is_cross_tools_host ${host}) ]] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DLLVM_TABLEGEN=$(build_directory "${LOCAL_HOST}" llvm)/bin/llvm-tblgen
                        -DCLANG_TABLEGEN=$(build_directory "${LOCAL_HOST}" llvm)/bin/clang-tblgen
                        -DLLVM_NATIVE_BUILD=$(build_directory "${LOCAL_HOST}" llvm)
                    )
                fi

                ;;

            swift)

                cmake_options=("${COMMON_CMAKE_OPTIONS[@]}")
                if [[ "${USE_GOLD_LINKER}" ]]; then
                    # Swift will selectively use the gold linker on all
                    # parts except building the standard library.  We
                    # let the Swift cmake setup figure out how to apply
                    # that.
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_ENABLE_GOLD_LINKER=TRUE
                    )
                fi

                # Configure every cross-compiled stdlib-deployment-target.
                # That is, every stdlib-deployment-target where (Target != Host).

                configured_targets=(`echo $(get_stdlib_targets_for_host ${host})`)
                for stdlib_deployment_target in "${configured_targets[@]}"; do

                    # We don't need to configure host's sysroot/toolchain etc
                    if [[ "${stdlib_deployment_target}" == "${host}" ]]; then
                        continue
                    fi
                    if [[ ! "$(should_build_stdlib_target ${stdlib_deployment_target} ${host})" ]]; then
                        continue
                    fi

                    case ${stdlib_deployment_target} in
                        # We don't need to set up any variables to cross-compile the stdlib for Darwin targets.
                        # 'xcrun' will detect everything on the CMake side.
                        macosx-* | iphone* | appletv* | watch* )
                            continue
                            ;;
                        # android-armv7 is the only other cross-compilable stdlib target we support right now.
                        # Set sysroot/toolchain-related variables.
                        android-armv7)
                            cmake_options=(
                                "${cmake_options[@]}"
                                -DSWIFT_ANDROID_NDK_PATH:STRING="${ANDROID_NDK}"
                                -DSWIFT_ANDROID_NDK_GCC_VERSION:STRING="${ANDROID_NDK_GCC_VERSION}"
                                -DSWIFT_ANDROID_SDK_PATH:STRING="${ANDROID_NDK}/platforms/android-${ANDROID_API_LEVEL}/arch-arm"
                                -DSWIFT_ANDROID_ICU_UC:STRING="${ANDROID_ICU_UC}"
                                -DSWIFT_ANDROID_ICU_UC_INCLUDE:STRING="${ANDROID_ICU_UC_INCLUDE}"
                                -DSWIFT_ANDROID_ICU_I18N:STRING="${ANDROID_ICU_I18N}"
                                -DSWIFT_ANDROID_ICU_I18N_INCLUDE:STRING="${ANDROID_ICU_I18N_INCLUDE}"
                            )
                            ;;
                        *)
                            echo "Unsupported stdlib-deployment-target to cross-compile: ${stdlib_deployment_target}"
                            exit 1
                            ;;
                    esac
                done

                native_llvm_tools_path=""
                native_clang_tools_path=""
                native_swift_tools_path=""
                if [[ $(is_cross_tools_host ${host}) ]] ; then

                    # Don't build benchmarks and tests when building cross compiler.
                    build_perf_testsuite_this_time=false
                    build_tests_this_time=false

                    native_llvm_tools_path="$(build_directory "${LOCAL_HOST}" llvm)/bin"
                    native_clang_tools_path="$(build_directory "${LOCAL_HOST}" llvm)/bin"
                    native_swift_tools_path="$(build_directory "${LOCAL_HOST}" swift)/bin"

                    cmake_options=(
                        "${cmake_options[@]}"
                        -DLLVM_TOOLS_BINARY_DIR:PATH=$(build_directory ${host} llvm)/bin
                        -DLLVM_LIBRARY_DIR:PATH=$(build_directory ${host} llvm)/lib
                        -DLLVM_MAIN_INCLUDE_DIR:PATH=$(build_directory ${host} llvm)/include
                        -DLLVM_BINARY_DIR:PATH=$(build_directory ${host} llvm)
                        -DLLVM_MAIN_SRC_DIR:PATH="${LLVM_SOURCE_DIR}"
                    )
                else
                    build_perf_testsuite_this_time=$(true_false "$(not ${SKIP_BUILD_BENCHMARKS})")
                    build_tests_this_time=${SOURCE_TREE_INCLUDES_TESTS}
                fi

                # Command-line parameters override any autodetection that we
                # might have done.
                if [[ "${NATIVE_LLVM_TOOLS_PATH}" ]] ; then
                    native_llvm_tools_path="${NATIVE_LLVM_TOOLS_PATH}"
                fi
                if [[ "${NATIVE_CLANG_TOOLS_PATH}" ]] ; then
                    native_clang_tools_path="${NATIVE_CLANG_TOOLS_PATH}"
                fi
                if [[ "${NATIVE_SWIFT_TOOLS_PATH}" ]] ; then
                    native_swift_tools_path="${NATIVE_SWIFT_TOOLS_PATH}"
                fi

                if [ "${BUILD_LLVM}" == "0" ] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DLLVM_TOOLS_BINARY_DIR:PATH=/tmp/dummy
                        -DLLVM_LIBRARY_DIR:PATH="${build_dir}"
                        -DLLVM_MAIN_INCLUDE_DIR:PATH=/tmp/dummy
                        -DLLVM_BINARY_DIR:PATH=$(build_directory ${host} llvm)
                        -DLLVM_MAIN_SRC_DIR:PATH="${LLVM_SOURCE_DIR}"
                    )
                fi

                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_C_FLAGS="$(swift_c_flags ${host})"
                    -DCMAKE_CXX_FLAGS="$(swift_c_flags ${host})"
                    -DCMAKE_BUILD_TYPE:STRING="${SWIFT_BUILD_TYPE}"
                    -DLLVM_ENABLE_ASSERTIONS:BOOL=$(true_false "${SWIFT_ENABLE_ASSERTIONS}")
                    -DLLVM_ENABLE_LTO=$(true_false "${LLVM_ENABLE_LTO}")
                    -DSWIFT_ANALYZE_CODE_COVERAGE:STRING=$(toupper "${SWIFT_ANALYZE_CODE_COVERAGE}")
                    -DSWIFT_STDLIB_BUILD_TYPE:STRING="${SWIFT_STDLIB_BUILD_TYPE}"
                    -DSWIFT_STDLIB_ASSERTIONS:BOOL=$(true_false "${SWIFT_STDLIB_ENABLE_ASSERTIONS}")
                    -DSWIFT_STDLIB_ENABLE_RESILIENCE:BOOL=$(true_false "${SWIFT_STDLIB_ENABLE_RESILIENCE}")
                    -DSWIFT_STDLIB_SIL_SERIALIZE_ALL:BOOL=$(true_false "${SWIFT_STDLIB_SIL_SERIALIZE_ALL}")
                    -DSWIFT_NATIVE_LLVM_TOOLS_PATH:STRING="${native_llvm_tools_path}"
                    -DSWIFT_NATIVE_CLANG_TOOLS_PATH:STRING="${native_clang_tools_path}"
                    -DSWIFT_NATIVE_SWIFT_TOOLS_PATH:STRING="${native_swift_tools_path}"
                    -DSWIFT_BUILD_TOOLS:BOOL=$(true_false "${BUILD_SWIFT_TOOLS}")
                    -DSWIFT_BUILD_STDLIB:BOOL=$(true_false "${BUILD_SWIFT_STDLIB}")
                    -DSWIFT_SERIALIZE_STDLIB_UNITTEST:BOOL=$(true_false "${BUILD_SERIALIZED_STDLIB_UNITTEST}")
                    -DSWIFT_STDLIB_SIL_DEBUGGING:BOOL=$(true_false "${BUILD_SIL_DEBUGGING_STDLIB}")
                    -DSWIFT_CHECK_INCREMENTAL_COMPILATION:BOOL=$(true_false "${CHECK_INCREMENTAL_COMPILATION}")
                    -DSWIFT_BUILD_SDK_OVERLAY:BOOL=$(true_false "${BUILD_SWIFT_SDK_OVERLAY}")
                    -DSWIFT_BUILD_STATIC_STDLIB:BOOL=$(true_false "${BUILD_SWIFT_STATIC_STDLIB}")
                    -DSWIFT_BUILD_PERF_TESTSUITE:BOOL=$(true_false "${build_perf_testsuite_this_time}")
                    -DSWIFT_BUILD_EXAMPLES:BOOL=$(true_false "${BUILD_SWIFT_EXAMPLES}")
                    -DSWIFT_INCLUDE_TESTS:BOOL=$(true_false "${build_tests_this_time}")
                    -DSWIFT_INSTALL_COMPONENTS:STRING="${SWIFT_INSTALL_COMPONENTS}"
                    -DSWIFT_EMBED_BITCODE_SECTION:BOOL=$(true_false "${EMBED_BITCODE_SECTION}")
                    -DSWIFT_ENABLE_LTO:BOOL=$(true_false "${SWIFT_ENABLE_LTO}")
                    -DSWIFT_BUILD_RUNTIME_WITH_HOST_COMPILER:BOOL=$(true_false "${BUILD_RUNTIME_WITH_HOST_COMPILER}")
                    "${swift_cmake_options[@]}"
                )

                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_INSTALL_PREFIX:PATH="$(get_host_install_prefix ${host})"
                    -DLLVM_CONFIG:PATH="$(build_directory_bin ${host} llvm)/llvm-config"
                    -DSWIFT_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
                    -DSWIFT_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
                    -DSWIFT_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
                    -DSWIFT_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
                    -DSWIFT_PATH_TO_CMARK_SOURCE:PATH="${CMARK_SOURCE_DIR}"
                    -DSWIFT_PATH_TO_CMARK_BUILD:PATH="$(build_directory ${host} cmark)"
                )

                if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_CMARK_LIBRARY_DIR:PATH=$(build_directory ${host} cmark)/src/${CMARK_BUILD_TYPE}
                    )
                else
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_CMARK_LIBRARY_DIR:PATH=$(build_directory ${host} cmark)/src
                    )
                fi

                if [[ "${SWIFT_SDKS}" ]] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_SDKS:STRING="$(join ";" ${SWIFT_SDKS[@]})"
                    )
                fi
                if [[ "${SWIFT_PRIMARY_VARIANT_SDK}" ]] ; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_PRIMARY_VARIANT_SDK:STRING="${SWIFT_PRIMARY_VARIANT_SDK}"
                        -DSWIFT_PRIMARY_VARIANT_ARCH:STRING="${SWIFT_PRIMARY_VARIANT_ARCH}"
                    )
                fi

                build_targets=(all "${SWIFT_STDLIB_TARGETS[@]}")
                if [[ $(true_false "${build_perf_testsuite_this_time}") == "TRUE" ]]; then
                    native_swift_tools_path="$(build_directory_bin ${LOCAL_HOST} swift)"
                    cmake_options=(
                        "${cmake_options[@]}"
                        -DSWIFT_EXEC:STRING="${native_swift_tools_path}/swiftc"
                    )
                    build_targets=("${build_targets[@]}"
                                   "${SWIFT_BENCHMARK_TARGETS[@]}")
                fi

                skip_build=${SKIP_BUILD_SWIFT}
                ;;
            lldb)
                if [ ! -d "${LLDB_SOURCE_DIR}" ]; then
                    echo "error: lldb not found in ${LLDB_SOURCE_DIR}"
                    exit 1
                fi
                if [[ "${CMAKE_GENERATOR}" != "Ninja" ]] ; then
                    echo "error: lldb can only build with ninja"
                    exit 1
                fi
                cmark_build_dir=$(build_directory ${host} cmark)
                lldb_build_dir=$(build_directory ${host} lldb)
                swift_build_dir=$(build_directory ${host} swift)

                # Add any lldb extra cmake arguments here.
                if [ ! -z "${LLDB_EXTRA_CMAKE_ARGS}" ]; then
                    cmake_options=(
                        "${cmake_options[@]}"
                        ${LLDB_EXTRA_CMAKE_ARGS}
                        )
                fi

                # Figure out if we think this is a buildbot build.
                # This will influence the lldb version line.
                if [ ! -z "${JENKINS_HOME}" -a ! -z "${JOB_NAME}" -a ! -z "${BUILD_NUMBER}" ]; then
                    LLDB_IS_BUILDBOT_BUILD=1
                else
                    LLDB_IS_BUILDBOT_BUILD=0
                fi

                # Get the build date
                LLDB_BUILD_DATE=$(date +%Y-%m-%d)

                case "${host}" in
                    linux-*)
                        cmake_options=(
                            "${cmake_options[@]}"
                            -DCMAKE_BUILD_TYPE:STRING="${LLDB_BUILD_TYPE}"
                            -DCMAKE_INSTALL_PREFIX:PATH="$(get_host_install_prefix ${host})"
                            -DLLDB_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
                            -DLLDB_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
                            -DLLDB_PATH_TO_SWIFT_SOURCE:PATH="${SWIFT_SOURCE_DIR}"
                            -DLLDB_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_SWIFT_BUILD:PATH="${swift_build_dir}"
                            -DLLDB_PATH_TO_CMARK_BUILD:PATH="${cmark_build_dir}"
                            -DLLDB_PATH_TO_SWIFTC:PATH="$(build_directory ${LOCAL_HOST} swift)/bin/swiftc"
                            -DLLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            -DLLDB_BUILD_DATE:STRING="\"${LLDB_BUILD_DATE}\""
                            -DLLDB_ALLOW_STATIC_BINDINGS=1
                        )
                        ;;
                    freebsd-*)
                        cmake_options=(
                            "${cmake_options[@]}"
                            -DCMAKE_BUILD_TYPE:STRING="${LLDB_BUILD_TYPE}"
                            -DCMAKE_INSTALL_PREFIX:PATH="$(get_host_install_prefix ${host})"
                            -DLLDB_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
                            -DLLDB_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
                            -DLLDB_PATH_TO_SWIFT_SOURCE:PATH="${SWIFT_SOURCE_DIR}"
                            -DLLDB_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_SWIFT_BUILD:PATH="${swift_build_dir}"
                            -DLLDB_PATH_TO_CMARK_BUILD:PATH="${cmark_build_dir}"
                            -DLLDB_PATH_TO_SWIFTC:PATH="$(build_directory ${LOCAL_HOST} swift)/bin/swiftc"
                            -DLLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            -DLLDB_BUILD_DATE:STRING="\"${LLDB_BUILD_DATE}\""
                            -DLLDB_ALLOW_STATIC_BINDINGS=1
                        )
                        ;;
                    cygwin-*)
                        cmake_options=(
                            "${cmake_options[@]}"
                            -DCMAKE_BUILD_TYPE:STRING="${LLDB_BUILD_TYPE}"
                            -DCMAKE_INSTALL_PREFIX:PATH="$(get_host_install_prefix ${host})"
                            -DLLDB_PATH_TO_LLVM_SOURCE:PATH="${LLVM_SOURCE_DIR}"
                            -DLLDB_PATH_TO_CLANG_SOURCE:PATH="${CLANG_SOURCE_DIR}"
                            -DLLDB_PATH_TO_SWIFT_SOURCE:PATH="${SWIFT_SOURCE_DIR}"
                            -DLLDB_PATH_TO_LLVM_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_CLANG_BUILD:PATH="${llvm_build_dir}"
                            -DLLDB_PATH_TO_SWIFT_BUILD:PATH="${swift_build_dir}"
                            -DLLDB_PATH_TO_CMARK_BUILD:PATH="${cmark_build_dir}"
                            -DLLDB_PATH_TO_SWIFTC:PATH="$(build_directory ${LOCAL_HOST} swift)/bin/swiftc"
                            -DLLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            -DLLDB_BUILD_DATE:STRING="\"${LLDB_BUILD_DATE}\""
                            -DLLDB_ALLOW_STATIC_BINDINGS=1
                        )
                        ;;
                    macosx-*)
                        # Set up flags to pass to xcodebuild
                        lldb_xcodebuild_options=(
                            LLDB_PATH_TO_LLVM_SOURCE="${LLVM_SOURCE_DIR}"
                            LLDB_PATH_TO_CLANG_SOURCE="${CLANG_SOURCE_DIR}"
                            LLDB_PATH_TO_SWIFT_SOURCE="${SWIFT_SOURCE_DIR}"
                            LLDB_PATH_TO_LLVM_BUILD="${llvm_build_dir}"
                            LLDB_PATH_TO_CLANG_BUILD="${llvm_build_dir}"
                            LLDB_PATH_TO_SWIFT_BUILD="${swift_build_dir}"
                            LLDB_PATH_TO_CMARK_BUILD="${cmark_build_dir}"
                            LLDB_PATH_TO_SWIFTC="$(build_directory ${LOCAL_HOST} swift)/bin/swiftc"
                            LLDB_IS_BUILDBOT_BUILD="${LLDB_IS_BUILDBOT_BUILD}"
                            LLDB_BUILD_DATE="\"${LLDB_BUILD_DATE}\""
                            SYMROOT="${lldb_build_dir}"
                            OBJROOT="${lldb_build_dir}"
                            ${LLDB_EXTRA_XCODEBUILD_ARGS}
                        )
                        if [[ "${LLDB_NO_DEBUGSERVER}" ]] ; then
                            lldb_xcodebuild_options=(
                                "${lldb_xcodebuild_options[@]}"
                                DEBUGSERVER_DISABLE_CODESIGN="1"
                                DEBUGSERVER_DELETE_AFTER_BUILD="1"
                            )
                        fi
                        if [[ "${LLDB_USE_SYSTEM_DEBUGSERVER}" ]] ; then
                            lldb_xcodebuild_options=(
                                "${lldb_xcodebuild_options[@]}"
                                DEBUGSERVER_USE_FROM_SYSTEM="1"
                            )
                        fi
                        set_lldb_build_mode
                        pushd ${source_dir}
                        xcodebuild -target desktop -configuration ${LLDB_BUILD_MODE} ${lldb_xcodebuild_options[@]}
                        popd
                        continue
                        ;;
                esac
                ;;
            llbuild)
                cmake_options=(
                    "${cmake_options[@]}"
                    -DCMAKE_INSTALL_PREFIX:PATH="$(get_host_install_prefix ${host})"
                    -DLIT_EXECUTABLE:PATH="${LLVM_SOURCE_DIR}/utils/lit/lit.py"
                    -DFILECHECK_EXECUTABLE:PATH="$(build_directory_bin ${LOCAL_HOST} llvm)/FileCheck"
                    -DCMAKE_BUILD_TYPE:STRING="${LLBUILD_BUILD_TYPE}"
                    -DLLVM_ENABLE_ASSERTIONS:BOOL=$(true_false "${LLBUILD_ENABLE_ASSERTIONS}")
                    # We disable all bindings, since llbuild builds before Swift
                    # and can't use the unbuilt `swiftc`.
                    -DLLBUILD_SUPPORT_BINDINGS:=
                )
                ;;
            swiftpm)
                set_swiftpm_bootstrap_command
                set -x
                "${swiftpm_bootstrap_command[@]}"
                { set +x; } 2>/dev/null
                
                # swiftpm installs itself with a bootstrap method. No further cmake building is performed.
                continue
                ;;
            xctest)
                SWIFTC_BIN="$(build_directory_bin ${LOCAL_HOST} swift)/swiftc"
                XCTEST_BUILD_DIR=$(build_directory ${host} xctest)
                FOUNDATION_BUILD_DIR=$(build_directory ${host} foundation)
                if [[ "$(uname -s)" == "Darwin" ]] ; then
                    # xcodebuild requires swift-stdlib-tool to build a Swift
                    # framework. This is normally present when building XCTest
                    # via a packaged .xctoolchain, but here we are using the
                    # swiftc that was just built--no toolchain exists yet. As a
                    # result, we must copy swift-stdlib-tool ourselves.
                    copy_swift_stdlib_tool_substitute "$(build_directory_bin ${host} swift)/swift-stdlib-tool"
                fi

                set -x
                # FIXME: Use XCTEST_BUILD_TYPE (which is never properly
                #        set) to build either --debug or --release.
                "${XCTEST_SOURCE_DIR}"/build_script.py \
                    --swiftc="${SWIFTC_BIN}" \
                    --build-dir="${XCTEST_BUILD_DIR}" \
                    --foundation-build-dir="${FOUNDATION_BUILD_DIR}/Foundation"
                { set +x; } 2>/dev/null

                # XCTest builds itself and doesn't rely on cmake
                continue
                ;;
            foundation)
                # The configuration script requires knowing about XCTest's
                # location for building and running the tests. Note that XCTest
                # is not yet built at this point.
                XCTEST_BUILD_DIR=$(build_directory ${host} xctest)
                SWIFTC_BIN="$(build_directory_bin ${LOCAL_HOST} swift)/swiftc"
                SWIFT_BIN="$(build_directory_bin ${LOCAL_HOST} swift)/swift"
                SWIFT_BUILD_PATH="$(build_directory ${host} swift)"
                LLVM_BIN="$(build_directory_bin ${LOCAL_HOST} llvm)"

                # Staging: require opt-in for building with dispatch
                if [[ ! "${SKIP_BUILD_LIBDISPATCH}" ]] ; then
                    LIBDISPATCH_BUILD_DIR="$(build_directory ${host} libdispatch)"
                    LIBDISPATCH_BUILD_ARGS="-DLIBDISPATCH_SOURCE_DIR=${LIBDISPATCH_SOURCE_DIR} -DLIBDISPATCH_BUILD_DIR=${LIBDISPATCH_BUILD_DIR}"
                fi

                if [[ "${USE_GOLD_LINKER}" ]]; then
                    SWIFT_USE_LINKER="-fuse-ld=gold"
                fi

                # FIXME CROSSCOMPILING: 
                # Foundation is a target library (like the Swift standard library),
                # so technically we should build it for all stdlib_targets, not just for the host.
                # However, we only have the triple and sysroot for the host.
                # Also, we will need to tell it which linker to use.
                FOUNDATION_BUILD_ARGS=()
                if [[ $(is_cross_tools_host ${host}) ]]; then
                    FOUNDATION_BUILD_ARGS+=(
                        "--target=${SWIFT_HOST_TRIPLE}"
                    )
                fi

                # FIXME: Foundation doesn't build from the script on OSX
                if [[ ${host} == "macosx"* ]]; then
                    echo "Skipping Foundation on OSX -- use the XCode project instead"
                    continue
                fi
    
                set -x
                pushd "${FOUNDATION_SOURCE_DIR}"
                SWIFTC="${SWIFTC_BIN}" CLANG="${LLVM_BIN}"/clang SWIFT="${SWIFT_BIN}" \
                      SDKROOT="${SWIFT_BUILD_PATH}" BUILD_DIR="${build_dir}" DSTROOT="$(get_host_install_destdir ${host})" PREFIX="$(get_host_install_prefix ${host})" ./configure "${FOUNDATION_BUILD_TYPE}" ${FOUNDATION_BUILD_ARGS[@]} -DXCTEST_BUILD_DIR=${XCTEST_BUILD_DIR} $LIBDISPATCH_BUILD_ARGS
                ${NINJA_BIN}
                popd
                { set +x; } 2>/dev/null

                # Foundation builds itself and doesn't use cmake
                continue
                ;;
            libdispatch)
                LIBDISPATCH_BUILD_DIR=$(build_directory ${host} ${product})
                SWIFT_BUILD_PATH="$(build_directory ${host} swift)"

                set -x
                if [[ ! -f "${LIBDISPATCH_BUILD_DIR}"/config.status ]]; then
                    # First time building; need to run autotools and configure
                    mkdir -p "${LIBDISPATCH_BUILD_DIR}"
                    pushd "${LIBDISPATCH_SOURCE_DIR}"
                    autoreconf -fvi
                    popd
                    pushd "${LIBDISPATCH_BUILD_DIR}"
                    "${LIBDISPATCH_SOURCE_DIR}"/configure --prefix="$(get_host_install_destdir ${host})$(get_host_install_prefix ${host})" --with-swift-toolchain="${SWIFT_BUILD_PATH}"
                    popd
                fi
                pushd "${LIBDISPATCH_BUILD_DIR}"
                make
                cd tests
                make build-tests
                popd
                { set +x; } 2>/dev/null

                # libdispatch builds itself and doesn't use cmake
                continue
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac

        # Clean the product-local module cache.
        rm -rf "${module_cache}"
        mkdir -p "${module_cache}"

        # Compute the generator output file to check for, to determine if we
        # must reconfigure. We only handle Ninja for now.
        #
        # This is important for ensuring that if a CMake configuration fails in
        # CI, that we will still be willing to rerun the configuration process.
        generator_output_path=""
        if [[ "${CMAKE_GENERATOR}" == "Ninja" ]] ; then
            generator_output_path="${build_dir}/build.ninja"
        fi

        # Configure if necessary.
        cmake_cache_path="${build_dir}/CMakeCache.txt"
        if [[  "${RECONFIGURE}" || ! -f "${cmake_cache_path}" || \
                    ( ! -z "${generator_output_path}" && ! -f "${generator_output_path}" ) ]] ; then
            set -x
            mkdir -p "${build_dir}"
            if [[ -n "${DISTCC}" ]]; then
                EXTRA_DISTCC_OPTIONS=("DISTCC_HOSTS=localhost,lzo,cpp")
            fi
            (cd "${build_dir}" && env "${EXTRA_DISTCC_OPTIONS[@]}" "${CMAKE}" "${cmake_options[@]}" "${EXTRA_CMAKE_OPTIONS[@]}" "${source_dir}")
            { set +x; } 2>/dev/null
        fi

        # When we are building LLVM create symlinks to the c++ headers. We need
        # to do this before building LLVM since compiler-rt depends on being
        # built with the just built clang compiler. These are normally put into
        # place during the cmake step of LLVM's build when libcxx is in
        # tree... but we are not building llvm with libcxx in tree when we build
        # swift. So we need to do configure's work here.
        if [[ "${product}" == "llvm" ]]; then
            # Find the location of the c++ header dir.
            if [[ "$(uname -s)" == "Darwin" ]] ; then
              HOST_CXX_DIR=$(dirname ${HOST_CXX})
              HOST_CXX_HEADERS_DIR="$HOST_CXX_DIR/../../usr/include/c++"
            else # Linux
              HOST_CXX_HEADERS_DIR="/usr/include/c++"
            fi

            # Find the path in which the local clang build is expecting to find
            # the c++ header files.
            BUILT_CXX_INCLUDE_DIR="$llvm_build_dir/include"

            echo "symlinking the system headers ($HOST_CXX_HEADERS_DIR) into the local clang build directory ($BUILT_CXX_INCLUDE_DIR)."
            set -x
            ln -s -f "$HOST_CXX_HEADERS_DIR" "$BUILT_CXX_INCLUDE_DIR"
            { set +x; } 2>/dev/null
        fi

        # Build.
        if [[ ! "${skip_build}" ]]; then
            if [[ "${CMAKE_GENERATOR}" == "Xcode" ]] ; then
                # Xcode generator uses "ALL_BUILD" instead of "all".
                # Also, xcodebuild uses -target instead of bare names.
                build_targets=("${build_targets[@]/all/ALL_BUILD}")
                build_targets=("${build_targets[@]/#/${BUILD_TARGET_FLAG} }")

                # Xcode can't restart itself if it turns out we need to reconfigure.
                # Do an advance build to handle that.
                set -x
                ${DISTCC_PUMP} "${CMAKE}" --build "${build_dir}" $(cmake_config_opt ${product})
                { set +x; } 2>/dev/null
            fi

            set -x
            ${DISTCC_PUMP} "${CMAKE}" --build "${build_dir}" $(cmake_config_opt ${product}) -- "${BUILD_ARGS[@]}" ${build_targets[@]}
            { set +x; } 2>/dev/null
        fi
    done
done
# END OF BUILD PHASE


# Trap function to print the current test configuration when tests fail.
# This is a function so the text is not unnecessarily displayed when running -x.
tests_busted ()
{
    echo "*** Failed while running tests for $1 $2"
}

for host in "${ALL_HOSTS[@]}"; do

    # Calculate test targets
    calculate_targets_for_host $host

    # Run the tests for each product
    for product in "${PRODUCTS[@]}"; do
        case ${product} in
            cmark)
                if [[ "${SKIP_TEST_CMARK}" ]]; then
                    continue
                fi
                executable_target=api_test
                results_targets=(test)
                if [[ "${CMAKE_GENERATOR}" == "Xcode" ]]; then
                    # Xcode generator uses "RUN_TESTS" instead of "test".
                    results_targets=(RUN_TESTS)
                fi
                ;;
            llvm)
                continue # We don't test LLVM
                ;;
            swift)
                executable_target=
                results_targets=
                if ! [[ "${SKIP_TEST_SWIFT}" ]]; then
                    executable_target=SwiftUnitTests
                    results_targets=("${SWIFT_TEST_TARGETS[@]}")
                    if [[ "${STRESS_TEST_SOURCEKIT}" ]]; then
                        results_targets=(
                            "${results_targets[@]}"
                            stress-SourceKit
                        )
                    fi
                fi
                if ! [[ "${SKIP_TEST_BENCHMARKS}" ]]; then
                    results_targets=(
                        "${results_targets[@]}"
                        "${SWIFT_RUN_BENCHMARK_TARGETS[@]}"
                    )
                fi
                if [[ -z "${results_targets[@]}" ]]; then
                    continue
                fi
                ;;
            lldb)
                if [[ "${SKIP_TEST_LLDB}" ]]; then
                    continue
                fi
                lldb_build_dir=$(build_directory ${host} lldb)
                swift_build_dir=$(build_directory ${host} swift)
                # Setup lldb executable path
                if [[ "$(uname -s)" == "Darwin" ]] ; then
                    lldb_executable="${lldb_build_dir}"/${LLDB_BUILD_MODE}/lldb
                else
                    lldb_executable="${lldb_build_dir}"/bin/lldb
                fi

                results_dir="${lldb_build_dir}/test-results"
                mkdir -p "${results_dir}"
                pushd "${results_dir}"

                # Handle test results formatter
                if [[ "${LLDB_TEST_WITH_CURSES}" ]]; then
                    # Setup the curses results formatter.
                    LLDB_FORMATTER_OPTS="\
                                       --results-formatter lldbsuite.test_event.formatter.curses.Curses \
                                       --results-file /dev/stdout"
                else
                    LLDB_FORMATTER_OPTS="\
                                       --results-formatter lldbsuite.test_event.formatter.xunit.XunitFormatter \
                                       --results-file ${results_dir}/results.xml \
                                       -O--xpass=ignore"
                    # Setup the xUnit results formatter.
                    if [[ "$(uname -s)" != "Darwin" ]] ; then
                        # On non-Darwin, we ignore skipped tests entirely
                        # so that they don't pollute our xUnit results with
                        # non-actionable content.
                        LLDB_FORMATTER_OPTS="${LLDB_FORMATTER_OPTS} -O-ndsym -O-rdebugserver -O-rlibc\\\\+\\\\+ -O-rlong.running -O-rbenchmarks -O-rrequires.one?.of.darwin"
                    fi
                fi

                # figure out which C/C++ compiler we should use for building test inferiors.
                if [[ "${LLDB_TEST_CC}" == "host-toolchain" ]]; then
                    # Use the host toolchain: i.e. the toolchain specified by HOST_CC
                    LLDB_DOTEST_CC_OPTS="-C ${HOST_CC}"
                elif [[ -n "${LLDB_TEST_CC}" ]]; then
                    # Use exactly the compiler path specified by the user.
                    LLDB_DOTEST_CC_OPTS="-C ${LLDB_TEST_CC}"
                else
                    # Use the clang that was just built in the tree.
                    LLDB_DOTEST_CC_OPTS="-C $(build_directory $LOCAL_HOST llvm)"/bin/clang
                fi
                
                SWIFTCC="$(build_directory $LOCAL_HOST swift)/bin/swiftc" SWIFTLIBS="${swift_build_dir}/lib/swift" "${LLDB_SOURCE_DIR}"/test/dotest.py --executable "${lldb_executable}" --rerun-all-issues ${LLDB_DOTEST_CC_OPTS} ${LLDB_FORMATTER_OPTS}
                popd
                continue
                ;;
            llbuild)
                if [[ "${SKIP_TEST_LLBUILD}" ]]; then
                    continue
                fi
                results_targets=("test")
                executable_target=""
                ;;
            swiftpm)
                if [[ "${SKIP_TEST_SWIFTPM}" ]]; then
                    continue
                fi
                echo "--- Running tests for ${product} ---"
                set -x
                "${swiftpm_bootstrap_command[@]}" test
                { set +x; } 2>/dev/null
                # As swiftpm tests itself, we break early here.
                continue
                ;;
            xctest)
                if [[ "${SKIP_TEST_XCTEST}" ]]; then
                    continue
                fi
                echo "--- Running tests for ${product} ---"
                SWIFTC_BIN="$(build_directory_bin ${LOCAL_HOST} swift)/swiftc"
                FOUNDATION_BUILD_DIR=$(build_directory ${host} foundation)
                XCTEST_BUILD_DIR=$(build_directory ${host} xctest)
                set -x
                "${XCTEST_SOURCE_DIR}"/build_script.py test \
                    --swiftc="${SWIFTC_BIN}" \
                    --foundation-build-dir="${FOUNDATION_BUILD_DIR}/Foundation" \
                    "${XCTEST_BUILD_DIR}"
                { set +x; } 2>/dev/null
                echo "--- Finished tests for ${product} ---"
                continue
                ;;
            foundation)
                # FIXME: Foundation doesn't build from the script on OSX
                if [[ ${host} == "macosx"* ]]; then
                    echo "Skipping Foundation on OSX -- use the XCode project instead"
                    continue
                fi
                if [[ "${SKIP_TEST_FOUNDATION}" ]]; then
                    continue
                fi
                echo "--- Running tests for ${product} ---"
                set -x
                build_dir=$(build_directory ${host} ${product})
                XCTEST_BUILD_DIR=$(build_directory ${host} xctest)
                pushd "${FOUNDATION_SOURCE_DIR}"
                ${NINJA_BIN} TestFoundation
                LD_LIBRARY_PATH="$(get_host_install_destdir ${host})$(get_host_install_prefix ${host})"/lib/swift/:"${build_dir}/Foundation":"${XCTEST_BUILD_DIR}":${LD_LIBRARY_PATH} "${build_dir}"/TestFoundation/TestFoundation
                popd
                { set +x; } 2>/dev/null
                echo "--- Finished tests for ${product} ---"
                continue
                ;;
            libdispatch)
                if [[ "${SKIP_TEST_LIBDISPATCH}" ]]; then
                    continue
                fi
                LIBDISPATCH_BUILD_DIR=$(build_directory ${host} ${product})
                echo "--- Running tests for ${product} ---"
                set -x
                pushd "${LIBDISPATCH_BUILD_DIR}"
                make check
                popd
                { set +x; } 2>/dev/null
                echo "--- Finished tests for ${product} ---"
                continue
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac

        trap "tests_busted ${product} ''" ERR
        build_dir=$(build_directory ${host} ${product})
        build_cmd=("${CMAKE}" --build "${build_dir}" $(cmake_config_opt ${product}) -- ${BUILD_ARGS})

        if [[ "${executable_target}" != "" ]]; then
            echo "--- Building tests for ${product} ---"
            set -x
            ${DISTCC_PUMP} "${build_cmd[@]}" ${BUILD_TARGET_FLAG} "${executable_target}"
            { set +x; } 2>/dev/null
        fi

        # We can only run tests built for the host machine, because
        # cross-compiled hosts only build their native target. See: get_stdlib_targets_for_host()
        if [[ $(is_cross_tools_host ${host}) ]]; then
            echo "--- Can't execute tests for ${host}, skipping... ---"
            continue
        fi

        echo "--- Running tests for ${product} ---"
        for target in "${results_targets[@]}"; do
            if [[ "${target}" != "" ]]; then
                echo "--- ${target} ---"
                trap "tests_busted ${product} '(${target})'" ERR
                if [[ "${CMAKE_GENERATOR}" == Ninja ]] && !( "${build_cmd[@]}" --version 2>&1 | grep -i -q llbuild ); then
                    # Ninja buffers command output to avoid scrambling the output
                    # of parallel jobs, which is awesome... except that it
                    # interferes with the progress meter when testing.  Instead of
                    # executing ninja directly, have it dump the commands it would
                    # run, strip Ninja's progress prefix with sed, and tell the
                    # shell to execute that.
                    sh -e -x -c "$("${build_cmd[@]}" -n -v ${target} | sed -e 's/[^]]*] //')"
                else
                    set -x
                    "${build_cmd[@]}" ${BUILD_TARGET_FLAG} ${target}
                    { set +x; } 2>/dev/null
                fi
                echo "-- ${target} finished --"
            fi
        done

        trap - ERR
        echo "--- Finished tests for ${product} ---"
    done
done
# END OF TEST PHASE


LIPO_SRC_DIRS=()

for host in "${ALL_HOSTS[@]}"; do

    # Calculate the directory to install products in to.
    host_install_destdir=$(get_host_install_destdir ${host})
    host_install_prefix=$(get_host_install_prefix ${host})
    
    if [[ $(should_include_host_in_lipo ${host}) ]]; then
        LIPO_SRC_DIRS+=( "${host_install_destdir}" )
    fi

    # Set the build options for this host
    set_build_options_for_host $host

    for product in "${PRODUCTS[@]}"; do

        INSTALL_TARGETS="install"

        case ${product} in
            cmark)
                if [[ -z "${INSTALL_CMARK}" ]] ; then
                    continue
                fi
                ;;
            llvm)
                if [[ -z "${LLVM_INSTALL_COMPONENTS}" ]] ; then
                    continue
                fi
                INSTALL_TARGETS=install-$(echo ${LLVM_INSTALL_COMPONENTS} | sed -E 's/;/ install-/g')
                ;;
            swift)
                if [[ -z "${INSTALL_SWIFT}" ]] ; then
                    continue
                fi
                ;;
            llbuild)
                if [[ -z "${INSTALL_LLBUILD}" ]] ; then
                    continue
                fi
                INSTALL_TARGETS=install-swift-build-tool
                ;;
            # Products from this here install themselves; they don't fall-through.
            lldb)
                if [[ -z "${INSTALL_LLDB}" ]] ; then
                    continue
                fi
                if [[ -z "${INSTALL_DESTDIR}" ]] ; then
                    echo "--install-destdir is required to install products."
                    exit 1
                fi

                case ${host} in
                    linux-*)
                        ;;
                    freebsd-*)
                        ;;
                    cygwin-*)
                        ;;
                    macosx-*)
                        set_lldb_build_mode
                        pushd ${LLDB_SOURCE_DIR}
                        xcodebuild -target toolchain -configuration ${LLDB_BUILD_MODE} install ${lldb_xcodebuild_options[@]} DSTROOT="${host_install_destdir}" LLDB_TOOLCHAIN_PREFIX="${TOOLCHAIN_PREFIX}"
                        popd
                        continue
                        ;;
                esac
                ;;
            swiftpm)
                if [[ -z "${INSTALL_SWIFTPM}" ]] ; then
                    continue
                fi
                if [[ -z "${INSTALL_DESTDIR}" ]] ; then
                    echo "--install-destdir is required to install products."
                    exit 1
                fi

                echo "--- Installing ${product} ---"
                set -x
                "${swiftpm_bootstrap_command[@]}" --prefix="${host_install_destdir}${host_install_prefix}" install
                { set +x; } 2>/dev/null
                # As swiftpm bootstraps the installation itself, we break early here.
                continue
                ;;
            xctest)
                if [[ -z "${INSTALL_XCTEST}" ]] ; then
                    continue
                fi
                if [[ -z "${INSTALL_DESTDIR}" ]] ; then
                    echo "--install-destdir is required to install products."
                    exit 1
                fi

                case ${host} in
                    linux-*)
                        LIB_TARGET="linux"
                        ;;
                    freebsd-*)
                        LIB_TARGET="freebsd"
                        ;;
                    cygwin-*)
                        LIB_TARGET="windows"
                        ;;
                    *)
                        echo "error: --install-xctest is not supported on this platform"
                        exit 1
                        ;;
                esac

                echo "--- Installing ${product} ---"
                XCTEST_BUILD_DIR=$(build_directory ${host} xctest)
                XCTEST_INSTALL_PREFIX="${host_install_destdir}${host_install_prefix}/lib/swift/${LIB_TARGET}"
                # Note that installing directly to /usr/lib/swift usually
                # requires root permissions.
                set -x
                "${XCTEST_SOURCE_DIR}"/build_script.py install \
                    --library-install-path="${XCTEST_INSTALL_PREFIX}" \
                    --module-install-path="${XCTEST_INSTALL_PREFIX}"/"${SWIFT_HOST_VARIANT_ARCH}" \
                    "${XCTEST_BUILD_DIR}"
                { set +x; } 2>/dev/null

                # As XCTest installation is self-contained, we break early here.
                continue
                ;;
            foundation)
                # FIXME: Foundation doesn't build from the script on OSX
                if [[ ${host} == "macosx"* ]]; then
                    echo "Skipping Foundation on OSX -- use the XCode project instead"
                    continue
                fi
                if [[ -z "${INSTALL_FOUNDATION}" ]] ; then
                    continue
                fi
                if [[ -z "${INSTALL_DESTDIR}" ]] ; then
                    echo "--install-destdir is required to install products."
                    exit 1
                fi
                echo "--- Installing ${product} ---"
                build_dir=$(build_directory ${host} ${product})
                set -x
                pushd "${FOUNDATION_SOURCE_DIR}"
                ${NINJA_BIN} install
                popd
                { set +x; } 2>/dev/null

                # As foundation installation is self-contained, we break early here.
                continue
                ;;
            libdispatch)
                if [[ -z "${INSTALL_LIBDISPATCH}" ]] ; then
                    continue
                fi
                if [[ -z "${INSTALL_DESTDIR}" ]] ; then
                    echo "--install-destdir is required to install products."
                    exit 1
                fi
                echo "--- Installing ${product} ---"
                LIBDISPATCH_BUILD_DIR=$(build_directory ${host} ${product})
                set -x
                pushd "${LIBDISPATCH_BUILD_DIR}"
                make install
                popd
                { set +x; } 2>/dev/null

                # As libdispatch installation is self-contained, we break early here.
                continue
                ;;
            *)
                echo "error: unknown product: ${product}"
                exit 1
                ;;
        esac

        if [[ -z "${INSTALL_DESTDIR}" ]] ; then
            echo "--install-destdir is required to install products."
            exit 1
        fi

        echo "--- Installing ${product} ---"
        build_dir=$(build_directory ${host} ${product})

        set -x

        DESTDIR="${host_install_destdir}" "${CMAKE}" --build "${build_dir}" -- ${INSTALL_TARGETS}
        { set +x; } 2>/dev/null
    done

    if [[ "${DARWIN_INSTALL_EXTRACT_SYMBOLS}" ]] && [[ $(host_has_darwin_symbols ${host}) ]]; then
        set -x
        # Copy executables and shared libraries from the `host_install_destdir` to
        # INSTALL_SYMROOT and run dsymutil on them.
        (cd "${host_install_destdir}" &&
         find ./"${TOOLCHAIN_PREFIX}" -perm -0111 -type f -print | cpio -pdm "${INSTALL_SYMROOT}")

        # Run dsymutil on executables and shared libraries.
        #
        # Exclude shell scripts.
        (cd "${INSTALL_SYMROOT}" &&
         find ./"${TOOLCHAIN_PREFIX}" -perm -0111 -type f -print | \
           grep -v swift-stdlib-tool | \
           grep -v crashlog.py | \
           grep -v symbolication.py | \
           xargs -n 1 -P ${BUILD_JOBS} $(xcrun_find_tool dsymutil))

        # Strip executables, shared libraries and static libraries in
        # `host_install_destdir`.
        find "${host_install_destdir}${TOOLCHAIN_PREFIX}/" \
          -perm -0111 -or -name "*.a" -type f -print | \
          xargs -n 1 -P ${BUILD_JOBS} $(xcrun_find_tool strip) -S

        { set +x; } 2>/dev/null
    fi
done
# Everything is 'installed', but some products may be awaiting lipo.


function build_and_test_installable_package() {

    local host="$1"

    if [[ "${INSTALLABLE_PACKAGE}" ]] ; then

        # Get the directory where the products where installed.
        # If INSTALL_DESTDIR not given, we couldn't have installed anything.
        
        if [[ -z "${INSTALL_DESTDIR}" ]] ; then
            echo "--install-destdir required to build a package. Skipping."
            return
        fi
        local host_install_destdir="$(get_host_install_destdir ${host})"
        local host_install_prefix="$(get_host_install_prefix ${host})"

        if [[ $(has_cross_compile_hosts) ]]; then
            package_for_host="${INSTALLABLE_PACKAGE}-${host}"
        else
            package_for_host="${INSTALLABLE_PACKAGE}"
        fi

        echo "--- Creating installable package ---"
        echo "-- Package file: ${package_for_host} --"

        # Assume the lipo builds are (or include) an OSX host and build an xctoolchain
        if [[ "${host}" == "macosx-"* ]] || [[ "${host}" == "merged-hosts" ]]; then
          copy_swift_stdlib_tool_substitute "${host_install_destdir}${host_install_prefix}/bin/swift-stdlib-tool"
          
          # Create plist for xctoolchain.
          echo "-- Create Info.plist --"
          PLISTBUDDY_BIN="/usr/libexec/PlistBuddy"

          DARWIN_TOOLCHAIN_INSTALL_LOCATION="/Library/Developer/Toolchains/${DARWIN_TOOLCHAIN_NAME}.xctoolchain"
          DARWIN_TOOLCHAIN_INFO_PLIST="${host_install_destdir}${TOOLCHAIN_PREFIX}/Info.plist"
          DARWIN_TOOLCHAIN_REPORT_URL="https://bugs.swift.org/"
          COMPATIBILITY_VERSION=1
          DARWIN_TOOLCHAIN_CREATED_DATE="$(date -u +'%a %b %d %T GMT %Y')"

          echo "-- Removing: ${DARWIN_TOOLCHAIN_INFO_PLIST}"
          rm -f ${DARWIN_TOOLCHAIN_INFO_PLIST}

          ${PLISTBUDDY_BIN} -c "Add DisplayName string '${DARWIN_TOOLCHAIN_DISPLAY_NAME}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add ShortDisplayName string '${DARWIN_TOOLCHAIN_DISPLAY_NAME_SHORT}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add CreatedDate date '${DARWIN_TOOLCHAIN_CREATED_DATE}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add CompatibilityVersion integer ${COMPATIBILITY_VERSION}" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add Version string '${DARWIN_TOOLCHAIN_VERSION}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add CFBundleIdentifier string '${DARWIN_TOOLCHAIN_BUNDLE_IDENTIFIER}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add ReportProblemURL string '${DARWIN_TOOLCHAIN_REPORT_URL}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add Aliases array" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add Aliases:0 string '${DARWIN_TOOLCHAIN_ALIAS}'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add OverrideBuildSettings dict" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add OverrideBuildSettings:ENABLE_BITCODE string 'NO'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add OverrideBuildSettings:SWIFT_DISABLE_REQUIRED_ARCLITE string 'YES'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"
          ${PLISTBUDDY_BIN} -c "Add OverrideBuildSettings:SWIFT_LINK_OBJC_RUNTIME string 'YES'" "${DARWIN_TOOLCHAIN_INFO_PLIST}"

          chmod a+r "${DARWIN_TOOLCHAIN_INFO_PLIST}"

          if [[ "${DARWIN_TOOLCHAIN_APPLICATION_CERT}" ]] ; then
            echo "-- Codesign xctoolchain --"
            "${SWIFT_SOURCE_DIR}/utils/toolchain-codesign" "${DARWIN_TOOLCHAIN_APPLICATION_CERT}" "${host_install_destdir}${TOOLCHAIN_PREFIX}/" 
          fi
          if [[ "${DARWIN_TOOLCHAIN_INSTALLER_PACKAGE}" ]] ; then
            echo "-- Create Installer --"
            "${SWIFT_SOURCE_DIR}/utils/toolchain-installer" "${host_install_destdir}${TOOLCHAIN_PREFIX}/" "${DARWIN_TOOLCHAIN_BUNDLE_IDENTIFIER}" \
            "${DARWIN_TOOLCHAIN_INSTALLER_CERT}" "${DARWIN_TOOLCHAIN_INSTALLER_PACKAGE}" "${DARWIN_TOOLCHAIN_INSTALL_LOCATION}" \
            "${DARWIN_TOOLCHAIN_VERSION}" "${SWIFT_SOURCE_DIR}/utils/darwin-installer-scripts"
          fi 

          # host_install_destdir contains the toolchain prefix.
          # We want to create the package in host_install_destdir_nonprefixed.
          (cd "${host_install_destdir}" &&
            tar -c -z -f "${package_for_host}" "${TOOLCHAIN_PREFIX/#\/}")
        else
            # tar on OSX doesn't support --owner/--group.
            if [[ "$(uname -s)" == "Darwin" ]] ; then
                (cd "${host_install_destdir}" &&
                        tar -c -z -f "${package_for_host}" "${host_install_prefix/#\/}")
            else
                (cd "${host_install_destdir}" &&
                        tar -c -z -f "${package_for_host}" --owner=0 --group=0 "${host_install_prefix/#\/}")
            fi
        fi
        if [[ "${TEST_INSTALLABLE_PACKAGE}" ]] ; then
            PKG_TESTS_SOURCE_DIR="${WORKSPACE}/swift-integration-tests"
            PKG_TESTS_SANDBOX_PARENT="$(build_directory swift_package_sandbox_${host} none)"
            PKG_TESTS_TEMPS="${PKG_TESTS_SANDBOX_PARENT}"/"tests"

            if [[ "${host}" == "macosx-"* ]] ; then
                PKG_TESTS_SANDBOX="${PKG_TESTS_SANDBOX_PARENT}"/"${TOOLCHAIN_PREFIX}"
            else # Linux
                PKG_TESTS_SANDBOX="${PKG_TESTS_SANDBOX_PARENT}"
            fi

            LIT_EXECUTABLE_PATH="${LLVM_SOURCE_DIR}/utils/lit/lit.py"
            FILECHECK_EXECUTABLE_PATH="$(build_directory_bin ${LOCAL_HOST} llvm)/FileCheck"
            echo "-- Test Installable Package --"
            set -x
            rm -rf "${PKG_TESTS_SANDBOX_PARENT}"
            mkdir -p "${PKG_TESTS_SANDBOX}"
            pushd "${PKG_TESTS_SANDBOX_PARENT}"
            tar xzf "${package_for_host}"
            popd

            (cd "${PKG_TESTS_SOURCE_DIR}" &&
                    python "${LIT_EXECUTABLE_PATH}" . -sv --param package-path="${PKG_TESTS_SANDBOX}" --param filecheck="${FILECHECK_EXECUTABLE_PATH}" --param test-exec-root="${PKG_TESTS_TEMPS}")
            { set +x; } 2>/dev/null
        fi
    fi
}

# Build and test packages.
for host in "${ALL_HOSTS[@]}"; do
    
    if [[ $(should_include_host_in_lipo ${host}) ]]; then
            continue
    fi    
    
    build_and_test_installable_package ${host}
done

# Lipo those products which require it, optionally build and test an installable package.
if [[ ${#LIPO_SRC_DIRS[@]} -gt 0 ]]; then
    echo "--- Merging and running lipo ---"
    
    # This is from multiple hosts; Which host should we say it is? 
    # Let's call it 'merged-hosts' so that we can identify it.
    mergedHost="merged-hosts"
    "${SWIFT_SOURCE_DIR}"/utils/recursive-lipo --lipo=$(xcrun_find_tool lipo) --copy-subdirs="$(get_host_install_prefix ${host})lib/swift $(get_host_install_prefix ${host})lib/swift_static" --destination="$(get_host_install_destdir ${mergedHost})" ${LIPO_SRC_DIRS[@]}

    # Build and test the lipo-ed package.
    build_and_test_installable_package ${mergedHost}
fi
# END
