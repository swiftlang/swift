// RUN: %target-sil-opt %s -pack-specialization | %FileCheck %s

sil_stage canonical

import Builtin
import Swift

protocol P {}

class C : P {}

// INDIVIDUAL PARAMETER TRANSFORMATION TESTS:
//
// There are currently 3 conventions for pack parameters: @pack_guaranteed,
// @pack_owned and @pack_inout. Each member of an exploded pack parameter will
// be mapped to a parameter that has a "direct" (@owned or unowned), @guaranteed
// or indirect convention. We rely on the existing code to handle the ownership
// and lifetimes of any indirect or @owned parameters, so there are only 3
// different ways the pass needs to handle exploded pack elements. Accordingly,
// this leads to 9 different cases for how a pack parameter may be transformed,
// for which we have written 9 test cases.

// Check that name mangling, parameter & result pack explosion, local pack allocation, cleanup and use work as expected.
// CHECK-LABEL: sil shared [ossa] @$s24copy_pack_int_guaranteedTf8xx_n : $@convention(thin) (Int) -> Int {
// CHECK:       bb0(%0 : $Int):
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{Int}
// CHECK-NEXT:    [[IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[ADDR:%[0-9]+]] = alloc_stack $Int
// CHECK-NEXT:    store %0 to [trivial] [[ADDR]]
// CHECK-NEXT:    pack_element_set [[ADDR]] into [[IDX]] of [[IN_PACK]]
// CHECK-NEXT:    [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{Int}
// CHECK-NEXT:    [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[OUT_ADDR:%[0-9]+]] = alloc_stack $Int
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK:         [[RESULT:%[0-9]+]] = load [trivial] [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_stack [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_pack [[OUT_PACK]]
// CHECK-NEXT:    dealloc_stack [[ADDR]]
// CHECK-NEXT:    dealloc_pack [[IN_PACK]]
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s24copy_pack_int_guaranteedTf8xx_n'
sil [ossa] @copy_pack_int_guaranteed : $@convention(thin) (@pack_guaranteed Pack{Int}) -> @pack_out Pack{Int} {
bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
  copy_addr %1 to [init] %0
  %9 = tuple ()
  return %9
}

// Check that parameters and results are correctly extracted from and written back to the former argument packs,
// including any borrows of indirect parameters.
// CHECK-LABEL: sil [ossa] @call_copy_pack_int_guaranteed : $@convention(thin) (@pack_guaranteed Pack{Int}) -> @pack_out Pack{Int} {
// CHECK:       bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
// CHECK:         [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[IN_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[ARG_ADDR:%[0-9]+]] = pack_element_get [[IN_IDX]] of %1 as $*Int
// CHECK-NEXT:    [[ARG:%[0-9]+]] = load [trivial] [[ARG_ADDR]]
// CHECK:         [[FN_REF:%[0-9]+]] = function_ref @$s24copy_pack_int_guaranteedTf8xx_n : $@convention(thin) (Int) -> Int
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[FN_REF]]([[ARG]]) : $@convention(thin) (Int) -> Int
// CHECK-NEXT:    [[RESULT_ADDR:%[0-9]+]] = pack_element_get [[OUT_IDX]] of %0
// CHECK-NEXT:    store [[RESULT]] to [trivial] [[RESULT_ADDR]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_int_guaranteed'
sil [ossa] @call_copy_pack_int_guaranteed : $@convention(thin) (@pack_guaranteed Pack{Int}) -> @pack_out Pack{Int} {
bb0(%0 : $*Pack{Int}, %1: $*Pack{Int}):
  %10 = function_ref @copy_pack_int_guaranteed : $@convention(thin) (@pack_guaranteed Pack{Int}) -> @pack_out Pack{Int}
  %11 = apply %10(%0, %1) : $@convention(thin) (@pack_guaranteed Pack{Int}) -> @pack_out Pack{Int}
  return %11
}

// As above, for an owned pack.
// CHECK-LABEL: sil shared [ossa] @$s19copy_pack_int_ownedTf8xx_n : $@convention(thin) (Int) -> Int {
// CHECK:       bb0(%0 : $Int):
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{Int}
// CHECK-NEXT:    [[IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[ADDR:%[0-9]+]] = alloc_stack $Int
// CHECK-NEXT:    store %0 to [trivial] [[ADDR]]
// CHECK-NEXT:    pack_element_set [[ADDR]] into [[IDX]] of [[IN_PACK]]
// CHECK-NEXT:    [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{Int}
// CHECK-NEXT:    [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[OUT_ADDR:%[0-9]+]] = alloc_stack $Int
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK:         [[RESULT:%[0-9]+]] = load [trivial] [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_stack [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_pack [[OUT_PACK]]
// CHECK-NEXT:    dealloc_stack [[ADDR]]
// CHECK-NEXT:    dealloc_pack [[IN_PACK]]
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s19copy_pack_int_ownedTf8xx_n'
sil [ossa] @copy_pack_int_owned : $@convention(thin) (@pack_owned Pack{Int}) -> @pack_out Pack{Int} {
bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
  copy_addr %1 to [init] %0
  %9 = tuple ()
  return %9
}

// CHECK-LABEL: sil [ossa] @call_copy_pack_int_owned : $@convention(thin) (@pack_owned Pack{Int}) -> @pack_out Pack{Int} {
// CHECK:       bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
// CHECK:         [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[IN_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[ARG_ADDR:%[0-9]+]] = pack_element_get [[IN_IDX]] of %1 as $*Int
// CHECK-NEXT:    [[ARG:%[0-9]+]] = load [trivial] [[ARG_ADDR]]
// CHECK:         [[FN_REF:%[0-9]+]] = function_ref @$s19copy_pack_int_ownedTf8xx_n : $@convention(thin) (Int) -> Int
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[FN_REF]]([[ARG]]) : $@convention(thin) (Int) -> Int
// CHECK-NEXT:    [[RESULT_ADDR:%[0-9]+]] = pack_element_get [[OUT_IDX]] of %0
// CHECK-NEXT:    store [[RESULT]] to [trivial] [[RESULT_ADDR]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_int_owned'
sil [ossa] @call_copy_pack_int_owned : $@convention(thin) (@pack_owned Pack{Int}) -> @pack_out Pack{Int} {
bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
  %10 = function_ref @copy_pack_int_owned : $@convention(thin) (@pack_owned Pack{Int}) -> @pack_out Pack{Int}
  %11 = apply %10(%0, %1) : $@convention(thin) (@pack_owned Pack{Int}) -> @pack_out Pack{Int}
  return %11
}

// As above, for an inout pack.
// CHECK-LABEL: sil shared [ossa] @$s19copy_pack_int_inoutTf8xx_n : $@convention(thin) (@inout Int) -> Int {
// CHECK:       bb0([[ADDR:%[0-9]+]] : $*Int):
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{Int}
// CHECK-NEXT:    [[IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    pack_element_set [[ADDR]] into [[IDX]] of [[IN_PACK]]
// CHECK-NEXT:    [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{Int}
// CHECK-NEXT:    [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[OUT_ADDR:%[0-9]+]] = alloc_stack $Int
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK:         [[RESULT:%[0-9]+]] = load [trivial] [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_stack [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_pack [[OUT_PACK]]
// CHECK-NEXT:    dealloc_pack [[IN_PACK]]
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s19copy_pack_int_inoutTf8xx_n'
sil [ossa] @copy_pack_int_inout : $@convention(thin) (@pack_inout Pack{Int}) -> @pack_out Pack{Int} {
bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
  copy_addr %1 to [init] %0
  %9 = tuple ()
  return %9
}

// CHECK-LABEL: sil [ossa] @call_copy_pack_int_inout : $@convention(thin) (@pack_inout Pack{Int}) -> @pack_out Pack{Int} {
// CHECK:       bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
// CHECK:         [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[IN_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Int}
// CHECK-NEXT:    [[ARG_ADDR:%[0-9]+]] = pack_element_get [[IN_IDX]] of %1 as $*Int
// CHECK:         [[FN_REF:%[0-9]+]] = function_ref @$s19copy_pack_int_inoutTf8xx_n : $@convention(thin) (@inout Int) -> Int
// CHECK-NEXT:    [[CALL_RESULT:%[0-9]+]] = apply [[FN_REF]]([[ARG_ADDR]]) : $@convention(thin) (@inout Int) -> Int
// CHECK-NEXT:    [[RESULT_ADDR:%[0-9]+]] = pack_element_get [[OUT_IDX]] of %0
// CHECK-NEXT:    store [[CALL_RESULT]] to [trivial] [[RESULT_ADDR]]
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = tuple ()
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_int_inout'
sil [ossa] @call_copy_pack_int_inout : $@convention(thin) (@pack_inout Pack{Int}) -> @pack_out Pack{Int} {
bb0(%0 : $*Pack{Int}, %1 : $*Pack{Int}):
  %10 = function_ref @copy_pack_int_inout : $@convention(thin) (@pack_inout Pack{Int}) -> @pack_out Pack{Int}
  %11 = apply %10(%0, %1) : $@convention(thin) (@pack_inout Pack{Int}) -> @pack_out Pack{Int}
  %12 = tuple ()
  return %12
}


// Check that borrowed lifetimes are managed correctly for guaranteed pack-exploded arguments.
// CHECK-LABEL: sil shared [ossa] @$s28copy_pack_class_c_guaranteedTf8xx_n : $@convention(thin) (@guaranteed C) -> @owned C {
// CHECK:       bb0(%0 : @guaranteed $C):
// CHECK:         [[IN_ADDR:%[0-9]+]] = alloc_stack $C
// CHECK:         [[BORROW:%[0-9]+]] = store_borrow %0 to [[IN_ADDR]]
// CHECK:         [[OUT_ADDR:%[0-9]+]] = alloc_stack $C
// CHECK:         [[RESULT:%[0-9]+]] = load [take] [[OUT_ADDR]]
// CHECK:         end_borrow [[BORROW]]
// CHECK:         return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s28copy_pack_class_c_guaranteedTf8xx_n'
sil [ossa] @copy_pack_class_c_guaranteed : $@convention(thin) (@pack_guaranteed Pack{C}) -> @pack_out Pack{C} {
bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
  copy_addr %1 to [init] %0
  %8 = tuple ()
  return %8
}

// Check that non-trivial guaranteed parameters are correctly borrowed
// CHECK-LABEL: sil [ossa] @call_copy_pack_class_c_guaranteed : $@convention(thin) (@pack_guaranteed Pack{C}) -> @pack_out Pack{C} {
// CHECK:       bb0(%0 : $*Pack{C}, %1 : $*Pack{C})
// CHECK:         [[IN_C_PACK_ADDR:%[0-9]+]] = pack_element_get [[PACK_GET_IDX:%[0-9]+]] of %1 as $*C
// CHECK-NEXT:    [[BORROW:%[0-9]+]] = load_borrow [[IN_C_PACK_ADDR]]
// CHECK:         [[SPECIALIZED:%[0-9]+]] = function_ref @$s28copy_pack_class_c_guaranteedTf8xx_n : $@convention(thin) (@guaranteed C) -> @owned C
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[SPECIALIZED]]([[BORROW]]) : $@convention(thin) (@guaranteed C) -> @owned C
// CHECK-NEXT:    end_borrow [[BORROW]]
// CHECK:         [[OUT_ADDR:%[0-9]+]] = pack_element_get [[OUT_PACK_GET_IDX:%[0-9]+]] of %0 as $*C
// CHECK:         store [[RESULT]] to [init] [[OUT_ADDR]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_class_c_guaranteed'
sil [ossa] @call_copy_pack_class_c_guaranteed : $@convention(thin) (@pack_guaranteed Pack{C}) -> @pack_out Pack{C} {
bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
  %16 = function_ref @copy_pack_class_c_guaranteed : $@convention(thin) (@pack_guaranteed Pack{C}) -> @pack_out Pack{C}
  %17 = apply %16(%0, %1) : $@convention(thin) (@pack_guaranteed Pack{C}) -> @pack_out Pack{C}
  return %17
}


// Check that lifetimes are managed correctly for owned pack-exploded arguments.
// The original code already manages lifetimes sufficiently, so no additional retains, releases, borrows etc. are necessary.
// CHECK-LABEL: sil shared [ossa] @$s23copy_pack_class_c_ownedTf8xx_n : $@convention(thin) (@owned C) -> @owned C {
// CHECK:       bb0(%0 : @owned $C):
// CHECK:         [[IN_ADDR:%[0-9]+]] = alloc_stack $C
// CHECK:         store %0 to [init] [[IN_ADDR]]
// CHECK:         [[OUT_ADDR:%[0-9]+]] = alloc_stack $C
// CHECK:         [[RESULT:%[0-9]+]] = load [take] [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_stack [[OUT_ADDR]]
// CHECK:         dealloc_stack [[IN_ADDR]]
// CHECK:         return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s23copy_pack_class_c_ownedTf8xx_n'
sil [ossa] @copy_pack_class_c_owned : $@convention(thin) (@pack_owned Pack{C}) -> @pack_out Pack{C} {
bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
  copy_addr %1 to [init] %0
  %8 = tuple ()
  return %8
}

// Check that non-trivial owned pack-exploded parameters are loaded and passed correctly.
// CHECK-LABEL: sil [ossa] @call_copy_pack_class_c_owned : $@convention(thin) (@pack_owned Pack{C}) -> @pack_out Pack{C} {
// CHECK:       bb0(%0 : $*Pack{C}, %1 : $*Pack{C})
// CHECK:         [[IN_C_PACK_ADDR:%[0-9]+]] = pack_element_get [[PACK_GET_IDX:%[0-9]+]] of %1 as $*C
// CHECK-NEXT:    [[ARGUMENT:%[0-9]+]] = load [take] [[IN_C_PACK_ADDR]]
// CHECK:         [[SPECIALIZED:%[0-9]+]] = function_ref @$s23copy_pack_class_c_ownedTf8xx_n : $@convention(thin) (@owned C) -> @owned C
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[SPECIALIZED]]([[ARGUMENT]]) : $@convention(thin) (@owned C) -> @owned C
// CHECK:         [[OUT_ADDR:%[0-9]+]] = pack_element_get [[OUT_PACK_GET_IDX:%[0-9]+]] of %0 as $*C
// CHECK:         store [[RESULT]] to [init] [[OUT_ADDR]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_class_c_owned'
sil [ossa] @call_copy_pack_class_c_owned : $@convention(thin) (@pack_owned Pack{C}) -> @pack_out Pack{C} {
bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
  %16 = function_ref @copy_pack_class_c_owned : $@convention(thin) (@pack_owned Pack{C}) -> @pack_out Pack{C}
  %17 = apply %16(%0, %1) : $@convention(thin) (@pack_owned Pack{C}) -> @pack_out Pack{C}
  return %17
}

// As above, for an inout Pack{C}. The code in this function should be almost identical to the @pack_inout Pack{Int} one.
// CHECK-LABEL: sil shared [ossa] @$s23copy_pack_class_c_inoutTf8xx_n : $@convention(thin) (@inout C) -> @owned C {
// CHECK:       bb0([[ADDR:%[0-9]+]] : $*C):
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{C}
// CHECK-NEXT:    [[IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{C}
// CHECK-NEXT:    pack_element_set [[ADDR]] into [[IDX]] of [[IN_PACK]]
// CHECK-NEXT:    [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{C}
// CHECK-NEXT:    [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{C}
// CHECK-NEXT:    [[OUT_ADDR:%[0-9]+]] = alloc_stack $C
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK:         [[RESULT:%[0-9]+]] = load [take] [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_stack [[OUT_ADDR]]
// CHECK-NEXT:    dealloc_pack [[OUT_PACK]]
// CHECK-NEXT:    dealloc_pack [[IN_PACK]]
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s23copy_pack_class_c_inoutTf8xx_n'
sil [ossa] @copy_pack_class_c_inout : $@convention(thin) (@pack_inout Pack{C}) -> @pack_out Pack{C} {
bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
  copy_addr %1 to [init] %0
  %9 = tuple ()
  return %9
}

// Check that non-trivial inout pack-exploded parameters are passed correctly.
// CHECK-LABEL: sil [ossa] @call_copy_pack_class_c_inout : $@convention(thin) (@pack_inout Pack{C}) -> @pack_out Pack{C} {
// CHECK:       bb0(%0 : $*Pack{C}, %1 : $*Pack{C})
// CHECK:         [[IN_C_PACK_ADDR:%[0-9]+]] = pack_element_get [[PACK_GET_IDX:%[0-9]+]] of %1 as $*C
// CHECK:         [[SPECIALIZED:%[0-9]+]] = function_ref @$s23copy_pack_class_c_inoutTf8xx_n : $@convention(thin) (@inout C) -> @owned C
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[SPECIALIZED]]([[IN_C_PACK_ADDR]]) : $@convention(thin) (@inout C) -> @owned C
// CHECK:         [[OUT_ADDR:%[0-9]+]] = pack_element_get [[OUT_PACK_GET_IDX:%[0-9]+]] of %0 as $*C
// CHECK:         store [[RESULT]] to [init] [[OUT_ADDR]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_class_c_inout'
sil [ossa] @call_copy_pack_class_c_inout : $@convention(thin) (@pack_inout Pack{C}) -> @pack_out Pack{C} {
bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
  %16 = function_ref @copy_pack_class_c_inout : $@convention(thin) (@pack_inout Pack{C}) -> @pack_out Pack{C}
  %17 = apply %16(%0, %1) : $@convention(thin) (@pack_inout Pack{C}) -> @pack_out Pack{C}
  return %17
}

// Check that pack explosion procedure is correct for non-loadable pack element types like any P.
// CHECK-LABEL: sil shared [ossa] @$s31copy_pack_protocol_p_guaranteedTf8xx_n : $@convention(thin) (@in_guaranteed any P) -> @out any P {
// CHECK:       bb0([[OUT_ADDR:%[0-9]+]] : $*any P, [[IN_ADDR:%[0-9]+]] : $*any P)
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{any P}
// CHECK-NEXT:    [[IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P}
// CHECK-NEXT:    pack_element_set [[IN_ADDR]] into [[IDX]] of [[IN_PACK]]
// CHECK-NEXT:    [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{any P}
// CHECK-NEXT:    [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P}
// CHECK-NEXT:    pack_element_set [[OUT_ADDR]] into [[OUT_IDX]] of [[OUT_PACK]]
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = tuple ()
// CHECK-NEXT:    dealloc_pack [[OUT_PACK]]
// CHECK-NEXT:    dealloc_pack [[IN_PACK]]
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s31copy_pack_protocol_p_guaranteedTf8xx_n'
sil [ossa] @copy_pack_protocol_p_guaranteed : $@convention(thin) (@pack_guaranteed Pack{any P}) -> @pack_out Pack{any P} {
bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
  copy_addr %1 to [init] %0
  %7 = tuple ()
  return %7
}

// Check that indirect result and parameter pack members are correctly extracted and passed to the callee.
// CHECK-LABEL: sil [ossa] @call_copy_pack_protocol_p_guaranteed : $@convention(thin) (@pack_guaranteed Pack{any P}) -> @pack_out Pack{any P} {
// CHECK:       bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P})
// CHECK:         [[OUT_P_PACK_ADDR:%[0-9]+]] = pack_element_get [[OUT_PACK_GET_IDX:%[0-9]+]] of %0 as $*any P
// CHECK:         [[IN_P_PACK_ADDR:%[0-9]+]] = pack_element_get [[PACK_GET_IDX:%[0-9]+]] of %1 as $*any P
// CHECK:         [[SPECIALIZED:%[0-9]+]] = function_ref @$s31copy_pack_protocol_p_guaranteedTf8xx_n : $@convention(thin) (@in_guaranteed any P) -> @out any P
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[SPECIALIZED]]([[OUT_P_PACK_ADDR]], [[IN_P_PACK_ADDR]]) : $@convention(thin) (@in_guaranteed any P) -> @out any P
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_protocol_p_guaranteed'
sil [ossa] @call_copy_pack_protocol_p_guaranteed : $@convention(thin) (@pack_guaranteed Pack{any P}) -> @pack_out Pack{any P} {
bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
  %16 = function_ref @copy_pack_protocol_p_guaranteed : $@convention(thin) (@pack_guaranteed Pack{any P}) -> @pack_out Pack{any P}
  %17 = apply %16(%0, %1) : $@convention(thin) (@pack_guaranteed Pack{any P}) -> @pack_out Pack{any P}
  return %17
}

// CHECK-LABEL: sil shared [ossa] @$s26copy_pack_protocol_p_ownedTf8xx_n : $@convention(thin) (@in any P) -> @out any P {
// CHECK:       bb0([[OUT_ADDR:%[0-9]+]] : $*any P, [[IN_ADDR:%[0-9]+]] : $*any P)
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{any P}
// CHECK-NEXT:    [[IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P}
// CHECK-NEXT:    pack_element_set [[IN_ADDR]] into [[IDX]] of [[IN_PACK]]
// CHECK-NEXT:    [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{any P}
// CHECK-NEXT:    [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P}
// CHECK-NEXT:    pack_element_set [[OUT_ADDR]] into [[OUT_IDX]] of [[OUT_PACK]]
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = tuple ()
// CHECK-NEXT:    dealloc_pack [[OUT_PACK]]
// CHECK-NEXT:    dealloc_pack [[IN_PACK]]
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s26copy_pack_protocol_p_ownedTf8xx_n'
sil [ossa] @copy_pack_protocol_p_owned : $@convention(thin) (@pack_owned Pack{any P}) -> @pack_out Pack{any P} {
bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
  copy_addr %1 to [init] %0
  %7 = tuple ()
  return %7
}

// As above for non-loadable types in owned packs.
// CHECK-LABEL: sil [ossa] @call_copy_pack_protocol_p_owned : $@convention(thin) (@pack_owned Pack{any P}) -> @pack_out Pack{any P} {
// CHECK:       bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P})
// CHECK:         [[OUT_P_PACK_ADDR:%[0-9]+]] = pack_element_get [[OUT_PACK_GET_IDX:%[0-9]+]] of %0 as $*any P
// CHECK:         [[IN_P_PACK_ADDR:%[0-9]+]] = pack_element_get [[PACK_GET_IDX:%[0-9]+]] of %1 as $*any P
// CHECK:         [[SPECIALIZED:%[0-9]+]] = function_ref @$s26copy_pack_protocol_p_ownedTf8xx_n : $@convention(thin) (@in any P) -> @out any P
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[SPECIALIZED]]([[OUT_P_PACK_ADDR]], [[IN_P_PACK_ADDR]]) : $@convention(thin) (@in any P) -> @out any P
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_protocol_p_owned'
sil [ossa] @call_copy_pack_protocol_p_owned : $@convention(thin) (@pack_owned Pack{any P}) -> @pack_out Pack{any P} {
bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
  %16 = function_ref @copy_pack_protocol_p_owned : $@convention(thin) (@pack_owned Pack{any P}) -> @pack_out Pack{any P}
  %17 = apply %16(%0, %1) : $@convention(thin) (@pack_owned Pack{any P}) -> @pack_out Pack{any P}
  return %17
}

// CHECK-LABEL: sil shared [ossa] @$s26copy_pack_protocol_p_inoutTf8xx_n : $@convention(thin) (@inout any P) -> @out any P {
// CHECK:       bb0([[OUT_ADDR:%[0-9]+]] : $*any P, [[IN_ADDR:%[0-9]+]] : $*any P)
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{any P}
// CHECK-NEXT:    [[IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P}
// CHECK-NEXT:    pack_element_set [[IN_ADDR]] into [[IDX]] of [[IN_PACK]]
// CHECK-NEXT:    [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{any P}
// CHECK-NEXT:    [[OUT_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P}
// CHECK-NEXT:    pack_element_set [[OUT_ADDR]] into [[OUT_IDX]] of [[OUT_PACK]]
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = tuple ()
// CHECK-NEXT:    dealloc_pack [[OUT_PACK]]
// CHECK-NEXT:    dealloc_pack [[IN_PACK]]
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s26copy_pack_protocol_p_inoutTf8xx_n'
sil [ossa] @copy_pack_protocol_p_inout : $@convention(thin) (@pack_inout Pack{any P}) -> @pack_out Pack{any P} {
bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
  copy_addr %1 to [init] %0
  %7 = tuple ()
  return %7
}

// As above for non-loadable types in inout packs.
// CHECK-LABEL: sil [ossa] @call_copy_pack_protocol_p_inout : $@convention(thin) (@pack_inout Pack{any P}) -> @pack_out Pack{any P} {
// CHECK:       bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P})
// CHECK:         [[OUT_P_PACK_ADDR:%[0-9]+]] = pack_element_get [[OUT_PACK_GET_IDX:%[0-9]+]] of %0 as $*any P
// CHECK:         [[IN_P_PACK_ADDR:%[0-9]+]] = pack_element_get [[PACK_GET_IDX:%[0-9]+]] of %1 as $*any P
// CHECK:         [[SPECIALIZED:%[0-9]+]] = function_ref @$s26copy_pack_protocol_p_inoutTf8xx_n : $@convention(thin) (@inout any P) -> @out any P
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[SPECIALIZED]]([[OUT_P_PACK_ADDR]], [[IN_P_PACK_ADDR]]) : $@convention(thin) (@inout any P) -> @out any P
// CHECK-NEXT:    return [[RESULT]]
// CHECK-LABEL: } // end sil function 'call_copy_pack_protocol_p_inout'
sil [ossa] @call_copy_pack_protocol_p_inout : $@convention(thin) (@pack_inout Pack{any P}) -> @pack_out Pack{any P} {
bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
  %16 = function_ref @copy_pack_protocol_p_inout : $@convention(thin) (@pack_inout Pack{any P}) -> @pack_out Pack{any P}
  %17 = apply %16(%0, %1) : $@convention(thin) (@pack_inout Pack{any P}) -> @pack_out Pack{any P}
  return %17
}

// INTERLEAVING PACK AND NON-PACK ARGUMENTS TESTS:
//
// The new function arguments and return values corresponding to pack parameters
// are inserted into the parameter and results lists in the same order as they
// are passed in the original pack.
//
// Other tests cover the callee and call-site modifications necessary to extract
// elements from packs. These tests focus primarily on the positions of the
// mapped arguments and result values.

// CHECK-LABEL: sil shared [ossa] @$s18interleave_unownedTf8xnxn_n : $@convention(thin) (Builtin.Int64, Builtin.Int32, Builtin.Int64) -> (Builtin.Int64, Builtin.Int32, Builtin.Int64) {
// CHECK:       bb0([[A1:%[0-9]+]] : $Builtin.Int64, [[A2:%[0-9]+]] : $Builtin.Int32, [[A3:%[0-9]+]] : $Builtin.Int64):
// CHECK:         [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{Builtin.Int32}
// CHECK:         store [[A2]] to [trivial] [[IN_STACK:%[0-9]+]]
// CHECK:         pack_element_set [[IN_STACK]] into [[IN_IDX:%[0-9]+]] of [[IN_PACK]]
// CHECK:         [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{Builtin.Int32}
// CHECK:         [[OUT_ADDR:%[0-9]+]] = alloc_stack $Builtin.Int32
// CHECK:         [[ORIGINAL_RESULT:%[0-9]+]] = tuple ([[A1]], [[A3]])
// CHECK:         ([[R1:%[0-9]+]], [[R3:%[0-9]+]]) = destructure_tuple [[ORIGINAL_RESULT]]
// CHECK:         [[R2:%[0-9]+]] = load [trivial] [[OUT_ADDR]]
// CHECK:         [[RESULT:%[0-9]+]] = tuple ([[R1]], [[R2]], [[R3]])
// CHECK:         return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s18interleave_unownedTf8xnxn_n'
sil [ossa] @interleave_unowned : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{Builtin.Int32}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{Builtin.Int32}, Builtin.Int64) {
bb0(%0 : $*Pack{Builtin.Int32}, %1 : $Builtin.Int64, %2 : $*Pack{Builtin.Int32}, %3 : $Builtin.Int64):
  %7 = scalar_pack_index 0 of $Pack{Builtin.Int32}
  %8 = pack_element_get %7 of %0 as $*Builtin.Int32
  %9 = pack_element_get %7 of %2 as $*Builtin.Int32
  copy_addr %9 to [init] %8
  %12 = tuple (%1, %3)
  return %12
}

// CHECK-LABEL: sil [ossa] @call_interleave_unowned  : $@convention(thin) (@pack_owned Pack{Builtin.Int32}) -> (Builtin.Int64, @pack_out Pack{Builtin.Int32}, Builtin.Int64) {
// CHECK:       bb0(%0 : $*Pack{Builtin.Int32}, %1 : $*Pack{Builtin.Int32}):
// CHECK:         [[FNREF:%[0-9]+]] = function_ref @$s18interleave_unownedTf8xnxn_n
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[FNREF]]
// CHECK:         ([[R1:%[0-9]+]], [[R2:%[0-9]+]], [[R3:%[0-9]+]]) = destructure_tuple [[RESULT]]
// CHECK:         store [[R2]] to
// CHECK-NEXT:    [[ORIGINAL_RESULT:%[0-9]+]] = tuple ([[R1:%[0-9]+]], [[R3:%[0-9]+]])
// CHECK-NEXT:    return [[ORIGINAL_RESULT]]
// CHECK-LABEL: } // end sil function 'call_interleave_unowned'
sil [ossa] @call_interleave_unowned : $@convention(thin) (@pack_owned Pack{Builtin.Int32}) -> (Builtin.Int64, @pack_out Pack{Builtin.Int32}, Builtin.Int64) {
bb0(%0 : $*Pack{Builtin.Int32}, %1 : $*Pack{Builtin.Int32}):
  %6 = integer_literal $Builtin.Int64, 1
  %12 = integer_literal $Builtin.Int64, 3
  %14 = function_ref @interleave_unowned : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{Builtin.Int32}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{Builtin.Int32}, Builtin.Int64)
  %15 = apply %14(%0, %6, %1, %12) : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{Builtin.Int32}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{Builtin.Int32}, Builtin.Int64)
  return %15
}


// CHECK-LABEL: sil shared [ossa] @$s17interleave_directTf8xnxn_n : $@convention(thin) (Builtin.Int64, @guaranteed C, Builtin.Int64) -> (Builtin.Int64, @owned C, Builtin.Int64) {
// CHECK:       bb0(%0 : $Builtin.Int64, %1 : @guaranteed $C, %2 : $Builtin.Int64):
// CHECK:         ([[R1:%[0-9]+]], [[R3:%[0-9]+]]) = destructure_tuple
// CHECK:         [[R2:%[0-9]+]] = load [take]
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = tuple ([[R1]], [[R2]], [[R3]])
// CHECK:         return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s17interleave_directTf8xnxn_n'
sil [ossa] @interleave_direct : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{C}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{C}, Builtin.Int64) {
bb0(%0 : $*Pack{C}, %1 : $Builtin.Int64, %2 : $*Pack{C}, %3 : $Builtin.Int64):
  %7 = scalar_pack_index 0 of $Pack{C}
  %8 = pack_element_get %7 of %0 as $*C
  %9 = pack_element_get %7 of %2 as $*C
  copy_addr %9 to [init] %8
  %12 = tuple (%1, %3)
  return %12
}

// CHECK-LABEL: sil [ossa] @call_interleave_direct  : $@convention(thin) (@pack_owned Pack{C}) -> (Builtin.Int64, @pack_out Pack{C}, Builtin.Int64) {
// CHECK:       bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
// CHECK:         [[FNREF:%[0-9]+]] = function_ref @$s17interleave_directTf8xnxn_n
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[FNREF]]
// CHECK:         ([[R1:%[0-9]+]], [[R2:%[0-9]+]], [[R3:%[0-9]+]]) = destructure_tuple [[RESULT]]
// CHECK:         store [[R2]] to
// CHECK-NEXT:    [[ORIGINAL_RESULT:%[0-9]+]] = tuple ([[R1:%[0-9]+]], [[R3:%[0-9]+]])
// CHECK:         return [[ORIGINAL_RESULT]]
// CHECK-LABEL: } // end sil function 'call_interleave_direct'
sil [ossa] @call_interleave_direct : $@convention(thin) (@pack_owned Pack{C}) -> (Builtin.Int64, @pack_out Pack{C}, Builtin.Int64) {
bb0(%0 : $*Pack{C}, %1 : $*Pack{C}):
  %6 = integer_literal $Builtin.Int64, 1
  %12 = integer_literal $Builtin.Int64, 3
  %14 = function_ref @interleave_direct : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{C}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{C}, Builtin.Int64)
  %15 = apply %14(%0, %6, %1, %12) : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{C}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{C}, Builtin.Int64)
  return %15
}


// CHECK-LABEL: sil shared [ossa] @$s19interleave_indirectTf8xnxn_n : $@convention(thin) (Builtin.Int64, @in_guaranteed any P, Builtin.Int64) -> (Builtin.Int64, @out any P, Builtin.Int64) {
// CHECK:       bb0(%0 : $*any P, %1 : $Builtin.Int64, %2 : $*any P, %3 : $Builtin.Int64):
// CHECK:         pack_element_set %2 into
// CHECK:         pack_element_set %0 into
// CHECK:         pack_element_get [[INDEX:%[0-9]+]] of [[OUT_PACK:%[0-9]+]]
// CHECK:         pack_element_get [[INDEX]] of [[IN_PACK:%[0-9]+]]
// CHECK:         [[RESULT:%[0-9]+]] = tuple ([[R1:%[0-9]+]], [[R3:%[0-9]+]])
// CHECK:         return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s19interleave_indirectTf8xnxn_n'
sil [ossa] @interleave_indirect : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{any P}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{any P}, Builtin.Int64) {
bb0(%0 : $*Pack{any P}, %1 : $Builtin.Int64, %2 : $*Pack{any P}, %3 : $Builtin.Int64):
  %7 = scalar_pack_index 0 of $Pack{any P}
  %8 = pack_element_get %7 of %0 as $*any P
  %9 = pack_element_get %7 of %2 as $*any P
  copy_addr %9 to [init] %8
  %11 = tuple (%1, %3)
  return %11
}

// CHECK-LABEL: sil [ossa] @call_interleave_indirect  : $@convention(thin) (@pack_owned Pack{any P}) -> (Builtin.Int64, @pack_out Pack{any P}, Builtin.Int64) {
// CHECK:       bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
// CHECK:         [[FNREF:%[0-9]+]] = function_ref @$s19interleave_indirectTf8xnxn_n
// CHECK-NEXT:    [[RESULT:%[0-9]+]] = apply [[FNREF]]
// CHECK:         return [[RESULT]]
// CHECK-LABEL: } // end sil function 'call_interleave_indirect'
sil [ossa] @call_interleave_indirect : $@convention(thin) (@pack_owned Pack{any P}) -> (Builtin.Int64, @pack_out Pack{any P}, Builtin.Int64) {
bb0(%0 : $*Pack{any P}, %1 : $*Pack{any P}):
  %6 = integer_literal $Builtin.Int64, 1
  %12 = integer_literal $Builtin.Int64, 3
  %14 = function_ref @interleave_indirect : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{any P}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{any P}, Builtin.Int64)
  %15 = apply %14(%0, %6, %1, %12) : $@convention(thin) (Builtin.Int64, @pack_guaranteed Pack{any P}, Builtin.Int64) -> (Builtin.Int64, @pack_out Pack{any P}, Builtin.Int64)
  return %15
}

// MULTI-ELEMENT PACK TESTS:

// Since the pack elements are the same type, ensure they are inserted in the correct order.
// CHECK-LABEL: sil shared [ossa] @$s09copy_int_B0Tf8xx_n : $@convention(thin) (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int64) {
// CHECK: bb0(%0 : $Builtin.Int64, %1 : $Builtin.Int64):
// CHECK: [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{Builtin.Int64, Builtin.Int64}
// CHECK: [[IN_IDX_0:%[0-9]+]] = scalar_pack_index 0 of $Pack{Builtin.Int64, Builtin.Int64}
// CHECK: [[IN_ADDR_0:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK: store %0 to [trivial] [[IN_ADDR_0]]
// CHECK: pack_element_set [[IN_ADDR_0]] into [[IN_IDX_0]] of [[IN_PACK]]
// CHECK: [[IN_IDX_1:%[0-9]+]] = scalar_pack_index 1 of $Pack{Builtin.Int64, Builtin.Int64}
// CHECK: [[IN_ADDR_1:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK: store %1 to [trivial] [[IN_ADDR_1]]
// CHECK: pack_element_set [[IN_ADDR_1]] into [[IN_IDX_1]] of [[IN_PACK]]
// CHECK: [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{Builtin.Int64, Builtin.Int64}
// CHECK: [[OUT_ADDR_0:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK: [[OUT_ADDR_1:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK: copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK: [[ORIGINAL_RESULT:%[0-9]+]] = tuple ()
// CHECK: [[OUT_0:%[0-9]+]] = load [trivial] [[OUT_ADDR_0]]
// CHECK: [[OUT_1:%[0-9]+]] = load [trivial] [[OUT_ADDR_1]]
// CHECK: [[RESULT:%[0-9]+]] = tuple ([[OUT_0]], [[OUT_1]])
// CHECK: return [[RESULT]]
// CHECK-LABEL: } // end sil function '$s09copy_int_B0Tf8xx_n'
sil [ossa] @copy_int_int : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, Builtin.Int64}) -> @pack_out Pack{Builtin.Int64, Builtin.Int64} {
bb0(%0 : $*Pack{Builtin.Int64, Builtin.Int64}, %1 : $*Pack{Builtin.Int64, Builtin.Int64}):
  copy_addr %1 to [init] %0
  %13 = tuple ()
  return %13
}

// CHECK-LABEL: sil [ossa] @call_copy_int_int : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, Builtin.Int64}) ->  @pack_out Pack{Builtin.Int64, Builtin.Int64} {
// CHECK-LABEL: } // end sil function 'call_copy_int_int'
sil [ossa] @call_copy_int_int : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, Builtin.Int64}) -> @pack_out Pack{Builtin.Int64, Builtin.Int64} {
bb0(%0 : $*Pack{Builtin.Int64, Builtin.Int64}, %1: $*Pack{Builtin.Int64, Builtin.Int64}):
  %2 = function_ref @copy_int_int : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, Builtin.Int64}) -> @pack_out Pack{Builtin.Int64, Builtin.Int64}
  %3 = apply %2(%0, %1) : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, Builtin.Int64}) -> @pack_out Pack{Builtin.Int64, Builtin.Int64}
  %4 = tuple ()
  return %4
}

// CHECK-LABEL: sil shared [ossa] @$s10copy_int_pTf8xx_n : $@convention(thin) (Builtin.Int64, @in_guaranteed any P) -> (Builtin.Int64, @out any P) {
// CHECK:       bb0(%0 : $*any P, %1 : $Builtin.Int64, %2 : $*any P):
// CHECK:         [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{Builtin.Int64, any P}
// CHECK:         [[IN_ADDR_0:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK:         store %1 to [trivial] [[IN_ADDR_0]]
// CHECK:         [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{Builtin.Int64, any P}
// CHECK:         [[OUT_ADDR_0:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK:         [[ORIGINAL_RESULT:%[0-9]+]] = tuple ()
// CHECK:         [[OUT_0:%[0-9]+]] = load [trivial] [[OUT_ADDR_0]]
// CHECK:         return [[OUT_0]]
// CHECK-LABEL: } // end sil function '$s10copy_int_pTf8xx_n'
sil [ossa] @copy_int_p : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, any P}) -> @pack_out Pack{Builtin.Int64, any P} {
bb0(%0 : $*Pack{Builtin.Int64, any P}, %1 : $*Pack{Builtin.Int64, any P}):
  copy_addr %1 to [init] %0
  %12 = tuple ()
  return %12
}

// CHECK-LABEL: sil [ossa] @call_copy_int_p : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, any P}) ->  @pack_out Pack{Builtin.Int64, any P} {
// CHECK-LABEL: } // end sil function 'call_copy_int_p'
sil [ossa] @call_copy_int_p : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, any P}) -> @pack_out Pack{Builtin.Int64, any P} {
bb0(%0 : $*Pack{Builtin.Int64, any P}, %1: $*Pack{Builtin.Int64, any P}):
  %2 = function_ref @copy_int_p : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, any P}) -> @pack_out Pack{Builtin.Int64, any P}
  %3 = apply %2(%0, %1) : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64, any P}) -> @pack_out Pack{Builtin.Int64, any P}
  %4 = tuple ()
  return %4
}

// CHECK-LABEL: sil shared [ossa] @$s10copy_p_intTf8xx_n : $@convention(thin) (@in_guaranteed any P, Builtin.Int64) -> (@out any P, Builtin.Int64) {
// CHECK:       bb0(%0 : $*any P, %1 : $*any P, %2 : $Builtin.Int64):
// CHECK:         [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{any P, Builtin.Int64}
// CHECK:         [[IN_ADDR_1:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK:         store %2 to [trivial] [[IN_ADDR_1]]
// CHECK:         [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{any P, Builtin.Int64}
// CHECK:         [[OUT_ADDR_0:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK:         [[ORIGINAL_RESULT:%[0-9]+]] = tuple ()
// CHECK:         [[OUT_0:%[0-9]+]] = load [trivial] [[OUT_ADDR_0]]
// CHECK:         return [[OUT_0]]
// CHECK-LABEL: } // end sil function '$s10copy_p_intTf8xx_n'
sil [ossa] @copy_p_int : $@convention(thin) (@pack_guaranteed Pack{any P, Builtin.Int64}) -> @pack_out Pack{any P, Builtin.Int64} {
bb0(%0 : $*Pack{any P, Builtin.Int64}, %1 : $*Pack{any P, Builtin.Int64}):
  copy_addr %1 to [init] %0
  %12 = tuple ()
  return %12
}

// CHECK-LABEL: sil [ossa] @call_copy_p_int : $@convention(thin) (@pack_guaranteed Pack{any P, Builtin.Int64}) ->  @pack_out Pack{any P, Builtin.Int64} {
// CHECK-LABEL: } // end sil function 'call_copy_p_int'
sil [ossa] @call_copy_p_int : $@convention(thin) (@pack_guaranteed Pack{any P, Builtin.Int64}) -> @pack_out Pack{any P, Builtin.Int64} {
bb0(%0 : $*Pack{any P, Builtin.Int64}, %1: $*Pack{any P, Builtin.Int64}):
  %2 = function_ref @copy_p_int : $@convention(thin) (@pack_guaranteed Pack{any P, Builtin.Int64}) -> @pack_out Pack{any P, Builtin.Int64}
  %3 = apply %2(%0, %1) : $@convention(thin) (@pack_guaranteed Pack{any P, Builtin.Int64}) -> @pack_out Pack{any P, Builtin.Int64}
  %4 = tuple ()
  return %4
}

// Since the pack elements are the same type, ensure they are inserted in the correct order.
// CHECK-LABEL: sil shared [ossa] @$s8copy_p_pTf8xx_n : $@convention(thin) (@in_guaranteed any P, @in_guaranteed any P) -> (@out any P, @out any P) {
// CHECK:       bb0(%0 : $*any P, %1 : $*any P, %2 : $*any P, %3 : $*any P):
// CHECK:         [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{any P, any P}
// CHECK-NEXT:    [[IN_IDX_0:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P, any P}
// CHECK-NEXT:    pack_element_set %2 into [[IN_IDX_0]] of [[IN_PACK]]
// CHECK-NEXT:    [[IN_IDX_1:%[0-9]+]] = scalar_pack_index 1 of $Pack{any P, any P}
// CHECK-NEXT:    pack_element_set %3 into [[IN_IDX_1]] of [[IN_PACK]]
// CHECK:         [[OUT_PACK:%[0-9]+]] = alloc_pack $Pack{any P, any P}
// CHECK-NEXT:    [[OUT_IDX_0:%[0-9]+]] = scalar_pack_index 0 of $Pack{any P, any P}
// CHECK-NEXT:    pack_element_set %0 into [[OUT_IDX_0]] of [[OUT_PACK]]
// CHECK-NEXT:    [[OUT_IDX_1:%[0-9]+]] = scalar_pack_index 1 of $Pack{any P, any P}
// CHECK-NEXT:    pack_element_set %1 into [[OUT_IDX_1]] of [[OUT_PACK]]
// CHECK:         copy_addr [[IN_PACK]] to [init] [[OUT_PACK]]
// CHECK:         [[ORIGINAL_RESULT:%[0-9]+]] = tuple ()
// CHECK:         return [[ORIGINAL_RESULT]]
// CHECK-LABEL: } // end sil function '$s8copy_p_pTf8xx_n'
sil [ossa] @copy_p_p : $@convention(thin) (@pack_guaranteed Pack{any P, any P}) -> @pack_out Pack{any P, any P} {
bb0(%0 : $*Pack{any P, any P}, %1 : $*Pack{any P, any P}):
  copy_addr %1 to [init] %0
  %11 = tuple ()
  return %11
}

// CHECK-LABEL: sil [ossa] @call_copy_p_p : $@convention(thin) (@pack_guaranteed Pack{any P, any P}) ->  @pack_out Pack{any P, any P} {
// CHECK-LABEL: } // end sil function 'call_copy_p_p'
sil [ossa] @call_copy_p_p : $@convention(thin) (@pack_guaranteed Pack{any P, any P}) -> @pack_out Pack{any P, any P} {
bb0(%0 : $*Pack{any P, any P}, %1: $*Pack{any P, any P}):
  %2 = function_ref @copy_p_p : $@convention(thin) (@pack_guaranteed Pack{any P, any P}) -> @pack_out Pack{any P, any P}
  %3 = apply %2(%0, %1) : $@convention(thin) (@pack_guaranteed Pack{any P, any P}) -> @pack_out Pack{any P, any P}
  %4 = tuple ()
  return %4
}

// EDGE CASE TESTS:

// Deallocation code should not be emitted at the end of a non-exiting terminator block.
// CHECK-LABEL: sil shared [ossa] @$s9crashableTf8x_n : $@convention(thin) (Builtin.Int64) -> () {
// CHECK:       bb0(%0 : $Builtin.Int64):
// CHECK-NEXT:    [[IN_PACK:%[0-9]+]] = alloc_pack $Pack{Builtin.Int64}
// CHECK-NEXT:    [[IN_IDX:%[0-9]+]] = scalar_pack_index 0 of $Pack{Builtin.Int64}
// CHECK-NEXT:    [[IN_ADDR:%[0-9]+]] = alloc_stack $Builtin.Int64
// CHECK-NEXT:    store %0 to [trivial] [[IN_ADDR]]
// CHECK-NEXT:    pack_element_set [[IN_ADDR]] into [[IN_IDX]] of [[IN_PACK]]
// CHECK-NEXT:    unreachable
// CHECK-LABEL: } // end sil function '$s9crashableTf8x_n'
sil [ossa] @crashable : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64}) -> () {
bb0(%0 : $*Pack{Builtin.Int64}):
  unreachable
}

// CHECK-LABEL: sil [ossa] @call_crashable : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64}) -> () {
// CHECK-LABEL: } // end sil function 'call_crashable'
sil [ossa] @call_crashable : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64}) -> () {
bb0(%0 : $*Pack{Builtin.Int64}):
  %1 = function_ref @crashable : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64}) -> ()
  %2 = apply %1(%0) : $@convention(thin) (@pack_guaranteed Pack{Builtin.Int64}) -> ()
  unreachable
}

// Pack-specialized functions should be converted to have a thin convention,
// unless they have a dynamic self parameter.

// CHECK-LABEL: sil shared [ossa] @$s27pack_method_no_dynamic_selfTf8x_n : $@convention(thin) (Int) -> () {
// CHECK-LABEL: } // end sil function '$s27pack_method_no_dynamic_selfTf8x_n'
sil [ossa] @pack_method_no_dynamic_self : $@convention(method) (@pack_guaranteed Pack{Int}) -> () {
bb0(%0 : $*Pack{Int}):
  %1 = tuple ()
  return %1
}

// If the function does have a dynamic self parameter, it must still be the last
// after pack specialization.
// CHECK-LABEL: sil shared [ossa] @$s29pack_method_with_dynamic_selfTf8xn_n : $@convention(method) (Int, @thick C.Type) -> () {
// CHECK-LABEL: } // end sil function '$s29pack_method_with_dynamic_selfTf8xn_n'
sil [ossa] @pack_method_with_dynamic_self : $@convention(method) (@pack_guaranteed Pack{Int}, @thick C.Type) -> () {
bb0(%0 : $*Pack{Int}, %1 : $@thick C.Type):
  %2 = metatype $@thick @dynamic_self C.Type
  %3 = tuple ()
  return %3
}

// CHECK-LABEL: sil [ossa] @call_pack_methods : $@convention(thin) (@pack_guaranteed Pack{Int}) -> () {
// CHECK:       bb0(%0 : $*Pack{Int}):
// CHECK:         function_ref @$s27pack_method_no_dynamic_selfTf8x_n : $@convention(thin) (Int) -> ()
// CHECK:         function_ref @$s29pack_method_with_dynamic_selfTf8xn_n : $@convention(method) (Int, @thick C.Type) -> ()
// CHECK-LABEL: } // end sil function 'call_pack_methods'
sil [ossa] @call_pack_methods : $@convention(thin) (@pack_guaranteed Pack{Int}) -> () {
bb0(%0 : $*Pack{Int}):
  %1 = function_ref @pack_method_no_dynamic_self : $@convention(method) (@pack_guaranteed Pack{Int}) -> ()
  %2 = apply %1(%0) : $@convention(method) (@pack_guaranteed Pack{Int}) -> ()

  %3 = metatype $@thick C.Type
  %4 = function_ref @pack_method_with_dynamic_self : $@convention(method) (@pack_guaranteed Pack{Int}, @thick C.Type) -> ()
  %5 = apply %4(%0, %3) : $@convention(method) (@pack_guaranteed Pack{Int}, @thick C.Type) -> ()
  return %2
}

// BAIL OUT CONDITION TESTS:
//
// Only perform pack specialization on functions that have indirect pack
// parameters that contain no pack expansions.
//
// 2025-10-15: We currently only explode packs with address elements
// (SILPackType::isElementAddress), because these are the most common (since
// they are created after generic specialization of most variadic generic
// functions), and expensive (since they introduce two layers of indirection).
// See the shouldExplode computed property in PackSpecialization.swift.
//
// This is an OSSA-only pass, so caller and callee must both be OSSA.


sil [ossa] @no_packs : $@convention(thin) (Int) -> () {
bb0(%0 : $Int):
  %1 = tuple ()
  return %1
}

sil [ossa] @indirect_pack : $@convention(thin) (@pack_guaranteed Pack{Int}) -> () {
bb0(%0 : $*Pack{Int}):
  %1 = tuple ()
  return %1
}

sil [ossa] @direct_pack : $@convention(thin) (@pack_guaranteed @direct Pack{Int}) -> () {
bb0(%0 : $*@direct Pack{Int}):
  %1 = tuple ()
  return %1
}

sil [ossa] @pack_expansion : $@convention(thin) <each A> (@pack_guaranteed Pack{repeat each A}) -> () {
bb0(%0 : $*Pack{repeat each A}):
  %1 = tuple ()
  return %1
}

sil [ossa] @mixed_packs : $@convention(thin) <each A> (@pack_guaranteed Pack{Int}, @pack_guaranteed @direct Pack{Int}, @pack_guaranteed Pack{repeat each A}) -> () {
bb0(%0 : $*Pack{Int}, %1 : $*@direct Pack{Int}, %2 : $*Pack{repeat each A}):
  %3 = tuple ()
  return %3
}

sil @non_ossa_callee : $@convention(thin) (@pack_guaranteed Pack{Int}) -> () {
bb0(%0 : $*Pack{Int}):
  %1 = tuple ()
  return %1
}

// CHECK-LABEL: sil [ossa] @call_eligibility_tests : $@convention(thin) <each A> (Int, @pack_guaranteed Pack{Int}, @pack_guaranteed @direct Pack{Int}, @pack_guaranteed Pack{repeat each A}) -> () {
// CHECK: bb0(%0 : $Int, %1 : $*Pack{Int}, %2 : $*@direct Pack{Int}, %3 : $*Pack{repeat each A}):
// CHECK: function_ref @no_packs : $@convention(thin) (Int) -> ()
// CHECK: function_ref @$s13indirect_packTf8x_n : $@convention(thin) (Int) -> ()
// CHECK: function_ref @direct_pack : $@convention(thin) (@pack_guaranteed @direct Pack{Int}) -> ()
// CHECK: function_ref @pack_expansion : $@convention(thin) <each τ_0_0> (@pack_guaranteed Pack{repeat each τ_0_0}) -> ()
// CHECK: function_ref @$s11mixed_packsTf8xnn_n : $@convention(thin) <each τ_0_0> (Int, @pack_guaranteed @direct Pack{Int}, @pack_guaranteed Pack{repeat each τ_0_0}) -> ()
// CHECK: function_ref @non_ossa_callee : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()
// CHECK-LABEL: } // end sil function 'call_eligibility_tests'
sil [ossa] @call_eligibility_tests : $@convention(thin) <each A> (Int, @pack_guaranteed Pack{Int}, @pack_guaranteed @direct Pack{Int}, @pack_guaranteed Pack{repeat each A}) -> () {
bb0(%0 : $Int, %1 : $*Pack{Int}, %2 : $*@direct Pack{Int}, %3 : $*Pack{repeat each A}):
  %4 = function_ref @no_packs : $@convention(thin) (Int) -> ()
  %5 = apply %4(%0) : $@convention(thin) (Int) -> ()

  %6 = function_ref @indirect_pack : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()
  %7 = apply %6(%1) : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()

  %8 = function_ref @direct_pack : $@convention(thin) (@pack_guaranteed @direct Pack{Int}) -> ()
  %9 = apply %8(%2) : $@convention(thin) (@pack_guaranteed @direct Pack{Int}) -> ()

  %10 = function_ref @pack_expansion : $@convention(thin) <each A> (@pack_guaranteed Pack{repeat each A}) -> ()
  %11 = apply %10<Pack{repeat each A}>(%3) : $@convention(thin) <each A> (@pack_guaranteed Pack{repeat each A}) -> ()

  %12 = function_ref @mixed_packs : $@convention(thin) <each A> (@pack_guaranteed Pack{Int}, @pack_guaranteed @direct Pack{Int}, @pack_guaranteed Pack{repeat each A}) -> ()
  %13 = apply %12<Pack{repeat each A}>(%1, %2, %3) : $@convention(thin) <each A> (@pack_guaranteed Pack{Int}, @pack_guaranteed @direct Pack{Int}, @pack_guaranteed Pack{repeat each A}) -> ()


  %14 = function_ref @non_ossa_callee : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()
  %15 = apply %14(%1) : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()

  %99 = tuple ()
  return %99
}

// CHECK-LABEL: sil @non_ossa_caller : $@convention(thin) (@pack_guaranteed Pack{Int}) -> () {
// CHECK: function_ref @indirect_pack : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()
// CHECK-LABEL: } // end sil function 'non_ossa_caller'
sil @non_ossa_caller : $@convention(thin) (@pack_guaranteed Pack{Int}) -> () {
bb0(%0 : $*Pack{Int}):
  %1 = function_ref @indirect_pack : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()
  %2 = apply %1(%0) : $@convention(thin) (@pack_guaranteed Pack{Int}) -> ()
  return %2
}
