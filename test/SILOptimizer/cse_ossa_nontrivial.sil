// RUN: %target-sil-opt -sil-print-types -enable-sil-verify-all %s -update-borrowed-from -cse | %FileCheck %s
// REQUIRES: PTRSIZE=64

sil_stage canonical

import Builtin
import Swift

///////////////
// CSE Tests //
///////////////
class SuperKlass {}

class Klass : SuperKlass {}

struct NonTrivialStruct {
  var val:Klass
}

public enum FakeOptional {
  case none
  case some(Klass)
}

public enum FakeOptional2 {
  case some1(UInt)
  case some2(Klass)
}

public enum FakeOptional3 {
  case none
  case some(WrapperStruct)
}

struct StructWithEnum {
  var val:FakeOptional
}

struct StructWithEnum2 {
  var val:FakeOptional2
}

sil @use_nontrivialstruct1 : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
sil @use_nontrivialstruct2 : $@convention(thin) (@owned NonTrivialStruct) -> ()
sil @use_nontrivialstruct3 : $@convention(thin) (@in_guaranteed NonTrivialStruct) -> ()
sil @use_superklass1 : $@convention(thin) (@owned SuperKlass) -> ()

// CHECK-LABEL: sil [ossa] @structliteral1 :
// CHECK: struct $NonTrivialStruct
// CHECK-NOT: struct $NonTrivialStruct
// CHECK-LABEL: } // end sil function 'structliteral1'
sil [ossa] @structliteral1 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %2 = struct $NonTrivialStruct (%0 : $Klass)
  %3 = struct $NonTrivialStruct (%0 : $Klass)
  %5 = function_ref @use_nontrivialstruct1 : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
  apply %5 (%2) : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
  apply %5 (%3) : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
  %res = tuple()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @structliteral2 :
// CHECK: struct $NonTrivialStruct
// CHECK-NOT: struct $NonTrivialStruct
// CHECK-LABEL: } // end sil function 'structliteral2'
sil [ossa] @structliteral2 : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %copy0 = copy_value %0 : $Klass
  %2 = struct $NonTrivialStruct (%0 : $Klass)
  %3 = struct $NonTrivialStruct (%copy0 : $Klass)
  %5 = function_ref @use_nontrivialstruct2 : $@convention(thin) (@owned NonTrivialStruct) -> ()
  apply %5 (%2) : $@convention(thin) (@owned NonTrivialStruct) -> ()
  apply %5 (%3) : $@convention(thin) (@owned NonTrivialStruct) -> ()
  %res = tuple()
  return %res : $()
}

sil [ossa] @sadd_with_address : $@convention(thin) (@inout Klass, @inout Klass) -> (Klass)

// CHECK-LABEL: sil [ossa] @project_box_test1 :
// CHECK: project_box %0 : $<τ_0_0> { var τ_0_0 } <Klass>
// CHECK-NOT: project_box
// CHECK-LABEL: } // end sil function 'project_box_test1'
sil [ossa] @project_box_test1 : $(@owned <τ_0_0> { var τ_0_0 } <Klass>) -> Klass {
bb0(%0 : @owned $<τ_0_0> { var τ_0_0 } <Klass>):
  %1 = project_box %0 : $<τ_0_0> { var τ_0_0 } <Klass>, 0
  %2 = project_box %0 : $<τ_0_0> { var τ_0_0 } <Klass>, 0
  %3 = function_ref @sadd_with_address : $@convention(thin) (@inout Klass, @inout Klass) -> (Klass)
  %4 = apply %3(%1, %2) : $@convention(thin) (@inout Klass, @inout Klass) -> (Klass)
  destroy_value %0 : $<τ_0_0> { var τ_0_0 } <Klass>
  return %4 : $(Klass)
}

// CHECK-LABEL: sil [ossa] @project_box_test2 :
// CHECK: project_box %0 : $<τ_0_0> { var τ_0_0 } <Klass>
// CHECK: project_box
// CHECK-LABEL: } // end sil function 'project_box_test2'
sil [ossa] @project_box_test2 : $(@owned <τ_0_0> { var τ_0_0 } <Klass>) -> Klass {
bb0(%0 : @owned $<τ_0_0> { var τ_0_0 } <Klass>):
  %1 = project_box %0 : $<τ_0_0> { var τ_0_0 } <Klass>, 0
  %copy0 = copy_value %0 : $<τ_0_0> { var τ_0_0 } <Klass>
  %2 = project_box %copy0 : $<τ_0_0> { var τ_0_0 } <Klass>, 0
  %3 = function_ref @sadd_with_address : $@convention(thin) (@inout Klass, @inout Klass) -> (Klass)
  %4 = apply %3(%1, %2) : $@convention(thin) (@inout Klass, @inout Klass) -> (Klass)
  destroy_value %copy0 : $<τ_0_0> { var τ_0_0 } <Klass>
  destroy_value %0 : $<τ_0_0> { var τ_0_0 } <Klass>
  return %4 : $(Klass)
}

// CHECK-LABEL: sil [ossa] @project_box_test3 :
// CHECK: project_box
// CHECK: project_box
// CHECK-LABEL: } // end sil function 'project_box_test3'
sil [ossa] @project_box_test3 : $(@owned <τ_0_0> { var τ_0_0 } <Klass>) -> Klass {
bb0(%0 : @owned $<τ_0_0> { var τ_0_0 } <Klass>):
  %copy0 = copy_value %0 : $<τ_0_0> { var τ_0_0 } <Klass>
  %2 = project_box %copy0 : $<τ_0_0> { var τ_0_0 } <Klass>, 0
  %1 = project_box %0 : $<τ_0_0> { var τ_0_0 } <Klass>, 0
  %3 = function_ref @sadd_with_address : $@convention(thin) (@inout Klass, @inout Klass) -> (Klass)
  %4 = apply %3(%1, %2) : $@convention(thin) (@inout Klass, @inout Klass) -> (Klass)
  destroy_value %copy0 : $<τ_0_0> { var τ_0_0 } <Klass>
  destroy_value %0 : $<τ_0_0> { var τ_0_0 } <Klass>
  return %4 : $(Klass)
}

sil [ossa] @tuple_function1 : $@convention(thin) (@owned (Klass, Klass), @owned (Klass, Klass)) -> @owned (Klass)
sil [ossa] @tuple_function2 : $@convention(thin) (@guaranteed (Klass, Klass), @guaranteed (Klass, Klass)) -> @owned (Klass)

// CHECK-LABEL: sil [ossa] @tuple_test1 :
// CHECK: tuple ({{%[0-9]+}} : $Klass, {{%[0-9]+}} : $Klass)
// CHECK-NOT: tuple ({{%[0-9]+}} : $Klass, {{%[0-9]+}} : $Klass)
// CHECK-LABEL: } // end sil function 'tuple_test1'
sil [ossa] @tuple_test1 : $@convention(thin) (@owned Klass, @owned Klass) -> @owned (Klass) {
bb0(%0 : @owned $Klass, %1 : @owned $Klass):
  %copy0 = copy_value %0 : $Klass
  %copy1 = copy_value %1 : $Klass
  %2 = tuple(%0 : $Klass, %1 : $Klass)
  %3 = tuple(%copy0 : $Klass, %copy1 : $Klass)
  %4 = function_ref @tuple_function1 : $@convention(thin) (@owned (Klass, Klass), @owned (Klass, Klass)) -> @owned (Klass)
  %5 = apply %4(%2, %3) : $@convention(thin) (@owned (Klass, Klass), @owned (Klass, Klass)) -> @owned (Klass)
  return %5 : $(Klass)
}

// mayIntroduceUnoptimizableCopies returns true because swift::areUsesWithinValueLifetime returns false
// since findOwnershipReferenceAggregate only looks through single operand forwarding instructions
// CHECK-LABEL: sil [ossa] @tuple_test2 :
// CHECK: tuple ({{%[0-9]+}} : $Klass, {{%[0-9]+}} : $Klass)
// TODO-CHECK-NOT: tuple ({{%[0-9]+}} : $Klass, {{%[0-9]+}} : $Klass)
// CHECK-LABEL: } // end sil function 'tuple_test2'
sil [ossa] @tuple_test2 : $@convention(thin) (@guaranteed Klass, @guaranteed Klass) -> @owned (Klass) {
bb0(%0 : @guaranteed $Klass, %1 : @guaranteed $Klass):
  %2 = tuple(%0 : $Klass, %1 : $Klass)
  %3 = tuple(%0 : $Klass, %1 : $Klass)
  %4 = function_ref @tuple_function2 : $@convention(thin) (@guaranteed (Klass, Klass), @guaranteed (Klass, Klass)) -> @owned (Klass)
  %5 = apply %4(%2, %3) : $@convention(thin) (@guaranteed (Klass, Klass), @guaranteed (Klass, Klass)) -> @owned (Klass)
  return %5 : $(Klass)
}

sil [ossa] @generate_tuple : $@convention(thin) () -> @owned ((Klass, Klass))

// CHECK-LABEL: sil [ossa] @tupleextract_test :
// CHECK: tuple_extract {{%[0-9]}} : $(Klass, Klass), 0
// CHECK-NOT: tuple_extract {{%[0-9]}} : $(Klass, Klass), 0
// CHECK-LABEL: } // end sil function 'tupleextract_test'
sil [ossa] @tupleextract_test : $@convention(thin) () -> @owned (Klass) {
  %0 = function_ref @generate_tuple : $@convention(thin) () -> @owned ((Klass, Klass))
  %1 = apply %0() : $@convention(thin) () -> @owned ((Klass, Klass))
  %borrow1 = begin_borrow %1 : $(Klass, Klass)
  %2 = tuple_extract %borrow1 : $(Klass, Klass), 0
  %3 = tuple_extract %borrow1 : $(Klass, Klass), 0
  %5 = integer_literal $Builtin.Int1, 0
  %6 = builtin "sadd_with_overflow_Int32" (%2 : $Klass, %3 : $Klass, %5 : $Builtin.Int1) : $(Klass, Builtin.Int1)
  %7 = tuple_extract %6 : $(Klass, Builtin.Int1), 0
  end_borrow %borrow1 : $(Klass, Klass)
  destroy_value %1 : $(Klass, Klass)
  return %7 : $(Klass)
}

sil [ossa] @helper : $@convention(thin) (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word
sil [ossa] @helper2 : $@convention(thin) (UInt8, UInt8) -> Builtin.Word

// CHECK-LABEL: sil [ossa] @enum_cse :
// CHECK: enum $FakeOptional, #FakeOptional.none!enumelt
// CHECK-NOT: enum $FakeOptional, #FakeOptional.none!enumelt
// CHECK: enum $FakeOptional, #FakeOptional.some!enumelt
// CHECK-NOT: enum $FakeOptional, #FakeOptional.some!enumelt
// CHECK-LABEL: } // end sil function 'enum_cse'
sil [ossa] @unknown_fake_optional_user : $@convention(thin) (FakeOptional) -> ()
sil [ossa] @enum_cse : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %func = function_ref @unknown_fake_optional_user : $@convention(thin) (FakeOptional) -> ()
  %1 = enum $FakeOptional, #FakeOptional.none!enumelt
  %2 = enum $FakeOptional, #FakeOptional.none!enumelt
  apply %func(%1) : $@convention(thin) (FakeOptional) -> ()
  apply %func(%2) : $@convention(thin) (FakeOptional) -> ()
  %4 = enum $FakeOptional, #FakeOptional.some!enumelt, %0 : $Klass
  %5 = enum $FakeOptional, #FakeOptional.some!enumelt, %0 : $Klass
  apply %func(%4) : $@convention(thin) (FakeOptional) -> ()
  apply %func(%5) : $@convention(thin) (FakeOptional) -> ()
  %6 = tuple()
  return %6 : $()
}

sil [ossa] @klass_user : $@convention(thin) (@guaranteed Klass) -> ()

// CHECK-LABEL: sil [ossa] @unchecked_enum_data_cse :
// CHECK: unchecked_enum_data
// CHECK-NOT: unchecked_enum_data
// CHECK-LABEL: } // end sil function 'unchecked_enum_data_cse'
sil [ossa] @unchecked_enum_data_cse : $@convention(thin) (@guaranteed FakeOptional) -> () {
bb0(%0 : @guaranteed $FakeOptional):
  %1 = function_ref @klass_user : $@convention(thin) (@guaranteed Klass) -> ()
  %2 = unchecked_enum_data %0 : $FakeOptional, #FakeOptional.some!enumelt
  %3 = unchecked_enum_data %0 : $FakeOptional, #FakeOptional.some!enumelt
  apply %1(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  apply %1(%3) : $@convention(thin) (@guaranteed Klass) -> ()
  %6 = tuple()
  return %6 : $()
}

// CHECK-LABEL: sil [ossa] @test2cse1 :
// CHECK: ref_to_raw_pointer
// CHECK-NOT: ref_to_raw_pointer
// CHECK: function_ref
// CHECK: apply
// CHECK-LABEL: } // end sil function 'test2cse1'
sil [ossa] @test2cse1 : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = ref_to_raw_pointer %0 : $Klass to $Builtin.RawPointer
  %2 = ref_to_raw_pointer %0 : $Klass to $Builtin.RawPointer
  %4 = function_ref @helper : $@convention(thin) (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word
  %5 = apply %4(%1, %2) : $@convention(thin) (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word
  destroy_value %0 : $Klass
  %6 = tuple()
  return %6 : $()
}

// CHECK-LABEL: sil [ossa] @test2cse2 :
// CHECK: ref_to_raw_pointer
// CHECK: ref_to_raw_pointer
// CHECK: function_ref
// CHECK: apply
// CHECK-LABEL: } // end sil function 'test2cse2'
sil [ossa] @test2cse2 : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %copy0 = copy_value %0 : $Klass
  %1 = ref_to_raw_pointer %0 : $Klass to $Builtin.RawPointer
  %2 = ref_to_raw_pointer %copy0 : $Klass to $Builtin.RawPointer
  %4 = function_ref @helper : $@convention(thin) (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word
  %5 = apply %4(%1, %2) : $@convention(thin) (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word
  destroy_value %copy0 : $Klass
  destroy_value %0 : $Klass
  %6 = tuple()
  return %6 : $()
}

// CHECK-LABEL: sil [ossa] @cse_raw_pointer_to_ref :
// CHECK: raw_pointer_to_ref
// CHECK-NOT: raw_pointer_to_ref
// CHECK: tuple
// CHECK-LABEL: } // end sil function 'cse_raw_pointer_to_ref'
sil [ossa] @cse_raw_pointer_to_ref : $@convention(thin) (Builtin.RawPointer) -> (Klass, Klass) {
bb0(%0 : $Builtin.RawPointer):
  %1 = raw_pointer_to_ref %0 : $Builtin.RawPointer to $Klass
  %2 = raw_pointer_to_ref %0 : $Builtin.RawPointer to $Klass
  %6 = tuple(%1: $Klass, %2: $Klass)
  return %6 : $(Klass, Klass)
}

enum Enum1 {
    case Case1
    case Case2
}

// CHECK-LABEL: sil [ossa] @cse_select_enum :
// CHECK: select_enum
// CHECK-NOT: select_enum
// CHECK: tuple
// CHECK-LABEL: } // end sil function 'cse_select_enum'
sil [ossa] @cse_select_enum : $@convention(thin) (@guaranteed Enum1) -> (Builtin.Int1, Builtin.Int1) {
bb0(%0 : $Enum1):
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  %1 = select_enum %0 : $Enum1, case #Enum1.Case1!enumelt: %t, case #Enum1.Case2!enumelt: %f : $Builtin.Int1
  %2 = select_enum %0 : $Enum1, case #Enum1.Case1!enumelt: %t, case #Enum1.Case2!enumelt: %f : $Builtin.Int1
  %3 = tuple (%1: $Builtin.Int1, %2: $Builtin.Int1)
  return %3: $(Builtin.Int1, Builtin.Int1)
}

// CHECK-LABEL:   sil [ossa] @cse_bridge_object_to_word1 :
// CHECK:           [[REF:%[0-9]+]] = bridge_object_to_word
// CHECK-NOT:       bridge_object_to_word
// CHECK:           tuple ([[REF]] : $Builtin.Word, [[REF]] : $Builtin.Word)
// CHECK-LABEL: } // end sil function 'cse_bridge_object_to_word1'
sil [ossa] @cse_bridge_object_to_word1 : $@convention(thin) (@owned Builtin.BridgeObject) -> (Builtin.Word, Builtin.Word) {
bb0(%0 : @owned $Builtin.BridgeObject):
  %1 = bridge_object_to_word %0 : $Builtin.BridgeObject to $Builtin.Word
  %2 = bridge_object_to_word %0 : $Builtin.BridgeObject to $Builtin.Word
  %3 = tuple (%1 : $Builtin.Word, %2 : $Builtin.Word)
  destroy_value %0 : $Builtin.BridgeObject
  return %3 : $(Builtin.Word, Builtin.Word)
}

// CHECK-LABEL:   sil [ossa] @cse_bridge_object_to_word2 :
// CHECK:           [[REF:%[0-9]+]] = bridge_object_to_word
// CHECK:           bridge_object_to_word
// CHECK-LABEL: } // end sil function 'cse_bridge_object_to_word2'
sil [ossa] @cse_bridge_object_to_word2 : $@convention(thin) (@owned Builtin.BridgeObject) -> (Builtin.Word, Builtin.Word) {
bb0(%0 : @owned $Builtin.BridgeObject):
  %copy = copy_value %0 : $Builtin.BridgeObject
  %1 = bridge_object_to_word %0 : $Builtin.BridgeObject to $Builtin.Word
  %2 = bridge_object_to_word %copy : $Builtin.BridgeObject to $Builtin.Word
  %3 = tuple (%1 : $Builtin.Word, %2 : $Builtin.Word)
  destroy_value %copy : $Builtin.BridgeObject
  destroy_value %0 : $Builtin.BridgeObject
  return %3 : $(Builtin.Word, Builtin.Word)
}

// CHECK-LABEL:   sil [ossa] @cse_bridge_object_to_word3 :
// CHECK:           [[REF:%[0-9]+]] = bridge_object_to_word
// CHECK:           bridge_object_to_word
// CHECK-LABEL: } // end sil function 'cse_bridge_object_to_word3'
sil [ossa] @cse_bridge_object_to_word3 : $@convention(thin) (@owned Builtin.BridgeObject) -> (Builtin.Word, Builtin.Word) {
bb0(%0 : @owned $Builtin.BridgeObject):
  %copy = copy_value %0 : $Builtin.BridgeObject
  %2 = bridge_object_to_word %copy : $Builtin.BridgeObject to $Builtin.Word
  %1 = bridge_object_to_word %0 : $Builtin.BridgeObject to $Builtin.Word
  %3 = tuple (%1 : $Builtin.Word, %2 : $Builtin.Word)
  destroy_value %copy : $Builtin.BridgeObject
  destroy_value %0 : $Builtin.BridgeObject
  return %3 : $(Builtin.Word, Builtin.Word)
}

class Ping {
  func ping() -> Ping
}
sil [ossa]  @_TFC4main4Ping4pingfS0_FT_S0_ : $@convention(method) (@guaranteed Ping) -> @owned Ping
sil [ossa]  @_TFC4main4PingD : $@convention(method) (@owned Ping) -> ()
sil [ossa]  @_TFC4main4PingcfMS0_FT_S0_ : $@convention(method) (@owned Ping) -> @owned Ping

// TODO: In order to cse this, we have to handle class_method with copy_value in InstructionIdentityComparer
// CHECK-LABEL: sil [ossa] @_TF4main4ringFCS_4PingT_ :
// CHECK:      class_method
// CHECK:      class_method
// CHECK-LABEL: } // end sil function '_TF4main4ringFCS_4PingT_'
sil [ossa] @_TF4main4ringFCS_4PingT_ : $@convention(thin) (@owned Ping) -> () {
bb0(%0 : @owned $Ping):
  %copy0 = copy_value %0 : $Ping
  %1 = class_method %0 : $Ping, #Ping.ping : (Ping) -> () -> Ping, $@convention(method) (@guaranteed Ping) -> @owned Ping
  %1a = class_method %copy0 : $Ping, #Ping.ping : (Ping) -> () -> Ping, $@convention(method) (@guaranteed Ping) -> @owned Ping
  %2 = apply %1(%0) : $@convention(method) (@guaranteed Ping) -> @owned Ping
  %2a = apply %1a(%0) : $@convention(method) (@guaranteed Ping) -> @owned Ping
  destroy_value %2 : $Ping
  destroy_value %2a : $Ping
  destroy_value %copy0 : $Ping
  destroy_value %0 : $Ping
  %10 = tuple ()
  return %10 : $()
}

sil_vtable Ping {
  #Ping.ping: @_TFC4main4Ping4pingfS0_FT_S0_	// main.Ping.ping (main.Ping)() -> main.Ping
  #Ping.deinit!deallocator: @_TFC4main4PingD	// main.Ping.__deallocating_deinit
  #Ping.init!initializer: @_TFC4main4PingcfMS0_FT_S0_	// main.Ping.init (main.Ping.Type)() -> main.Ping
}

struct KlassPair {
 var first: Klass
 var second: Klass
}

// Support destructure_struct in CSE after introducing support for MultipleValueInstruction is OSSA's rauw utility
// CHECK-LABEL: sil [ossa] @destructure_struct_test1 :
// CHECK:       destructure_struct
// TODOCHECK-NOT:   destructure_struct
// CHECK-LABEL: } // end sil function 'destructure_struct_test1'
sil [ossa] @destructure_struct_test1 : $@convention(thin) (@owned KlassPair) -> () {
bb0(%0 : @owned $KlassPair):
  %copy0 = copy_value %0: $KlassPair
  (%1, %2) = destructure_struct %0 : $KlassPair
  (%3, %4) = destructure_struct %copy0 : $KlassPair
  destroy_value %1 : $Klass
  destroy_value %2 : $Klass
  destroy_value %3 : $Klass
  destroy_value %4 : $Klass
  %res = tuple ()
  return %res : $()
}

// Support destructure_struct in CSE after introducing support for MultipleValueInstruction is OSSA's rauw utility
// CHECK-LABEL: sil [ossa] @destructure_struct_test2 :
// CHECK:       destructure_struct
// TODOCHECK-NOT:   destructure_struct
// CHECK-LABEL: } // end sil function 'destructure_struct_test2'
sil [ossa] @destructure_struct_test2 : $@convention(thin) (@guaranteed KlassPair) -> () {
bb0(%0 : @guaranteed $KlassPair):
  (%1, %2) = destructure_struct %0 : $KlassPair
  (%3, %4) = destructure_struct %0 : $KlassPair
  %func = function_ref @klass_user : $@convention(thin) (@guaranteed Klass) -> ()
  apply %func(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  apply %func(%3) : $@convention(thin) (@guaranteed Klass) -> ()
  %res = tuple ()
  return %res : $()
}

// Support destructure_tuple in CSE after introducing support for MultipleValueInstruction is OSSA's rauw utility
// CHECK-LABEL: sil [ossa] @destructure_tuple_test1 :
// CHECK:       destructure_tuple
// TODOCHECK-NOT:   destructure_tuple
// CHECK-LABEL: } // end sil function 'destructure_tuple_test1'
sil [ossa] @destructure_tuple_test1 : $@convention(thin) (@owned (Klass, Klass)) -> () {
bb0(%0 : @owned $(Klass, Klass)):
  %copy0 = copy_value %0: $(Klass, Klass)
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  (%3, %4) = destructure_tuple %copy0 : $(Klass, Klass)
  destroy_value %1 : $Klass
  destroy_value %2 : $Klass
  destroy_value %3 : $Klass
  destroy_value %4 : $Klass
  %res = tuple ()
  return %res : $()
}

// Support destructure_tuple in CSE after introducing support for MultipleValueInstruction is OSSA's rauw utility
// CHECK-LABEL: sil [ossa] @destructure_tuple_test2 :
// CHECK:       destructure_tuple
// TODOCHECK-NOT:   destructure_tuple
// CHECK-LABEL: } // end sil function 'destructure_tuple_test2'
sil [ossa] @destructure_tuple_test2 : $@convention(thin) (@guaranteed (Klass, Klass)) -> () {
bb0(%0 : @guaranteed $(Klass, Klass)):
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  (%3, %4) = destructure_tuple %0 : $(Klass, Klass)
  %func = function_ref @klass_user : $@convention(thin) (@guaranteed Klass) -> ()
  apply %func(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  apply %func(%3) : $@convention(thin) (@guaranteed Klass) -> ()
  %res = tuple ()
  return %res : $()
}


// CHECK-LABEL: sil [ossa] @struct_test2 :
// CHECK: struct $NonTrivialStruct
// TODO-CHECK-NOT: struct $NonTrivialStruct
// CHECK-LABEL: } // end sil function 'struct_test2'
sil [ossa] @struct_test2 : $@convention(thin) (@guaranteed Klass) -> @owned Klass {
bb0(%0 : @guaranteed $Klass):
  %copy0 = copy_value %0 : $Klass
  %1 = struct $NonTrivialStruct (%copy0 : $Klass)
  %2 = struct $NonTrivialStruct (%0 : $Klass)
  %3 = struct_extract %2 : $NonTrivialStruct, #NonTrivialStruct.val
  destroy_value %1 : $NonTrivialStruct
  %copy3 = copy_value %3 : $Klass
  return %copy3 : $Klass
}

// CHECK-LABEL: sil [ossa] @struct_test3 :
// CHECK: struct $NonTrivialStruct
// TODO-CHECK-NOT: struct $NonTrivialStruct
// CHECK-LABEL: } // end sil function 'struct_test3'
sil [ossa] @struct_test3 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %copy0 = copy_value %0 : $Klass
  %1 = struct $NonTrivialStruct (%copy0 : $Klass)
  %2 = struct $NonTrivialStruct (%0 : $Klass)
  %3 = struct_extract %2 : $NonTrivialStruct, #NonTrivialStruct.val
  destroy_value %1 : $NonTrivialStruct
  %copy3 = copy_value %3 : $Klass
  destroy_value %copy3 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @struct_test4 :
// CHECK: struct $NonTrivialStruct
// CHECK-NOT: struct $NonTrivialStruct
// CHECK-LABEL: } // end sil function 'struct_test4'
sil [ossa] @struct_test4 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = struct $NonTrivialStruct (%0 : $Klass)
  %2 = struct $NonTrivialStruct (%0 : $Klass)
  %3 = struct_extract %2 : $NonTrivialStruct, #NonTrivialStruct.val
  %4 = struct_extract %1 : $NonTrivialStruct, #NonTrivialStruct.val
  %copy3 = copy_value %3 : $Klass
  %copy4 = copy_value %4 : $Klass
  destroy_value %copy3 : $Klass
  destroy_value %copy4 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @struct_test5 :
// CHECK: struct $NonTrivialStruct
// CHECK-NOT: struct $NonTrivialStruct
// CHECK-LABEL: } // end sil function 'struct_test5'
sil [ossa] @struct_test5 : $@convention(thin) (@guaranteed Klass) -> @owned Klass {
bb0(%0 : @guaranteed $Klass):
  %copy0 = copy_value %0 : $Klass
  %2 = struct $NonTrivialStruct (%0 : $Klass)
  %1 = struct $NonTrivialStruct (%copy0 : $Klass)
  %3 = struct_extract %2 : $NonTrivialStruct, #NonTrivialStruct.val
  destroy_value %1 : $NonTrivialStruct
  %copy3 = copy_value %3 : $Klass
  return %copy3 : $Klass
}

// CHECK-LABEL: sil [ossa] @struct_extract_test1 :
// CHECK:       struct_extract
// TODO-CHECK-NOT:   struct_extract
// CHECK-LABEL: } // end sil function 'struct_extract_test1'
sil [ossa] @struct_extract_test1 : $@convention(thin) (@owned NonTrivialStruct) -> @owned Klass {
bb0(%0 : @owned $NonTrivialStruct):
  %borrow0 = begin_borrow %0 : $NonTrivialStruct
  %2 = struct_extract %borrow0 : $NonTrivialStruct, #NonTrivialStruct.val
  %copy2 = copy_value %2 : $Klass
  end_borrow %borrow0 : $NonTrivialStruct
  %borrow1 = begin_borrow %0 : $NonTrivialStruct
  %3 = struct_extract %borrow1 : $NonTrivialStruct, #NonTrivialStruct.val
  %copy3 = copy_value %3 : $Klass
  end_borrow %borrow1 : $NonTrivialStruct
  destroy_value %copy2 : $Klass
  destroy_value %0 : $NonTrivialStruct
  return %copy3 : $Klass
}

// CHECK-LABEL: sil [ossa] @struct_extract_test2 :
// CHECK: struct_extract
// CHECK-NOT: struct_extract
// CHECK-LABEL: } // end sil function 'struct_extract_test2'
sil [ossa] @struct_extract_test2 : $@convention(thin) (@guaranteed NonTrivialStruct) -> () {
bb0(%0 : @guaranteed $NonTrivialStruct):
  %1 = struct_extract %0 : $NonTrivialStruct, #NonTrivialStruct.val
  %copy1 = copy_value %1 : $Klass
  %2 = struct_extract %0 : $NonTrivialStruct, #NonTrivialStruct.val
  %copy2 = copy_value %2 : $Klass
  destroy_value %copy1 : $Klass
  destroy_value %copy2 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @struct_extract_test3 :
// CHECK: struct_extract
// CHECK-NOT: struct_extract
// CHECK-LABEL: } // end sil function 'struct_extract_test3'
sil [ossa] @struct_extract_test3 : $@convention(thin) (@guaranteed StructWithEnum) -> () {
bb0(%0 : @guaranteed $StructWithEnum):
  %1 = struct_extract %0 : $StructWithEnum, #StructWithEnum.val
  %copy1 = copy_value %1 : $FakeOptional
  switch_enum %1 : $FakeOptional, case #FakeOptional.some!enumelt:bb1, case #FakeOptional.none!enumelt:bb2

bb1(%arg1 : @guaranteed $Klass):
  br bb3

bb2:
  br bb3

bb3:
  %2 = struct_extract %0 : $StructWithEnum, #StructWithEnum.val
  %copy2 = copy_value %2 : $FakeOptional
  switch_enum %2 : $FakeOptional, case #FakeOptional.some!enumelt:bb4, case #FakeOptional.none!enumelt:bb5

bb4(%arg2 : @guaranteed $Klass):
  br bb6

bb5:
  br bb6

bb6:
  destroy_value %copy1 : $FakeOptional
  destroy_value %copy2 : $FakeOptional
  %res = tuple ()
  return %res : $()
}

// This CSE test will need the OSSA rauw utility to split edges
// CHECK-LABEL: sil [ossa] @struct_extract_test4 :
// CHECK: struct_extract
// CHECK-NOT: struct_extract
// CHECK-LABEL: } // end sil function 'struct_extract_test4'
sil [ossa] @struct_extract_test4 : $@convention(thin) (@guaranteed StructWithEnum2) -> () {
bb0(%0 : @guaranteed $StructWithEnum2):
  %1 = struct_extract %0 : $StructWithEnum2, #StructWithEnum2.val
  %copy1 = copy_value %1 : $FakeOptional2
  br bb4

bb4:
  %2 = struct_extract %0 : $StructWithEnum2, #StructWithEnum2.val
  %copy2 = copy_value %2 : $FakeOptional2
  switch_enum %2 : $FakeOptional2, case #FakeOptional2.some1!enumelt:bb5, case #FakeOptional2.some2!enumelt:bb6

bb5(%arg4 : $UInt):
  br bb7(%arg4 : $UInt)

bb6(%arg5 : @guaranteed $Klass):
  %4 = unchecked_trivial_bit_cast %arg5 : $Klass to $UInt
  br bb7(%4 : $UInt)

bb7(%arg6 : $UInt):
  destroy_value %copy2 : $FakeOptional2
  br bb8

bb8:
  destroy_value %copy1 : $FakeOptional2
  %res = tuple ()
  return %res : $()
}

struct RecurStruct {
  var val:NonTrivialStruct
}

// Test to make sure we do not crash on a use after free when the branch instructions in bb1 and bb2 are deleted
//
// FIXME: Fix OwnershipRAUW to handle guaranteed uses of the old CSE'd
// value that are reborrows. The reborrowed uses are not dominated by
// the old value, but they are still within the new values borrow scope.
//
// CHECK-LABEL: sil [ossa] @test_useafterfreeinrauw :
// CHECK: bb0
// CHECK: struct_extract
// FIXME-CHECK-NOT: struct_extract
// CHECK: cond_br
// CHECK-LABEL: } // end sil function 'test_useafterfreeinrauw'
sil [ossa] @test_useafterfreeinrauw : $@convention(thin) (@guaranteed RecurStruct) -> @owned NonTrivialStruct {
bb0(%0 : @guaranteed $RecurStruct):
  %1 = struct_extract %0 : $RecurStruct, #RecurStruct.val
  debug_value %1 : $NonTrivialStruct
  %2 = struct_extract %0 : $RecurStruct, #RecurStruct.val
  cond_br undef, bb1, bb2

bb1:
  %3 = struct_extract %2 : $NonTrivialStruct, #NonTrivialStruct.val
  br bb3(%3 : $Klass)

bb2:
  %4 = struct_extract %2 : $NonTrivialStruct, #NonTrivialStruct.val
  br bb3(%4 : $Klass)

bb3(%borrow : @guaranteed $Klass):
  %copy = copy_value %1 : $NonTrivialStruct
  return %copy : $NonTrivialStruct
}

// Test to make sure we clear the context if we fail while checking if ownership rauw is possible
// CHECK-LABEL: sil [ossa] @test_rauwfailsandthensucceeds :
// CHECK: bb0
// CHECK: struct_extract
// TODO-CHECK: struct_extract
// CHECK: struct $_SliceBuffer
// TODO-CHECK-NOT: struct $_SliceBuffer
// CHECK-LABEL: } // end sil function 'test_rauwfailsandthensucceeds'
sil [ossa] @test_rauwfailsandthensucceeds : $@convention(method) <Element> (UnsafeMutablePointer<Element>, @guaranteed _ContiguousArrayBuffer<Element>, Int, UInt) -> @owned _SliceBuffer<Element> {
bb0(%0 : $UnsafeMutablePointer<Element>, %1 : @guaranteed $_ContiguousArrayBuffer<Element>, %2 : $Int, %3 : $UInt):
  %4 = struct_extract %1 : $_ContiguousArrayBuffer<Element>, #_ContiguousArrayBuffer._storage
  %5 = copy_value %4 : $__ContiguousArrayStorageBase
  %6 = init_existential_ref %5 : $__ContiguousArrayStorageBase : $__ContiguousArrayStorageBase, $AnyObject
  %7 = struct_extract %1 : $_ContiguousArrayBuffer<Element>, #_ContiguousArrayBuffer._storage
  %8 = ref_tail_addr %7 : $__ContiguousArrayStorageBase, $Element
  %9 = address_to_pointer %8 : $*Element to $Builtin.RawPointer
  %10 = struct $UnsafeMutablePointer<Element> (%9 : $Builtin.RawPointer)
  %11 = begin_borrow %6 : $AnyObject
  %12 = struct $_SliceBuffer<Element> (%11 : $AnyObject, %0 : $UnsafeMutablePointer<Element>, %2 : $Int, %3 : $UInt)
  %13 = copy_value %12 : $_SliceBuffer<Element>
  end_borrow %11 : $AnyObject
  destroy_value %13 : $_SliceBuffer<Element>
  %14 = begin_borrow %6 : $AnyObject
  %15 = struct $_SliceBuffer<Element> (%14 : $AnyObject, %0 : $UnsafeMutablePointer<Element>, %2 : $Int, %3 : $UInt)
  %16 = copy_value %15 : $_SliceBuffer<Element>
  end_borrow %14 : $AnyObject
  %17 = struct $_SliceBuffer<Element> (%6 : $AnyObject, %0 : $UnsafeMutablePointer<Element>, %2 : $Int, %3 : $UInt)
  destroy_value %17 : $_SliceBuffer<Element>
  return %16 : $_SliceBuffer<Element>
}

sil [ossa] @use_word1 : $@convention(thin) (@inout _UnsafeBitset.Word) -> ()

// TODO: Disable the TODO check when rauw address users correctly replaces all uses of the old ref_tail_addr with the new ref_tail_addr.
// CHECK-LABEL: sil [ossa] @test_reftailaddr :
// CHECK: bb0
// CHECK: ref_tail_addr
// TODO-CHECK-NOT: ref_tail_addr
// CHECK-LABEL: } // end sil function 'test_reftailaddr'
sil [ossa] @test_reftailaddr : $@convention(thin) (@owned __RawSetStorage) -> () {
bb0(%0 : @owned $__RawSetStorage):
  %func  = function_ref @use_word1 : $@convention(thin) (@inout _UnsafeBitset.Word) -> ()
  %1 = copy_value %0 : $__RawSetStorage
  %2 = begin_borrow %1 : $__RawSetStorage
  %3 = ref_tail_addr %2 : $__RawSetStorage, $_UnsafeBitset.Word
  apply %func(%3) : $@convention(thin) (@inout _UnsafeBitset.Word) -> ()
  end_borrow %2 : $__RawSetStorage
  %4 = copy_value %0 : $__RawSetStorage
  %5 = begin_borrow %4 : $__RawSetStorage
  %6 = ref_tail_addr %5 : $__RawSetStorage, $_UnsafeBitset.Word
  apply %func(%6) : $@convention(thin) (@inout _UnsafeBitset.Word) -> ()
  end_borrow %5 : $__RawSetStorage
  destroy_value %1 : $__RawSetStorage
  destroy_value %4 : $__RawSetStorage
  destroy_value %0 : $__RawSetStorage
  %res  = tuple ()
  return %res : $()
}

class WrapperKlass {
  var val:Builtin.NativeObject
}

sil [ossa] @use_object : $@convention(thin) (@inout Builtin.NativeObject) -> ()

// CHECK-LABEL: sil [ossa] @test_refelementaddr :
// CHECK: bb0
// CHECK: ref_element_addr
// CHECK-NOT: ref_element_addr
// CHECK-LABEL: } // end sil function 'test_refelementaddr'
sil [ossa] @test_refelementaddr : $@convention(thin) (@guaranteed WrapperKlass) -> () {
bb0(%0 : @guaranteed $WrapperKlass):
  %func  = function_ref @use_object : $@convention(thin) (@inout Builtin.NativeObject) -> ()
  %ele1 = ref_element_addr %0 : $WrapperKlass, #WrapperKlass.val
  apply %func(%ele1) : $@convention(thin) (@inout Builtin.NativeObject) -> ()
  %copy0 = copy_value %0 : $WrapperKlass
  %borrow = begin_borrow %copy0 : $WrapperKlass
  %ele2 = ref_element_addr %borrow : $WrapperKlass, #WrapperKlass.val
  apply %func(%ele2) : $@convention(thin) (@inout Builtin.NativeObject) -> ()
  end_borrow %borrow : $WrapperKlass
  destroy_value %copy0 : $WrapperKlass
  %res  = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @test_refelementaddr_loop : {{.*}} {
// CHECK:         ref_element_addr
// CHECK:         ref_element_addr
// CHECK-LABEL: } // end sil function 'test_refelementaddr_loop'
sil [ossa] @test_refelementaddr_loop : $@convention(thin) () -> () {
bb0:
  %2 = apply undef() : $@convention(thin) () -> @owned WrapperKlass
  %3 = move_value [lexical] [var_decl] %2 : $WrapperKlass
  br bb1 

bb1:
  %func  = function_ref @use_object : $@convention(thin) (@inout Builtin.NativeObject) -> ()
  %borrow1 = begin_borrow %3 : $WrapperKlass
  %ele1 = ref_element_addr %borrow1 : $WrapperKlass, #WrapperKlass.val
  apply %func(%ele1) : $@convention(thin) (@inout Builtin.NativeObject) -> ()
  end_borrow %borrow1 : $WrapperKlass
  %borrow2 = begin_borrow %3 : $WrapperKlass
  %ele2 = ref_element_addr %borrow2 : $WrapperKlass, #WrapperKlass.val
  apply %func(%ele2) : $@convention(thin) (@inout Builtin.NativeObject) -> ()
  end_borrow %borrow2 : $WrapperKlass
  br bb1 
}

sil [ossa] @use_word2 : $@convention(thin) (@inout Builtin.Word) -> ()

/*
// TODO: Enable this test after the verifier correctly handles the case a ref_tail_addr's result is used in an unchecked_addr_cast
// TODOCHECK-LABEL: sil [ossa] @test_uncheckedaddrcast :
// TODOCHECK: bb0
// TODOCHECK: unchecked_addr_cast
// TODO-CHECK-NOT: unchecked_addr_cast
// TODOCHECK-LABEL: } // end sil function 'test_uncheckedaddrcast'
sil [ossa] @test_reftailaddr : $@convention(thin) (@owned __RawSetStorage) -> () {
bb0(%0 : @owned $__RawSetStorage):
  %func = function_ref @use_word2 : $@convention(thin) (@inout Builtin.Word) -> ()
  %1 = copy_value %0 : $__RawSetStorage
  %2 = begin_borrow %1 : $__RawSetStorage
  %3 = ref_tail_addr %2 : $__RawSetStorage, $_UnsafeBitset.Word
  %cast1 = unchecked_addr_cast %3 : $*_UnsafeBitset.Word to $*Builtin.Word
  apply %func(%cast1) : $@convention(thin) (@inout Builtin.Word) -> ()
  end_borrow %2 : $__RawSetStorage
  %4 = copy_value %0 : $__RawSetStorage
  %5 = begin_borrow %4 : $__RawSetStorage
  %6 = ref_tail_addr %5 : $__RawSetStorage, $_UnsafeBitset.Word
  %cast2 = unchecked_addr_cast %6 : $*_UnsafeBitset.Word to $*Builtin.Word
  apply %func(%cast2) : $@convention(thin) (@inout Builtin.Word) -> ()
  end_borrow %5 : $__RawSetStorage
  destroy_value %1 : $__RawSetStorage
  destroy_value %4 : $__RawSetStorage
  destroy_value %0 : $__RawSetStorage
  %res  = tuple ()
  return %res : $()
}
*/

sil [ossa] @use_bridgeobject : $@convention(thin) (Builtin.BridgeObject) -> ()

// CHECK-LABEL: sil [ossa] @test_valuetobridgeobject :
// CHECK: bb0
// CHECK: value_to_bridge_object
// CHECK: value_to_bridge_object
// CHECK-LABEL: } // end sil function 'test_valuetobridgeobject'
sil [ossa] @test_valuetobridgeobject : $@convention(thin) (@guaranteed WrapperKlass) -> () {
bb0(%0 : @guaranteed $WrapperKlass):
  %func  = function_ref @use_bridgeobject : $@convention(thin) (Builtin.BridgeObject) -> ()
  %1 = value_to_bridge_object %0 : $WrapperKlass
  apply %func(%1) : $@convention(thin) (Builtin.BridgeObject) -> ()
  %borrow = begin_borrow %0 : $WrapperKlass
  %2 = value_to_bridge_object %borrow : $WrapperKlass
  apply %func(%2) : $@convention(thin) (Builtin.BridgeObject) -> ()
  end_borrow %borrow : $WrapperKlass
  %res  = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @cse_upcast_loop :
// CHECK: upcast
// CHECK-NOT: upcast
// CHECK-LABEL: } // end sil function 'cse_upcast_loop'
sil [ossa] @cse_upcast_loop : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %func  = function_ref @use_superklass1 : $@convention(thin) (@owned SuperKlass) -> ()
  %copy0 = copy_value %0 : $Klass
  %1 = upcast %copy0 : $Klass to $SuperKlass
  apply %func(%1) : $@convention(thin) (@owned SuperKlass) -> ()
  br bb1

bb1:
  cond_br undef, bb2, bb3

bb2:
  %copy1 = copy_value %0 : $Klass
  %2 = upcast %copy1 : $Klass to $SuperKlass
  apply %func(%2) : $@convention(thin) (@owned SuperKlass) -> ()
  br bb1

bb3:
  destroy_value %0 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @cse_select_enum2 :
// CHECK: select_enum
// CHECK-NOT: select_enum
// CHECK: tuple
// CHECK-LABEL: } // end sil function 'cse_select_enum2'
sil [ossa] @cse_select_enum2 : $@convention(thin) (@guaranteed FakeOptional) -> (Builtin.Int1, Builtin.Int1) {
bb0(%0 : @guaranteed $FakeOptional):
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  %1 = select_enum %0 : $FakeOptional, case #FakeOptional.none!enumelt: %t, case #FakeOptional.some!enumelt: %f : $Builtin.Int1
  %copy = copy_value %0 : $FakeOptional
  %2 = select_enum %copy : $FakeOptional, case #FakeOptional.none!enumelt: %t, case #FakeOptional.some!enumelt: %f : $Builtin.Int1
  destroy_value %copy : $FakeOptional
  %3 = tuple (%1: $Builtin.Int1, %2: $Builtin.Int1)
  return %3: $(Builtin.Int1, Builtin.Int1)
}

// CHECK-LABEL: sil [ossa] @enum_cse2 :
// CHECK: enum $FakeOptional, #FakeOptional.some!enumelt
// CHECK-NOT: enum $FakeOptional, #FakeOptional.some!enumelt
// CHECK-LABEL: } // end sil function 'enum_cse2'
sil [ossa] @enum_cse2 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %func = function_ref @unknown_fake_optional_user : $@convention(thin) (FakeOptional) -> ()
  %copy = copy_value %0 : $Klass
  %4 = enum $FakeOptional, #FakeOptional.some!enumelt, %0 : $Klass
  %5 = enum $FakeOptional, #FakeOptional.some!enumelt, %copy : $Klass
  apply %func(%4) : $@convention(thin) (FakeOptional) -> ()
  apply %func(%5) : $@convention(thin) (FakeOptional) -> ()
  destroy_value %5 : $FakeOptional
  %6 = tuple()
  return %6 : $()
}

class TestKlass {
  var testStruct: NonTrivialStruct
}

sil [ossa] @use_klass : $@convention(thin) (@guaranteed Klass) -> ()

// An interior pointer, struct_element_addr, can be reused during an
// OSSA/RAUW because its new uses are within the borrowed value
// (function argument %0).
//
// CHECK-LABEL: sil [ossa] @cse_ossa_interioruseswithinarg :
// CHECK: struct_element_addr
// CHECK-NOT: struct_element_addr
// CHECK-LABEL: } // end sil function 'cse_ossa_interioruseswithinarg'
sil [ossa] @cse_ossa_interioruseswithinarg : $@convention(thin) (@guaranteed TestKlass) -> () {
bb0(%0 : @guaranteed $TestKlass):
  %1 = ref_element_addr %0 : $TestKlass, #TestKlass.testStruct
  %2 = begin_access [modify] [dynamic] %1 : $*NonTrivialStruct
  %3 = struct_element_addr %2 : $*NonTrivialStruct, #NonTrivialStruct.val
  %4 = load_borrow %3 : $*Klass
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %c = apply %f(%4) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %4 : $Klass
  %3a = struct_element_addr %2 : $*NonTrivialStruct, #NonTrivialStruct.val
  %4a = load_borrow %3a : $*Klass
  %ca = apply %f(%4a) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %4a : $Klass
  end_access %2 : $*NonTrivialStruct
  %139 = tuple ()
  return %139 : $()
}

// An interior pointer, struct_element_addr, cannot be reused without
// cloning the access scope, which we don't do. The two
// struct_element_addr's are not currently considered equivalent.
//
// CHECK-LABEL: sil [ossa] @cse_ossa_outsideaccessscope :
// CHECK: struct_element_addr
// CHECK: struct_element_addr
// CHECK-LABEL: } // end sil function 'cse_ossa_outsideaccessscope'
sil [ossa] @cse_ossa_outsideaccessscope : $@convention(thin) (@guaranteed TestKlass) -> () {
bb0(%0 : @guaranteed $TestKlass):
  %1 = ref_element_addr %0 : $TestKlass, #TestKlass.testStruct
  %a1 = begin_access [modify] [dynamic] %1 : $*NonTrivialStruct
  %e1 = struct_element_addr %a1 : $*NonTrivialStruct, #NonTrivialStruct.val
  %l1 = load_borrow %e1 : $*Klass
  end_access %a1 : $*NonTrivialStruct
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %c1 = apply %f(%l1) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %l1 : $Klass
  %a2 = begin_access [modify] [dynamic] %1 : $*NonTrivialStruct
  %e2 = struct_element_addr %a2 : $*NonTrivialStruct, #NonTrivialStruct.val
  %l2 = load_borrow %e2 : $*Klass
  end_access %a2 : $*NonTrivialStruct
  %c2 = apply %f(%l2) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %l2 : $Klass
  %139 = tuple ()
  return %139 : $()
}

struct X {
  var i: Int64
}

sil_global hidden @globalX : $X

sil [ossa] @use_address : $@convention(thin) (@in_guaranteed X) -> ()

// CHECK-LABEL: sil [ossa] @cse_ossa_validrauwfollowinvalidrauw :
// CHECK: global_addr
// CHECK-NOT: global_addr
// CHECK-LABEL: } // end sil function 'cse_ossa_validrauwfollowinvalidrauw'
sil [ossa] @cse_ossa_validrauwfollowinvalidrauw : $@convention(thin) (@guaranteed TestKlass) -> () {
bb0(%0 : @guaranteed $TestKlass):
  %1 = function_ref @use_address : $@convention(thin) (@in_guaranteed X) -> ()
  %2 = ref_element_addr %0 : $TestKlass, #TestKlass.testStruct
  %3 = begin_access [modify] [dynamic] %2 : $*NonTrivialStruct
  %4 = struct_element_addr %3 : $*NonTrivialStruct, #NonTrivialStruct.val
  %5 = load_borrow %4 : $*Klass
  %6 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %7 = apply %6(%5) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %5 : $Klass
  %9 = global_addr @globalX : $*X
  %10 = apply %1(%9) : $@convention(thin) (@in_guaranteed X) -> ()
  %11 = struct_element_addr %3 : $*NonTrivialStruct, #NonTrivialStruct.val
  %12 = load_borrow %11 : $*Klass
  %13 = apply %6(%12) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %12 : $Klass
  %15 = global_addr @globalX : $*X
  %16 = apply %1(%15) : $@convention(thin) (@in_guaranteed X) -> ()
  end_access %3 : $*NonTrivialStruct
  %18 = tuple ()
  return %18 : $()
}


struct WrapperStruct {
  var val: TestKlass
}

// CHECK-LABEL: sil [ossa] @cse_ossa_utilstest :
// CHECK: ref_element_addr
// CHECK: ref_element_addr
// CHECK-LABEL: } // end sil function 'cse_ossa_utilstest'
sil [ossa] @cse_ossa_utilstest : $@convention(thin) (@guaranteed WrapperStruct) -> () {
bb0(%0 : @guaranteed $WrapperStruct):
%f = function_ref @use_nontrivialstruct3 : $@convention(thin) (@in_guaranteed NonTrivialStruct) -> ()
%none = enum $FakeOptional3, #FakeOptional3.none
switch_enum %none : $FakeOptional3, case #FakeOptional3.some!enumelt:bb1, case #FakeOptional3.none!enumelt:bb2, forwarding: @guaranteed

bb1(%arg : @guaranteed $WrapperStruct):
%ex = struct_extract %arg : $WrapperStruct, #WrapperStruct.val
%1 = ref_element_addr %ex : $TestKlass, #TestKlass.testStruct
apply %f (%1) : $@convention(thin) (@in_guaranteed NonTrivialStruct) -> ()
%2 = ref_element_addr %ex : $TestKlass, #TestKlass.testStruct
apply %f (%2) : $@convention(thin) (@in_guaranteed NonTrivialStruct) -> ()
br bb3

bb2:
br bb3

bb3:
%res = tuple ()
return %res : $()
}

sil [ossa] @use : $@convention(thin) (@sil_unmanaged Klass) -> ()
sil [ossa] @getKlass : $@convention(thin) () -> (@owned Klass)

// Tests to make sure cse does not eliminate non-owned, non-guaranteed redundant values
// by looking through ownership instructions.
// CHECK-LABEL: sil [ossa] @test_ref_to_unmanaged :
// CHECK: ref_to_unmanaged
// CHECK: ref_to_unmanaged
// CHECK-LABEL: } // end sil function 'test_ref_to_unmanaged'
sil [ossa] @test_ref_to_unmanaged : $@convention(thin) () -> () {
bb0:
 %f1 = function_ref @getKlass : $@convention(thin) () -> (@owned Klass)
 %f2 = function_ref @use : $@convention(thin) (@sil_unmanaged Klass) -> ()
 %0 = apply %f1() : $@convention(thin) () -> (@owned Klass)
 %raw1 = ref_to_unmanaged %0 : $Klass to $@sil_unmanaged Klass
 apply %f2(%raw1) : $@convention(thin) (@sil_unmanaged Klass) -> ()
 %copy = copy_value %0 : $Klass
 destroy_value %0 : $Klass
 %raw2 = ref_to_unmanaged %copy : $Klass to $@sil_unmanaged Klass
 apply %f2(%raw2) : $@convention(thin) (@sil_unmanaged Klass) -> ()
 destroy_value %copy : $Klass
 %t = tuple ()
 return %t : $()
}

// CHECK-LABEL: sil [ossa] @test_aggreate_tail_addr :
// CHECK: ref_tail_addr
// CHECK: ref_tail_addr
// CHECK-LABEL: } // end sil function 'test_aggreate_tail_addr'
sil [ossa] @test_aggreate_tail_addr : $@convention(thin) (@owned _NativeDictionary<Int, Klass>) -> () {
bb0(%0 : @owned $_NativeDictionary<Int, Klass>):
  %49 = move_value [lexical] %0 : $_NativeDictionary<Int, Klass> 
  %50 = begin_borrow %49
  %51 = struct_extract %50, #_NativeDictionary._storage
  %52 = copy_value %51
  %53 = ref_tail_addr %51, $_UnsafeBitset.Word
  %59 = load [trivial] %53
  end_borrow %50
  %72 = begin_borrow %52
  %73 = ref_tail_addr %72, $_UnsafeBitset.Word
  %74 = struct_element_addr %73, #_UnsafeBitset.Word.value
  %75 = struct_element_addr %74, #UInt._value
  %76 = load [trivial] %75
  end_borrow %72
  destroy_value %52
  destroy_value %49
  unreachable
}

struct Pointer<Element> {
  @_hasStorage let pointer: UnsafePointer<Klass> { get }
}

struct Wrapper {
  let k: Klass
  var ptr: Pointer<Klass> 
}

sil @use_wrapper : $@convention(thin) (@in_guaranteed Wrapper) -> ()

// CHECK-LABEL: sil [ossa] @testMarkDepNonEscAddressValue : $@convention(thin) (@in Wrapper) -> () {
// CHECK: mark_dependence
// CHECK: mark_dependence
// CHECK-LABEL: } // end sil function 'testMarkDepNonEscAddressValue'
sil [ossa] @testMarkDepNonEscAddressValue : $@convention(thin) (@in Wrapper) -> () {
bb0(%0 : $*Wrapper):
  %f = function_ref @use_wrapper : $@convention(thin) (@in_guaranteed Wrapper) -> ()
  %1 = load [copy] %0
  %2 = begin_borrow %1
  %3 = struct_extract %2, #Wrapper.ptr
  %4 = struct_extract %3, #Pointer.pointer
  %5 = struct_extract %4, #UnsafePointer._rawValue
  %6 = pointer_to_address %5 to [strict] $*Wrapper
  %7 = mark_dependence [nonescaping] %6 on %2
  apply %f(%7) : $@convention(thin) (@in_guaranteed Wrapper) -> ()
  end_borrow %2
  %9 = begin_borrow %1
  %10 = struct_extract %9, #Wrapper.ptr
  %11 = struct_extract %10, #Pointer.pointer
  %12 = struct_extract %11, #UnsafePointer._rawValue
  %13 = pointer_to_address %12 to [strict] $*Wrapper
  %14 = mark_dependence [nonescaping] %13 on %9
  apply %f(%14) : $@convention(thin) (@in_guaranteed Wrapper) -> ()
  end_borrow %9
  destroy_value %1
  destroy_addr %0
  %18 = tuple ()
  return %18
}

sil @get_nontrivialstruct : $@convention(thin) () -> @owned NonTrivialStruct

// Both CopyPropagation and CopyToBorrow cannot eliminate the copy generated by
// OSSA RAUW if we look through ownership instructions while CSE'ing
// CHECK-LABEL: sil [ossa] @struct_copy_test1 :
// CHECK: struct_extract
// CHECK: struct_extract
// CHECK-LABEL: } // end sil function 'struct_copy_test1'
sil [ossa] @struct_copy_test1 : $@convention(thin) (@owned NonTrivialStruct) -> () {
bb0(%0 : @owned $NonTrivialStruct):
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %b1 = begin_borrow %0
  %ex1 = struct_extract %b1, #NonTrivialStruct.val
  apply %f(%ex1) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b1
  %b2 = begin_borrow %0
  %ex2 = struct_extract %b2, #NonTrivialStruct.val
  apply %f(%ex2) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b2
  destroy_value %0 : $NonTrivialStruct
  %res = tuple ()
  return %res : $()
}

// Both CopyPropagation and CopyToBorrow cannot eliminate the copy generated by
// OSSA RAUW if we look through ownership instructions while CSE'ing
// CHECK-LABEL: sil [ossa] @struct_copy_test2 :
// CHECK: struct_extract
// CHECK: struct_extract
// CHECK-LABEL: } // end sil function 'struct_copy_test2'
sil [ossa] @struct_copy_test2 : $@convention(thin) () -> () {
bb0:
  %f1 = function_ref @get_nontrivialstruct : $@convention(thin) () -> @owned NonTrivialStruct
  %0 = apply %f1() : $@convention(thin) () -> @owned NonTrivialStruct
  %f2 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %b1 = begin_borrow %0
  %ex1 = struct_extract %b1, #NonTrivialStruct.val
  apply %f2(%ex1) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b1
  %b2 = begin_borrow %0
  %ex2 = struct_extract %b2, #NonTrivialStruct.val
  apply %f2(%ex2) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b2
  destroy_value %0 : $NonTrivialStruct
  %res = tuple ()
  return %res : $()
}
