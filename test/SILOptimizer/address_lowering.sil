// RUN: %target-sil-opt -address-lowering -enable-sil-opaque-values -emit-sorted-sil -module-name Swift -sil-verify-all %s | %FileCheck %s
//
// The module name must be Swift so that declarations like Error are parsed as the correct loadable type.

import Builtin

sil_stage raw

typealias AnyObject = Builtin.AnyObject
typealias Int = Builtin.Int64
typealias Bool = Builtin.Int1

public protocol C : AnyObject {}

sil_default_witness_table C {}

protocol P {
  func foo()
}

enum Optional<T> {
  case none
  case some(T)
}

protocol Error {}

struct I {}

struct SI<T> {
  var element: T
  var index: I
}

struct SRef<T> {
  var object: AnyObject
  var element: T
}

struct Pair<T> {
  var x : T
  var y : T
}

enum Mixed<T> {
  case i(Int)
  case t(T)
  case o(AnyObject)
};

precedencegroup ComparisonPrecedence {
  assignment: true
  associativity: right
}
infix operator  <: ComparisonPrecedence
public protocol Comparable {
  static func < (lhs: Self, rhs: Self) -> Bool
}

sil [ossa] @takeGuaranteedObject : $@convention(thin) (@guaranteed AnyObject) -> ()
sil [ossa] @takeIndirectClass : $@convention(thin) (@in_guaranteed C) -> ()
sil [ossa] @takeTuple : $@convention(thin) <τ_0_0> (@in_guaranteed (τ_0_0, C)) -> ()


sil [ossa] @takeIn : $@convention(thin) <T> (@in T) -> ()
sil [ossa] @takeInGuaranteed : $@convention(thin) <T> (@in_guaranteed T) -> ()

sil [ossa] @throwsError : $@convention(thin) <T> (@in T) -> (@out T, @error Error)
sil [ossa] @returnInt : $@convention(thin) <T> (@in T) -> (Int, @error Error)
sil [ossa] @returnIntOut : $@convention(thin) <T> (@in T) -> (@out Int, @error Error)
sil [ossa] @returnTuple : $@convention(thin) <T> (@in T) -> (@out T, Int, @out Int, @out T, @error Error)

// CHECK-LABEL: sil [ossa] @f010_addrlower_identity : $@convention(thin) <T> (@in T) -> @out T {
// CHECK: bb0(%0 : $*T, %1 : $*T):
// CHECK: copy_addr [take] %1 to [initialization] %0 : $*T
// CHECK: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f010_addrlower_identity'
sil [ossa] @f010_addrlower_identity : $@convention(thin) <T> (@in T) -> @out T {
bb0(%0 : @owned $T):
  return %0 : $T
}

// This could happen as a result of either partial specialization from
// a single type parameter into a generic tuple, or specialization
// from a single type parameter into a tuple of concrete address-only
// types.
//
// CHECK-LABEL: sil [ossa] @f011_identity_tuple : $@convention(thin) <T> (@in (T, T)) -> @out (T, T) {
// CHECK: bb0(%0 : $*(T, T), %1 : $*(T, T)):
// CHECK:   copy_addr [take] %1 to [initialization] %0 : $*(T, T)
// CHECK-LABEL: } // end sil function 'f011_identity_tuple'
sil [ossa] @f011_identity_tuple : $@convention(thin) <T> (@in (T, T)) -> @out (T, T) {
bb0(%0 : @owned $(T, T)):
  return %0 : $(T, T)
}

// CHECK-LABEL: sil [ossa] @f012_decompose_tuple_arg : $@convention(thin) <T> (@in (T, T)) -> @out (T, T) {
// CHECK: bb0(%0 : $*(T, T), %1 : $*(T, T)):
// CHECK:   [[ARG0:%.*]] = tuple_element_addr %1 : $*(T, T), 0
// CHECK:   [[ARG1:%.*]] = tuple_element_addr %1 : $*(T, T), 1
// CHECK:   [[RET0:%.*]] = tuple_element_addr %0 : $*(T, T), 0
// CHECK:   apply %{{.*}}<T>([[RET0]], [[ARG0]]) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> @out τ_0_0
// CHECK:   [[RET1:%.*]] = tuple_element_addr %0 : $*(T, T), 1
// CHECK:   copy_addr [take] [[ARG1]] to [initialization] [[RET1]] : $*T
// CHECK-LABEL: } // end sil function 'f012_decompose_tuple_arg'
sil [ossa] @f012_decompose_tuple_arg : $@convention(thin) <T> (@in (T, T)) -> @out (T, T) {
bb0(%0 : @owned $(T, T)):
  (%arg0, %arg1) = destructure_tuple %0 : $(T, T)
  %f = function_ref @f010_addrlower_identity : $@convention(thin) <T> (@in T) -> @out T
  %call = apply %f<T>(%arg0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> @out τ_0_0
  %result = tuple (%call : $T, %arg1 : $T)
  return %result : $(T, T)
}

// CHECK-LABEL: sil [ossa] @f013_pass_tuple_arg : $@convention(thin) <T> (@in T) -> @out T {
// CHECK: bb0(%0 : $*T, %1 : $*T):
// CHECK:   [[IN:%.*]] = alloc_stack $(T, T)
// CHECK:   [[OUT:%.*]] = alloc_stack $(T, T)
// CHECK:   [[IN1:%.*]] = tuple_element_addr [[IN]] : $*(T, T), 1
// CHECK:   copy_addr %1 to [initialization] [[IN1]] : $*T
// CHECK:   [[IN0:%.*]] = tuple_element_addr %2 : $*(T, T), 0
// CHECK:   copy_addr [take] %1 to [initialization] [[IN0]] : $*T
// CHECK:   apply %{{.*}}<T>([[OUT]], [[IN]]) : $@convention(thin) <τ_0_0> (@in (τ_0_0, τ_0_0)) -> @out (τ_0_0, τ_0_0)
// CHECK:   [[RET:%.*]] = tuple_element_addr [[OUT]] : $*(T, T), 0
// CHECK:   [[DEAD:%.*]] = tuple_element_addr [[OUT]] : $*(T, T), 1
// CHECK:   destroy_addr [[DEAD]] : $*T
// CHECK:   copy_addr [take] [[RET]] to [initialization] %0 : $*T
// CHECK-LABEL: } // end sil function 'f013_pass_tuple_arg'
sil [ossa] @f013_pass_tuple_arg : $@convention(thin) <T> (@in T) -> @out T {
bb0(%0 : @owned $T):
  %copy0 = copy_value %0 : $T
  %arg = tuple (%0 : $T, %copy0 : $T)
  %f = function_ref @f011_identity_tuple : $@convention(thin) <T> (@in (T, T)) -> @out (T, T)
  %call = apply %f<T>(%arg) : $@convention(thin) <T> (@in (T, T)) -> @out (T, T)
  (%call0, %call1) = destructure_tuple %call : $(T, T)
  destroy_value %call1 : $T
  return %call0 : $T
}

// CHECK-LABEL: sil [ossa] @f020_multiResult : $@convention(thin) <T> (@in T) -> (@out T, @out T, @out T) {
// CHECK: %0 "$return_value"
// CHECK: %1 "$return_value"
// CHECK: %2 "$return_value"
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : $*T, %3 : $*T):
// CHECK:   copy_addr %3 to [initialization] %1 : $*T
// CHECK:   copy_addr %3 to [initialization] %2 : $*T
// CHECK:   copy_addr [take] %3 to [initialization] %0 : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f020_multiResult'
sil [ossa] @f020_multiResult : $@convention(thin) <T> (@in T) -> (@out T, @out T, @out T) {
bb0(%0 : @owned $T):
  %1 = copy_value %0 : $T
  %2 = copy_value %0 : $T
  %6 = tuple (%0 : $T, %1 : $T, %2 : $T)
  return %6 : $(T, T, T)
}

// Test returning an opaque tuple of tuples as a concrete tuple.
// The multiResult call is specialized, but the SIL result convention does not change.
// ---
// CHECK-LABEL: sil [ossa] @f021_callMultiResult : $@convention(thin) (Builtin.Int64) -> (Builtin.Int64, Builtin.Int64, Builtin.Int64) {
// CHECK: bb0(%0 : $Builtin.Int64):
// CHECK:  %[[FN:.*]] = function_ref @f020_multiResult : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0, @out τ_0_0)
// CHECK:  %[[IN:.*]] = alloc_stack $Builtin.Int64
// CHECK:  store %0 to [trivial] %[[IN]] : $*Builtin.Int64
// CHECK:  %[[OUT1:.*]] = alloc_stack $Builtin.Int64
// CHECK:  %[[OUT2:.*]] = alloc_stack $Builtin.Int64
// CHECK:  %[[OUT3:.*]] = alloc_stack $Builtin.Int64
// CHECK:  %{{.*}} = apply %[[FN]]<Builtin.Int64>(%[[OUT1]], %[[OUT2]], %[[OUT3]], %[[IN]]) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0, @out τ_0_0)
// CHECK:  %[[R3:.*]] = load [trivial] %[[OUT3]] : $*Builtin.Int64
// CHECK:  dealloc_stack %[[OUT3]] : $*Builtin.Int64
// CHECK:  %[[R2:.*]] = load [trivial] %[[OUT2]] : $*Builtin.Int64
// CHECK:  dealloc_stack %[[OUT2]] : $*Builtin.Int64
// CHECK:  %[[R1:.*]] = load [trivial] %[[OUT1]] : $*Builtin.Int64
// CHECK:  dealloc_stack %[[OUT1]] : $*Builtin.Int64
// CHECK:  dealloc_stack %[[IN]] : $*Builtin.Int64
// CHECK:  %[[R:.*]] = tuple (%[[R1]] : $Builtin.Int64, %[[R2]] : $Builtin.Int64, %[[R3]] : $Builtin.Int64)
// CHECK:  return %[[R]] : $(Builtin.Int64, Builtin.Int64, Builtin.Int64)
// CHECK-LABEL: } // end sil function 'f021_callMultiResult'
sil [ossa] @f021_callMultiResult : $@convention(thin) (Int) -> (Int, Int, Int) {
bb0(%0 : $Int):
  %1 = function_ref @f020_multiResult : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0, @out τ_0_0)
  %2 = apply %1<Int>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0, @out τ_0_0)
  (%3, %4, %5) = destructure_tuple %2 : $(Int, Int, Int)
  %6 = tuple (%3 : $Int, %4 : $Int, %5 : $Int)
  return %6 : $(Int, Int, Int)
}

// CHECK-LABEL: sil [ossa] @f030_returnPair : $@convention(thin) <T> (@in T) -> (@out T, @out T) {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : $*T):
// CHECK:   copy_addr %2 to [initialization] %1 : $*T
// CHECK:   copy_addr [take] %2 to [initialization] %0 : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f030_returnPair'
sil [ossa] @f030_returnPair : $@convention(thin) <T> (@in T) -> (@out T, @out T) {
bb0(%0 : @owned $T):
  %1 = copy_value %0 : $T
  %3 = tuple (%0 : $T, %1 : $T)
  return %3 : $(T, T)
}

// CHECK-LABEL: sil [ossa] @f031_unusedIndirect : $@convention(thin) <T> (@in T) -> @out T {
// CHECK: bb0(%0 : $*T, %1 : $*T):
// CHECK:   %[[LOC0:.*]] = alloc_stack $T
// CHECK:   %[[F:.*]] = function_ref @f030_returnPair : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK:   %[[R0:.*]] = apply %[[F]]<T>(%[[LOC0]], %0, %1) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK:   destroy_addr %[[LOC0]] : $*T
// CHECK:   dealloc_stack %[[LOC0]] : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f031_unusedIndirect'
sil [ossa] @f031_unusedIndirect : $@convention(thin) <T> (@in T) -> @out T {
bb0(%0 : @owned $T):
  %2 = function_ref @f030_returnPair : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  %4 = apply %2<T>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  (%5, %6) = destructure_tuple %4 : $(T, T)
  destroy_value %5 : $T
  return %6 : $T
}

// CHECK-LABEL: sil [ossa] @f040_consumeArg : $@convention(thin) <T> (@in T) -> () {
// CHECK: destroy_addr %0 : $*T 
// CHECK-LABEL: } // end sil function 'f040_consumeArg'
sil [ossa] @f040_consumeArg : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  destroy_value %0 : $T
  %3 = tuple ()
  return %3 : $()
}

// CHECK-LABEL: sil [ossa] @f041_opaqueArg : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK:  %[[LOC:.*]] = alloc_stack $T
// CHECK:  %[[FN:.*]] = function_ref @f040_consumeArg : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
// CHECK:  copy_addr %0 to [initialization] %[[LOC]] : $*T
// CHECK:  %{{.*}} = apply %[[FN]]<T>(%[[LOC]]) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
// CHECK:  destroy_addr %0 : $*T
// CHECK:  %[[R:.*]] = tuple ()
// CHECK:  dealloc_stack %[[LOC]] : $*T
// CHECK:  return %[[R]] : $()
// CHECK-LABEL: } // end sil function 'f041_opaqueArg'
sil [ossa] @f041_opaqueArg : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  %2 = function_ref @f040_consumeArg : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
  %3 = copy_value %0 : $T
  %4 = apply %2<T>(%3) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
  destroy_value %0 : $T
  %6 = tuple ()
  return %6 : $()
}

// FIXME: Optimize transfers from indirect function args to indirect call args.
// Verify that a subsequent pass remove the temp allocation.
//
// CHECK-LABEL: sil [ossa] @f043_indirectGuaranteedArg : $@convention(thin) (@in C) -> () {
// CHECK: bb0(%0 : $*C):
// CHECK:   [[LD:%.*]] = load [take] %0 : $*C
// CHECK:   [[TMP:%.*]] = alloc_stack $C
// CHECK:   [[B:%.*]] = begin_borrow [[LD]] : $C
// CHECK:   [[SB:%.*]] = store_borrow [[B]] to [[TMP]] : $*C
// CHECK:   apply %{{.*}}([[TMP]]) : $@convention(thin) (@in_guaranteed C) -> ()
// CHECK:   end_borrow [[B]] : $C
// CHECK:   dealloc_stack [[TMP]] : $*C
// CHECK:   destroy_value [[LD]] : $C
// CHECK-LABEL: } // end sil function 'f043_indirectGuaranteedArg'
sil [ossa] @f043_indirectGuaranteedArg : $@convention(thin) (@in C) -> () {
bb0(%0 : @owned $C):
  %1 = function_ref @takeIndirectClass : $@convention(thin) (@in_guaranteed C) -> ()
  %2 = apply %1(%0) : $@convention(thin) (@in_guaranteed C) -> ()
  destroy_value %0 : $C
  %6 = tuple ()
  return %6 : $()
}

sil [ossa] @f044_indirectGuaranteed : $@convention(thin) <T>(@in_guaranteed T) -> ()

// CHECK-LABEL: sil [ossa] @f045_indirectGuaranteedCallArg : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK:   apply %{{.*}}<T>(%0) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> ()
// CHECK:   destroy_addr %0 : $*T
// CHECK-LABEL: } // end sil function 'f045_indirectGuaranteedCallArg'
sil [ossa] @f045_indirectGuaranteedCallArg : $@convention(thin) <T>(@in T) -> () {
bb0(%0 : @owned $T):
  %1 = function_ref @f044_indirectGuaranteed : $@convention(thin) <τ_0_0>(@in_guaranteed τ_0_0) -> ()
  %2 = apply %1<T>(%0) : $@convention(thin) <τ_0_0>(@in_guaranteed τ_0_0) -> ()
  destroy_value %0 : $T
  %6 = tuple ()
  return %6 : $()
}

// CHECK-LABEL: sil [ossa] @f046_indirectGuaranteedFunctionArg : $@convention(thin) <T> (@in_guaranteed T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK-NOT: load
// CHECK: apply %{{.*}}<T>(%0) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> ()
// CHECK-NOT: end_borrow
// CHECK-LABEL: } // end sil function 'f046_indirectGuaranteedFunctionArg'
sil [ossa] @f046_indirectGuaranteedFunctionArg : $@convention(thin) <T>(@in_guaranteed T) -> () {
bb0(%0 : @guaranteed $T):
  %1 = function_ref @f044_indirectGuaranteed : $@convention(thin) <τ_0_0>(@in_guaranteed τ_0_0) -> ()
  %2 = apply %1<T>(%0) : $@convention(thin) <τ_0_0>(@in_guaranteed τ_0_0) -> ()
  %6 = tuple ()
  return %6 : $()
}

// CHECK-LABEL: sil [ossa] @f050_storeinout : $@convention(thin) <T> (@inout T, @inout T, @in T) -> () {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : $*T):
// CHECK:   %[[PREV1:.*]] = alloc_stack $T
// CHECK:   %[[PREV2:.*]] = alloc_stack $T
// CHECK:   debug_value %0 : $*T, var, name "t", argno 1
// CHECK:   debug_value %1 : $*T, var, name "u", argno 2
// CHECK:   debug_value %2 : $*T
// CHECK:   copy_addr [take] %0 to [initialization] %[[PREV1]] : $*T
// CHECK:   copy_addr %2 to [initialization] %0 : $*T
// CHECK:   destroy_addr %[[PREV1]] : $*T
// CHECK:   copy_addr %1 to [initialization] %[[PREV2]] : $*T
// CHECK:   copy_addr %2 to %1 : $*T
// CHECK:   destroy_addr %[[PREV2]] : $*T
// CHECK:   destroy_addr %2 : $*T
// CHECK:   dealloc_stack %[[PREV2]] : $*T
// CHECK:   dealloc_stack %[[PREV1]] : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f050_storeinout'
sil [ossa] @f050_storeinout : $@convention(thin) <T> (@inout T, @inout T, @in T) -> () {
bb0(%0 : $*T, %1 : $*T, %2 : @owned $T):
  debug_value %0 : $*T, var, name "t", argno 1, expr op_deref
  debug_value %1 : $*T, var, name "u", argno 2, expr op_deref
  debug_value %2 : $T, let, name "x", argno 3
  %7 = load [take] %0 : $*T
  %6 = copy_value %2 : $T
  store %6 to [init] %0 : $*T
  destroy_value %7 : $T
  %11 = load [copy] %1 : $*T
  %10 = copy_value %2 : $T
  store %10 to [assign] %1 : $*T
  destroy_value %11 : $T
  destroy_value %2 : $T
  %15 = tuple ()
  return %15 : $()
}

// CHECK-LABEL: sil [ossa] @f060_mutate : $@convention(thin) <T> (@inout T, @in T) -> () {
// CHECK: bb0(%0 : $*T, %1 : $*T):
// CHECK:   [[A0:%.*]] = alloc_stack $T
// CHECK:   copy_addr [take] %0 to [initialization] [[A0]] : $*T
// CHECK:   copy_addr %1 to [initialization] %0 : $*T
// CHECK:   destroy_addr [[A0]] : $*T
// CHECK:   destroy_addr %1 : $*T
// CHECK:   dealloc_stack [[A0]] : $*T
// CHECK-LABEL: } // end sil function 'f060_mutate'
sil [ossa] @f060_mutate : $@convention(thin) <T> (@inout T, @in T) -> () {
bb0(%0 : $*T, %1 : @owned $T):
  %4 = copy_value %1 : $T
  %5 = load [take] %0 : $*T
  store %4 to [init] %0 : $*T
  destroy_value %5 : $T
  destroy_value %1 : $T
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil [ossa] @f061_callinout : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK:   %[[LOC1:.*]] = alloc_stack $T
// CHECK:   %[[INOUT:.*]] = alloc_stack $T, var, name "u"
// CHECK:   copy_addr %0 to [initialization] %[[INOUT]] : $*T
// CHECK:   %[[FN:.*]] = function_ref @f060_mutate : $@convention(thin) <τ_0_0> (@inout τ_0_0, @in τ_0_0) -> ()
// CHECK:   copy_addr %0 to [initialization] %[[LOC1]] : $*T
// CHECK:   %{{.*}} = apply %[[FN]]<T>(%[[INOUT]], %[[LOC1]]) : $@convention(thin) <τ_0_0> (@inout τ_0_0, @in τ_0_0) -> ()
// CHECK:   destroy_addr %[[INOUT]] : $*T
// CHECK:   destroy_addr %0 : $*T
// CHECK:   dealloc_stack %[[INOUT]] : $*T
// CHECK:   dealloc_stack %[[LOC1]] : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f061_callinout'
sil [ossa] @f061_callinout : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  %1 = alloc_stack $T, var, name "u"
  %3 = copy_value %0 : $T
  store %3 to [init] %1 : $*T
  %5 = function_ref @f060_mutate : $@convention(thin) <τ_0_0> (@inout τ_0_0, @in τ_0_0) -> ()
  %6 = copy_value %0 : $T
  %7 = apply %5<T>(%1, %6) : $@convention(thin) <τ_0_0> (@inout τ_0_0, @in τ_0_0) -> ()
  destroy_addr %1 : $*T
  destroy_value %0 : $T
  %10 = tuple ()
  dealloc_stack %1 : $*T
  return %10 : $()
}

// CHECK-LABEL: sil [ossa] @f070_mixedResult1 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @owned C) {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : @owned $C):
// CHECK:   copy_addr [take] %1 to [initialization] %0 : $*T
// CHECK:   return %2 : $C
// CHECK-LABEL: } // end sil function 'f070_mixedResult1'
sil [ossa] @f070_mixedResult1 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @owned C) {
bb0(%0 : @owned $T, %1 : @owned $C):
  %4 = tuple (%0 : $T, %1 : $C)
  return %4 : $(T, C)
}

// CHECK-LABEL: sil [ossa] @f071_mixedResult2 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @out T, @owned C, @owned C) {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : $*T, %3 : @owned $C):
// CHECK:   copy_addr %2 to [initialization] %0 : $*T
// CHECK:   [[C:%.*]] = copy_value %3 : $C
// CHECK:   copy_addr [take] %2 to [initialization] %1 : $*T
// CHECK:   [[T:%.*]] = tuple ([[C]] : $C, %3 : $C)
// CHECK:   return [[T]] : $(C, C)
// CHECK-LABEL: } // end sil function 'f071_mixedResult2'
sil [ossa] @f071_mixedResult2 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @out T, @owned C, @owned C) {
bb0(%0 : @owned $T, %1 : @owned $C):
  %4 = copy_value %0 : $T
  %5 = copy_value %1 : $C
  %6 = tuple (%4 : $T, %0 : $T, %5 : $C, %1 : $C)
  return %6 : $(T, T, C, C)
}

// CHECK-LABEL: sil [ossa] @f072_callMixedResult1 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @owned C) {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : @owned $C):
// CHECK:   [[IN:%.*]] = alloc_stack $T
// CHECK:   // function_ref f070_mixedResult1
// CHECK:   [[F:%.*]] = function_ref @f070_mixedResult1 : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @owned C)
// CHECK:   copy_addr %1 to [initialization] [[IN]] : $*T
// CHECK:   [[C:%.*]] = copy_value %2 : $C
// CHECK:   [[R:%.*]] = apply [[F]]<T>(%0, [[IN]], [[C]]) : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @owned C)
// CHECK:   destroy_value %2 : $C
// CHECK:   destroy_addr %1 : $*T
// CHECK:   dealloc_stack [[IN]] : $*T
// CHECK:   return [[R]] : $C
// CHECK-LABEL: } // end sil function 'f072_callMixedResult1'
sil [ossa] @f072_callMixedResult1 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @owned C) {
bb0(%0 : @owned $T, %1 : @owned $C):
  %4 = function_ref @f070_mixedResult1 : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @owned C)
  %5 = copy_value %0 : $T
  %6 = copy_value %1 : $C
  %7 = apply %4<T>(%5, %6) : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @owned C)
  (%8, %9) = destructure_tuple %7 : $(T, C)
  destroy_value %1 : $C
  destroy_value %0 : $T
  %15 = tuple (%8 : $T, %9 : $C)
  return %15 : $(T, C)
}

// CHECK-LABEL: sil [ossa] @f073_callMixedResult2 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @out T, @owned C, @owned C) {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : $*T, %3 : @owned $C):
// CHECK:   [[IN:%.*]] = alloc_stack $T
// CHECK:   [[F:%.*]] = function_ref @f071_mixedResult2 : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @out τ_0_0, @owned C, @owned C)
// CHECK:   copy_addr %2 to [initialization] [[IN]] : $*T
// CHECK:   [[C:%.*]] = copy_value %3 : $C
// CHECK:   [[T:%.*]] = apply [[F]]<T>(%0, %1, [[IN]], [[C]]) : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @out τ_0_0, @owned C, @owned C)
// CHECK:   ([[OUT0:%.*]], [[OUT1:%.*]]) = destructure_tuple [[T]] : $(C, C)
// CHECK:   destroy_value %3 : $C
// CHECK:   destroy_addr %2 : $*T
// CHECK:   [[R:%.*]] = tuple ([[OUT0]] : $C, [[OUT1]] : $C)
// CHECK:   dealloc_stack [[IN]] : $*T
// CHECK:   return [[R]] : $(C, C)
// CHECK-LABEL: } // end sil function 'f073_callMixedResult2'
sil [ossa] @f073_callMixedResult2 : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @out T, @owned C, @owned C) {
bb0(%0 : @owned $T, %1 : @owned $C):
  %4 = function_ref @f071_mixedResult2 : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @out τ_0_0, @owned C, @owned C)
  %5 = copy_value %0 : $T
  %6 = copy_value %1 : $C
  %7 = apply %4<T>(%5, %6) : $@convention(thin) <τ_0_0> (@in τ_0_0, @owned C) -> (@out τ_0_0, @out τ_0_0, @owned C, @owned C)
  (%8, %9, %10, %11) = destructure_tuple %7 : $(T, T, C, C)
  destroy_value %1 : $C
  destroy_value %0 : $T
  %19 = tuple (%8 : $T, %9 : $T, %10 : $C, %11 : $C)
  return %19 : $(T, T, C, C)
}

sil [ossa] @returnMixedResult3 : $@convention(thin) <T> () -> (@out T, @out C, @owned C)

// Example directly from the comments in
// ApplyRewriter::convertApplyWithIndirectResults()
//
// FIXME: verify that a subsequent pass remove the temp allocation.
//
// CHECK-LABEL: sil [ossa] @f074_callMixedResult3 : $@convention(thin) <T> () -> (@out T, @out C, @owned C) {
// CHECK: bb0(%0 : $*T, %1 : $*C):
// CHECK:   [[OUT1:%.*]] = alloc_stack $C
// CHECK:   [[OUT2:%.*]] = apply %{{.*}}<T>(%0, [[OUT1]]) : $@convention(thin) <τ_0_0> () -> (@out τ_0_0, @out C, @owned C)
// CHECK:   [[LD:%.*]] = load [take] [[OUT1]] : $*C
// CHECK:   dealloc_stack [[OUT1]] : $*C
// CHECK:   store [[LD]] to [init] %1 : $*C
// CHECK:   return [[OUT2]] : $C
// CHECK-LABEL: } // end sil function 'f074_callMixedResult3'
sil [ossa] @f074_callMixedResult3 : $@convention(thin) <T> () -> (@out T, @out C, @owned C) {
bb0:
  %0 = function_ref @returnMixedResult3 : $@convention(thin) <T> () -> (@out T, @out C, @owned C)
  %1 = apply %0<T>() : $@convention(thin) <T> () -> (@out T, @out C, @owned C)
  (%2, %3, %4) = destructure_tuple %1 : $(T, C, C)
  %5 = tuple (%2 : $T, %3 : $C, %4 : $C)
  return %5 : $(T, C, C)
}

// CHECK-LABEL: sil [ossa] @f075_reusedResult : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @owned C) {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : @owned $C):
// CHECK:   [[TUPLE:%.*]] = alloc_stack $(T, C)
// CHECK:   [[E1:%.*]] = tuple_element_addr [[TUPLE]] : $*(T, C), 0
// CHECK:   copy_addr [take] %1 to [initialization] [[E1]] : $*T
// CHECK:   [[E2:%.*]] = tuple_element_addr [[TUPLE]] : $*(T, C), 1
// CHECK:   store %2 to [init] [[E2]] : $*C
// CHECK:   apply %{{.*}}<T>([[TUPLE]]) : $@convention(thin) <τ_0_0> (@in_guaranteed (τ_0_0, C)) -> ()
// CHECK:   [[E1:%.*]] = tuple_element_addr [[TUPLE]] : $*(T, C), 0
// CHECK:   [[E2:%.*]] = tuple_element_addr [[TUPLE]] : $*(T, C), 1
// CHECK:   [[LD:%.*]] = load [take] [[E2]] : $*C
// CHECK:   copy_addr [take] [[E1]] to [initialization] %0 : $*T
// CHECK:   dealloc_stack [[TUPLE]] : $*(T, C)
// CHECK:   return [[LD]] : $C
// CHECK-LABEL: } // end sil function 'f075_reusedResult'
sil [ossa] @f075_reusedResult : $@convention(thin) <T> (@in T, @owned C) -> (@out T, @owned C) {
bb0(%0 : @owned $T, %1 : @owned $C):
  %2 = tuple (%0 : $T, %1 : $C)
  %f = function_ref @takeTuple : $@convention(thin) <τ_0_0> (@in_guaranteed (τ_0_0, C)) -> ()
  %c = apply %f<T>(%2) : $@convention(thin) <τ_0_0> (@in_guaranteed (τ_0_0, C)) -> ()
  return %2 : $(T, C)
}

// CHECK-LABEL: sil [ossa] @f080_optional : $@convention(thin) <T> (@in T) -> @out Optional<T> {
// CHECK: bb0(%0 : $*Optional<T>, %1 : $*T):
// CHECK:   [[DATA:%.*]] = init_enum_data_addr %0 : $*Optional<T>, #Optional.some!enumelt
// CHECK:   copy_addr %1 to [initialization] [[DATA]] : $*T
// CHECK:   inject_enum_addr %0 : $*Optional<T>, #Optional.some!enumelt
// CHECK:   destroy_addr %1 : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f080_optional'
sil [ossa] @f080_optional : $@convention(thin) <T> (@in T) -> @out Optional<T> {
bb0(%0 : @owned $T):
  %cpy = copy_value %0 : $T
  %opt = enum $Optional<T>, #Optional.some!enumelt, %cpy : $T
  destroy_value %0 : $T
  return %opt : $Optional<T>
}

// CHECK-LABEL: sil [ossa] @f081_unwrap : $@convention(thin) <T> (@in Optional<T>) -> () {
// CHECK: bb0(%0 : $*Optional<T>):
// CHECK:   [[A:%.*]] = unchecked_take_enum_data_addr %0 : $*Optional<T>, #Optional.some!enumelt
// CHECK:   apply %{{.*}}<T>([[A]]) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
// CHECK-LABEL: } // end sil function 'f081_unwrap'
sil [ossa] @f081_unwrap : $@convention(thin) <T> (@in Optional<T>) -> () {
bb0(%0 : @owned $Optional<T>):
  %d = unchecked_enum_data %0 : $Optional<T>, #Optional.some!enumelt
  %f = function_ref @takeIn : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
  %call = apply %f<T>(%d) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
  %4 = tuple ()
  return %4 : $()
}

// CHECK-LABEL: sil [ossa] @f090_tupletuple : $@convention(thin) ((Builtin.Int64, Builtin.Int64), Builtin.Int64) -> (@out (Builtin.Int64, Builtin.Int64), @out (Builtin.Int64, Builtin.Int64), Builtin.Int64, Builtin.Int64) {
// CHECK: bb0(%0 : $*(Builtin.Int64, Builtin.Int64), %1 : $*(Builtin.Int64, Builtin.Int64), %2 : $(Builtin.Int64, Builtin.Int64), %3 : $Builtin.Int64):
// CHECK:   store %2 to [trivial] %0 : $*(Builtin.Int64, Builtin.Int64)
// CHECK:   store %2 to [trivial] %1 : $*(Builtin.Int64, Builtin.Int64)
// CHECK:   %[[T:.*]] = tuple (%3 : $Builtin.Int64, %3 : $Builtin.Int64)
// CHECK:   return %[[T]] : $(Builtin.Int64, Builtin.Int64)
// CHECK-LABEL: } // end sil function 'f090_tupletuple'
sil [ossa] @f090_tupletuple : $@convention(thin) ((Int, Int), Int) -> (@out (Int, Int), @out (Int, Int), Int, Int) {
bb0(%0 : $(Int, Int), %1 : $Int):
  %2 = tuple (%0 : $(Int, Int), %0 : $(Int, Int), %1 : $Int, %1 : $Int)
  return %2 : $((Int, Int), (Int, Int), Int, Int)
}

// CHECK-LABEL: sil [ossa] @f091_callTuple : $@convention(thin) (Builtin.Int64) -> (Builtin.Int64, Builtin.Int64, Builtin.Int64, Builtin.Int64, Builtin.Int64, Builtin.Int64) {
// CHECK: bb0(%0 : $Builtin.Int64):
// CHECK:   [[T1:%.*]] = tuple (%0 : $Builtin.Int64, %0 : $Builtin.Int64)
// CHECK:   [[F:%.*]] = function_ref @f090_tupletuple : $@convention(thin) ((Builtin.Int64, Builtin.Int64), Builtin.Int64) -> (@out (Builtin.Int64, Builtin.Int64), @out (Builtin.Int64, Builtin.Int64), Builtin.Int64, Builtin.Int64)
// CHECK:   [[O1:%.*]] = alloc_stack $(Builtin.Int64, Builtin.Int64)
// CHECK:   [[O2:%.*]] = alloc_stack $(Builtin.Int64, Builtin.Int64)
// CHECK:   [[R:%.*]] = apply [[F]]([[O1]], [[O2]], %1, %0) : $@convention(thin) ((Builtin.Int64, Builtin.Int64), Builtin.Int64) -> (@out (Builtin.Int64, Builtin.Int64), @out (Builtin.Int64, Builtin.Int64), Builtin.Int64, Builtin.Int64)
// CHECK:   [[L2:%.*]] = load [trivial] [[O2]] : $*(Builtin.Int64, Builtin.Int64)
// CHECK:   dealloc_stack [[O2]] : $*(Builtin.Int64, Builtin.Int64)
// CHECK:   [[L1:%.*]] = load [trivial] [[O1]] : $*(Builtin.Int64, Builtin.Int64)
// CHECK:   dealloc_stack [[O1]] : $*(Builtin.Int64, Builtin.Int64)
// CHECK:   ([[R4:%.*]], [[R5:%.*]]) = destructure_tuple [[R]] : $(Builtin.Int64, Builtin.Int64)
// CHECK:   ([[R0:%.*]], [[R1:%.*]]) = destructure_tuple [[L1]] : $(Builtin.Int64, Builtin.Int64)
// CHECK:   ([[R2:%.*]], [[R3:%.*]]) = destructure_tuple [[L2]] : $(Builtin.Int64, Builtin.Int64)
// CHECK:   [[RET:%.*]] = tuple ([[R0]] : $Builtin.Int64, [[R1]] : $Builtin.Int64, [[R2]] : $Builtin.Int64, [[R3]] : $Builtin.Int64, [[R4]] : $Builtin.Int64, [[R5]] : $Builtin.Int64)
// CHECK:   return [[RET]] : $(Builtin.Int64, Builtin.Int64, Builtin.Int64, Builtin.Int64, Builtin.Int64, Builtin.Int64)
// CHECK-LABEL: } // end sil function 'f091_callTuple'
sil [ossa] @f091_callTuple : $@convention(thin) (Int) -> (Int, Int, Int, Int, Int, Int) {
bb0(%0: $Int):
  %1 = tuple (%0 : $Int, %0 : $Int)
  %2 = function_ref @f090_tupletuple : $@convention(thin) ((Int, Int), Int) -> (@out (Int, Int), @out (Int, Int), Int, Int)
  %3 = apply %2(%1, %0) : $@convention(thin) ((Int, Int), Int) -> (@out (Int, Int), @out (Int, Int), Int, Int)
  (%4, %5, %6, %7) = destructure_tuple %3 : $((Int, Int), (Int, Int), Int, Int)
  (%8, %9) = destructure_tuple %4 : $(Int, Int)
  (%10, %11) = destructure_tuple %5 : $(Int, Int)
  %12 = tuple (%8 : $Int, %9 : $Int, %10 : $Int, %11 : $Int, %6 : $Int, %7 : $Int)
  return %12 : $(Int, Int, Int, Int, Int, Int)
}

// CHECK-LABEL: sil [ossa] @f100_any : $@convention(thin) (@in Any) -> () {
// CHECK: bb0(%0 : $*Any):
// CHECK:   destroy_addr %0 : $*Any
// CHECK:   %[[T:.*]] = tuple ()
// CHECK:   return %[[T]] : $()
// CHECK-LABEL: } // end sil function 'f100_any'
sil [ossa] @f100_any : $@convention(thin) (@in Any) -> () {
bb0(%0 : @owned $Any):
  debug_value %0 : $Any, let, name "any", argno 1
  destroy_value %0 : $Any
  %3 = tuple ()
  return %3 : $()
}

// CHECK-LABEL: sil [ossa] @f101_passAny : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK:   %[[A:.*]] = alloc_stack $Any
// CHECK:   %[[F:.*]] = function_ref @f100_any : $@convention(thin) (@in Any) -> ()
// CHECK:   %[[T2:.*]] = init_existential_addr %[[A]] : $*Any, $T
// CHECK:   copy_addr %0 to [initialization] %[[T2]] : $*T
// CHECK:   %{{.*}} = apply %[[F]](%[[A]]) : $@convention(thin) (@in Any) -> ()
// CHECK:   destroy_addr %0 : $*T
// CHECK:   dealloc_stack %[[A]] : $*Any
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f101_passAny'
sil [ossa] @f101_passAny : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  %2 = function_ref @f100_any : $@convention(thin) (@in Any) -> ()
  %3 = copy_value %0 : $T
  %4 = init_existential_value %3 : $T, $T, $Any
  %5 = apply %2(%4) : $@convention(thin) (@in Any) -> ()
  destroy_value %0 : $T
  %7 = tuple ()
  return %7 : $()
}

// Test convertIndirectFunctionArgs and init_existential_value on concrete
// types.
// CHECK-LABEL: sil [ossa] @f102_passAnyObjectAsAny : $@convention(thin) (@in AnyObject) -> () {
// CHECK: bb0(%0 : $*AnyObject):
// CHECK:   [[A:%.*]] = alloc_stack $Any
// CHECK:   [[ARG:%.*]] = load [take] %0 : $*AnyObject
// CHECK:   [[F:%.*]] = function_ref @f100_any : $@convention(thin) (@in Any) -> ()
// CHECK:   [[VAL:%.*]] = init_existential_addr [[A]] : $*Any, $AnyObject
// CHECK:   store [[ARG]] to [init] [[VAL]] : $*AnyObject
// CHECK:   %{{.*}} = apply [[F]]([[A]]) : $@convention(thin) (@in Any) -> ()
// CHECK:   [[R:%.*]] = tuple ()
// CHECK:   dealloc_stack [[A]] : $*Any
// CHECK:   return [[R]] : $()
// CHECK-LABEL: } // end sil function 'f102_passAnyObjectAsAny'
sil [ossa] @f102_passAnyObjectAsAny : $@convention(thin) (@in AnyObject) -> () {
bb0(%0 : @owned $AnyObject):
  %2 = function_ref @f100_any : $@convention(thin) (@in Any) -> ()
  %4 = init_existential_value %0 : $AnyObject, $AnyObject, $Any
  %5 = apply %2(%4) : $@convention(thin) (@in Any) -> ()
  %7 = tuple ()
  return %7 : $()
}

// Helper
sil [ossa] @f110_singleIndirectFunc : $@convention(thin) <τ_0_0> () -> @out τ_0_0

// Test convertApplyWithIndirectResults.
// CHECK-LABEL: sil [ossa] @f111_singleIndirectApply : $@convention(thin) <τ_0_0> () -> @out τ_0_0 {
// CHECK: bb0(%0 : $*τ_0_0):
// CHECK: [[F:%.*]] = function_ref @f110_singleIndirectFunc : $@convention(thin) <τ_0_0> () -> @out τ_0_0
// CHECK: %{{.*}} = apply [[F]]<τ_0_0>(%0) : $@convention(thin) <τ_0_0> () -> @out τ_0_0
// CHECK: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f111_singleIndirectApply'
sil [ossa] @f111_singleIndirectApply : $@convention(thin) <τ_0_0> () -> @out τ_0_0 {
bb0:
  %2 = function_ref @f110_singleIndirectFunc : $@convention(thin) <τ_0_0> () -> @out τ_0_0
  %3 = apply %2<τ_0_0>() : $@convention(thin) <τ_0_0> () -> @out τ_0_0
  return %3 : $τ_0_0
}

// CHECK-LABEL: sil [ossa] @f120_testDestructure : $@convention(method) <Element> (@in SI<Element>) -> (@out Element, @out I) {
// CHECK: bb0(%0 : $*Element, %1 : $*I, %2 : $*SI<Element>):
// CHECK:   [[ELT_ADR:%.*]] = struct_element_addr %2 : $*SI<Element>, #SI.element
// CHECK:   [[IDX_ADR:%.*]] = struct_element_addr %2 : $*SI<Element>, #SI.index
// CHECK:   [[IDX:%.*]] = load [trivial] [[IDX_ADR]] : $*I
// CHECK:   copy_addr [take] [[ELT_ADR]] to [initialization] %0 : $*Element // id: %6
// CHECK:   store [[IDX]] to [trivial] %1 : $*I
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f120_testDestructure'
sil [ossa] @f120_testDestructure : $@convention(method) <Element> (@in SI<Element>) -> (@out Element, @out I) {
bb0(%0 : @owned $SI<Element>):
  (%element, %index) = destructure_struct %0 : $SI<Element>
  %tuple = tuple(%element : $Element, %index : $I)
  return %tuple : $(Element, I)
}

// CHECK-LABEL: sil [ossa] @f121_testStructExtract : $@convention(method) (@in SI<AnyObject>) -> (@out AnyObject, @out I) {
// CHECK: bb0(%0 : $*AnyObject, %1 : $*I, %2 : $*SI<AnyObject>):
// CHECK:   [[IN:%.*]] = load [take] %2 : $*SI<AnyObject>
// CHECK:   [[B:%.*]] = begin_borrow [[IN]] : $SI<AnyObject>
// CHECK:   [[E0:%.*]] = struct_extract [[B]] : $SI<AnyObject>, #SI.element
// CHECK:   [[C:%.*]] = copy_value [[E0]] : $AnyObject
// CHECK:   [[E1:%.*]] = struct_extract [[B]] : $SI<AnyObject>, #SI.index
// CHECK:   end_borrow [[B]] : $SI<AnyObject>
// CHECK:   destroy_value [[IN]] : $SI<AnyObject>
// CHECK:   store [[C]] to [init] %0 : $*AnyObject
// CHECK:   store [[E1]] to [trivial] %1 : $*I
// CHECK-LABEL: } // end sil function 'f121_testStructExtract'
sil [ossa] @f121_testStructExtract : $@convention(method) (@in SI<AnyObject>) -> (@out AnyObject, @out I) {
bb0(%0 : @owned $SI<AnyObject>):
  %borrow = begin_borrow %0 : $SI<AnyObject> 
  %object = struct_extract %borrow : $SI<AnyObject>, #SI.element
  %copy = copy_value %object : $AnyObject
  %index = struct_extract %borrow : $SI<AnyObject>, #SI.index
  end_borrow %borrow : $SI<AnyObject>
  destroy_value %0 : $SI<AnyObject>
  %tuple = tuple(%copy : $AnyObject, %index : $I)
  return %tuple : $(AnyObject, I)
}

// CHECK-LABEL: sil [ossa] @f122_testStructExtract : $@convention(method) <T> (@in SRef<T>) -> (@out AnyObject, @out T) {
// CHECK: bb0(%0 : $*AnyObject, %1 : $*T, %2 : $*SRef<T>):
// CHECK-NOT: alloc_stack
// CHECK:   [[E0:%.*]] = struct_element_addr %2 : $*SRef<T>, #SRef.object
// CHECK:   [[C:%.*]] = load [copy] [[E0]] : $*AnyObject
// CHECK:   [[E1:%.*]] = struct_element_addr %2 : $*SRef<T>, #SRef.element
// CHECK:   copy_addr [[E1]] to [initialization] %1 : $*T
// CHECK:   destroy_addr %2 : $*SRef<T>
// CHECK:   store [[C]] to [init] %0 : $*AnyObject
// CHECK-NOT: dealloc_stack
// CHECK-LABEL: } // end sil function 'f122_testStructExtract'
sil [ossa] @f122_testStructExtract : $@convention(method) <T>(@in SRef<T>) -> (@out AnyObject, @out T) {
bb0(%0 : @owned $SRef<T>):
  %borrow = begin_borrow %0 : $SRef<T> 
  %object = struct_extract %borrow : $SRef<T>, #SRef.object
  %copy1 = copy_value %object : $AnyObject
  %element = struct_extract %borrow : $SRef<T>, #SRef.element
  %copy2 = copy_value %element : $T
  end_borrow %borrow : $SRef<T>
  destroy_value %0 : $SRef<T>
  %tuple = tuple(%copy1 : $AnyObject, %copy2 : $T)
  return %tuple : $(AnyObject, T)
}

// CHECK-LABEL: sil [ossa] @f123_testStructExtract : $@convention(method) <T> (@in SRef<T>) -> (@out AnyObject, @out T) {
// CHECK: bb0(%0 : $*AnyObject, %1 : $*T, %2 : $*SRef<T>):
// CHECK-NOT: alloc_stack
// CHECK:   [[E0:%.*]] = struct_element_addr %2 : $*SRef<T>, #SRef.object
// CHECK:   [[L:%.*]] = load_borrow [[E0]] : $*AnyObject
// CHECK:   apply %{{.*}}([[L]]) : $@convention(thin) (@guaranteed AnyObject) -> ()
// CHECK:   [[C:%.*]] = copy_value [[L]] : $AnyObject
// CHECK:   end_borrow [[L]] : $AnyObject
// CHECK:   [[E1:%.*]] = struct_element_addr %2 : $*SRef<T>, #SRef.element
// CHECK:   copy_addr [[E1]] to [initialization] %1 : $*T
// CHECK:   destroy_addr %2 : $*SRef<T>
// CHECK:   store [[C]] to [init] %0 : $*AnyObject
// CHECK-NOT: dealloc_stack
// CHECK-LABEL: } // end sil function 'f123_testStructExtract'
sil [ossa] @f123_testStructExtract : $@convention(method) <T>(@in SRef<T>) -> (@out AnyObject, @out T) {
bb0(%0 : @owned $SRef<T>):
  %borrow = begin_borrow %0 : $SRef<T> 
  %object = struct_extract %borrow : $SRef<T>, #SRef.object
  %f = function_ref @takeGuaranteedObject : $@convention(thin) (@guaranteed AnyObject) -> ()
  %call = apply%f(%object) : $@convention(thin) (@guaranteed AnyObject) -> ()
  %copy1 = copy_value %object : $AnyObject
  %element = struct_extract %borrow : $SRef<T>, #SRef.element
  %copy2 = copy_value %element : $T
  end_borrow %borrow : $SRef<T>
  destroy_value %0 : $SRef<T>
  %tuple = tuple(%copy1 : $AnyObject, %copy2 : $T)
  return %tuple : $(AnyObject, T)
}

// CHECK-LABEL: sil [ossa] @f124_testTupleExtract : $@convention(method) <T> (@in (AnyObject, T)) -> (@out AnyObject, @out T) {
// CHECK: bb0(%0 : $*AnyObject, %1 : $*T, %2 : $*(AnyObject, T)):
// CHECK-NOT: alloc_stack
// CHECK:   [[E0:%.*]] = tuple_element_addr %2 : $*(AnyObject, T), 0
// CHECK:   [[C:%.*]] = load [copy] [[E0]] : $*AnyObject
// CHECK:   [[E1:%.*]] = tuple_element_addr %2 : $*(AnyObject, T), 1
// CHECK:   copy_addr [[E1]] to [initialization] %1 : $*T
// CHECK:   destroy_addr %2 : $*(AnyObject, T)
// CHECK:   store [[C]] to [init] %0 : $*AnyObject
// CHECK-NOT: dealloc_stack
sil [ossa] @f124_testTupleExtract : $@convention(method) <T>(@in (AnyObject, T)) -> (@out AnyObject, @out T) {
bb0(%0 : @owned $(AnyObject, T)):
  %borrow = begin_borrow %0 : $(AnyObject, T)
  %object = tuple_extract %borrow : $(AnyObject, T), 0
  %copy1 = copy_value %object : $AnyObject
  %element = tuple_extract %borrow : $(AnyObject, T), 1
  %copy2 = copy_value %element : $T
  end_borrow %borrow : $(AnyObject, T)
  destroy_value %0 : $(AnyObject, T)
  %tuple = tuple(%copy1 : $AnyObject, %copy2 : $T)
  return %tuple : $(AnyObject, T)
}

// CHECK-LABEL: sil [ossa] @f125_testTupleExtract : $@convention(method) <T> (@in (AnyObject, T)) -> (@out AnyObject, @out T) {
// CHECK: bb0(%0 : $*AnyObject, %1 : $*T, %2 : $*(AnyObject, T)):
// CHECK-NOT: alloc_stack
// CHECK:   [[E0:%.*]] = tuple_element_addr %2 : $*(AnyObject, T), 0
// CHECK:   [[L:%.*]] = load_borrow %3 : $*AnyObject
// CHECK:   apply %{{.*}}([[L]]) : $@convention(thin) (@guaranteed AnyObject) -> ()
// CHECK:   [[C:%.*]] = copy_value [[L]] : $AnyObject
// CHECK:   end_borrow [[L]] : $AnyObject
// CHECK:   [[E1:%.*]] = tuple_element_addr %2 : $*(AnyObject, T), 1
// CHECK:   copy_addr [[E1]] to [initialization] %1 : $*T
// CHECK:   destroy_addr %2 : $*(AnyObject, T)
// CHECK:   store [[C]] to [init] %0 : $*AnyObject
// CHECK-NOT: dealloc_stack
// CHECK-LABEL: } // end sil function 'f125_testTupleExtract'
sil [ossa] @f125_testTupleExtract : $@convention(method) <T>(@in (AnyObject, T)) -> (@out AnyObject, @out T) {
bb0(%0 : @owned $(AnyObject, T)):
  %borrow = begin_borrow %0 : $(AnyObject, T)
  %object = tuple_extract %borrow : $(AnyObject, T), 0
  %f = function_ref @takeGuaranteedObject : $@convention(thin) (@guaranteed AnyObject) -> ()
  %call = apply%f(%object) : $@convention(thin) (@guaranteed AnyObject) -> ()
  %copy1 = copy_value %object : $AnyObject
  %element = tuple_extract %borrow : $(AnyObject, T), 1
  %copy2 = copy_value %element : $T
  end_borrow %borrow : $(AnyObject, T)
  destroy_value %0 : $(AnyObject, T)
  %tuple = tuple(%copy1 : $AnyObject, %copy2 : $T)
  return %tuple : $(AnyObject, T)
}

// CHECK-LABEL: sil [ossa] @f126_testDestructureAndBorrow : $@convention(method) <Element> (@in (SI<Element>, I)) -> (@out Element, @out I) {
// CHECK: bb0(%0 : $*Element, %1 : $*I, %2 : $*(SI<Element>, I)):
// CHECK:   [[SI:%.*]] = tuple_element_addr %2 : $*(SI<Element>, I), 0
// CHECK:   [[I:%.*]] = tuple_element_addr %2 : $*(SI<Element>, I), 1
// CHECK:   [[LD:%.*]] = load [trivial] [[I]] : $*I
// CHECK:   [[E:%.*]] = struct_element_addr [[SI]] : $*SI<Element>, #SI.element
// CHECK:   copy_addr [[E]] to [initialization] %0 : $*Element
// CHECK:   destroy_addr [[SI]] : $*SI<Element>
// CHECK:   store [[LD]] to [trivial] %1 : $*I
// CHECK-LABEL: } // end sil function 'f126_testDestructureAndBorrow'
sil [ossa] @f126_testDestructureAndBorrow : $@convention(method) <Element> (@in (SI<Element>, I)) -> (@out Element, @out I) {
bb0(%0 : @owned $(SI<Element>, I)):
  (%si, %i) = destructure_tuple %0 : $(SI<Element>, I)
  %borrow = begin_borrow %si : $SI<Element>
  %element = struct_extract %borrow : $SI<Element>, #SI.element
  %copy = copy_value %element : $Element
  end_borrow %borrow : $SI<Element>
  destroy_value %si : $SI<Element>
  %tuple = tuple(%copy : $Element, %i : $I)
  return %tuple : $(Element, I)
}

// CHECK-LABEL: sil [ossa] @f130_testReleaseValue : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK:   destroy_addr %0 : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f130_testReleaseValue'
sil [ossa] @f130_testReleaseValue : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  destroy_value %0 : $T
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil [ossa] @f140_testTupleProject : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK:   [[LOCAL:%.*]] = alloc_stack $((T, T), T)
// CHECK:   [[ELT0:%.*]] = tuple_element_addr [[LOCAL]] : $*((T, T), T), 0
// CHECK:   [[ELT0_0:%.*]] = tuple_element_addr [[ELT0]] : $*(T, T), 0
// CHECK:   copy_addr %0 to [initialization] [[ELT0_0]] : $*T
// CHECK:   [[ELT1:%.*]] = tuple_element_addr [[LOCAL]] : $*((T, T), T), 1
// CHECK:   copy_addr %0 to [initialization] [[ELT1]] : $*T
// CHECK:   [[ELT0_1:%.*]] = tuple_element_addr [[ELT0]] : $*(T, T), 1
// CHECK:   copy_addr [take] %0 to [initialization] [[ELT0_1]] : $*T
// CHECK:   destroy_addr [[LOCAL]] : $*((T, T), T)
// CHECK:   dealloc_stack [[LOCAL]] : $*((T, T), T)
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f140_testTupleProject'
sil [ossa] @f140_testTupleProject : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  %copy0 = copy_value %0 : $T
  %copy1 = copy_value %0 : $T
  %tuple1 = tuple (%copy0 : $T, %0 : $T)
  %tuple2 = tuple (%tuple1 : $(T, T), %copy1 : $T)
  destroy_value %tuple2 : $((T, T), T)
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil [ossa] @f150_testStructProject : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : $*T):
// CHECK:   [[ALLOC:%.*]] = alloc_stack $Pair<Pair<T>>
// CHECK:   [[ELT_X:%.*]] = struct_element_addr [[ALLOC]] : $*Pair<Pair<T>>, #Pair.x
// CHECK:   [[ELT_XY:%.*]] = struct_element_addr [[ELT_X]] : $*Pair<T>, #Pair.y
// CHECK:   copy_addr %0 to [initialization] [[ELT_XY]] : $*T
// CHECK:   [[ELT_XX:%.*]] = struct_element_addr [[ELT_X]] : $*Pair<T>, #Pair.x
// CHECK:   copy_addr [take] %0 to [initialization] [[ELT_XX]] : $*T
// CHECK:   [[ELT_Y:%.*]] = struct_element_addr [[ALLOC]] : $*Pair<Pair<T>>, #Pair.y
// CHECK:   copy_addr [[ELT_X]] to [initialization] [[ELT_Y]] : $*Pair<T>
// CHECK:   destroy_addr [[ALLOC]] : $*Pair<Pair<T>>
// CHECK:   dealloc_stack [[ALLOC]] : $*Pair<Pair<T>>
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f150_testStructProject'
sil [ossa] @f150_testStructProject : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  %copy0 = copy_value %0 : $T
  %struct1 = struct $Pair<T> (%0 : $T, %copy0 : $T)
  %struct_copy = copy_value %struct1 : $Pair<T>
  %struct2 = struct $Pair<Pair<T>> (%struct1 : $Pair<T>, %struct_copy : $Pair<T>)
  destroy_value %struct2 : $Pair<Pair<T>>
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil [ossa] @f160_testOpenedArchetype : $@convention(thin) (@in P) -> () {
// CHECK: bb0(%0 : $*P):
// CHECK:   [[ALLOC:%.*]] = alloc_stack $P, var, name "q"
// CHECK:   copy_addr %0 to [initialization] [[ALLOC]] : $*P
// CHECK:   [[OPEN:%.*]] = open_existential_addr immutable_access %0 : $*P to $*[[ARCHETYPE:@opened(.*)]] P
// CHECK:   [[CP:%.*]] = alloc_stack $[[ARCHETYPE]] P // type-defs: [[OPEN]];
// CHECK:   [[WT:%.*]] = witness_method $[[ARCHETYPE]] P, #P.foo : <Self where Self : P> (Self) -> () -> (), [[OPEN]] : $*[[ARCHETYPE]] P : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
// CHECK:   copy_addr [[OPEN]] to [initialization] [[CP]] : $*[[ARCHETYPE]] P
// CHECK:   %{{.*}} = apply [[WT]]<[[ARCHETYPE]] P>([[CP]]) : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
// CHECK:   destroy_addr [[CP]] : $*[[ARCHETYPE]] P
// CHECK:   destroy_addr [[ALLOC]] : $*P
// CHECK:   destroy_addr %0 : $*P
// CHECK:   %{{.*}} = tuple ()
// CHECK:   dealloc_stack [[CP]] : $*[[ARCHETYPE]] P
// CHECK:   dealloc_stack [[ALLOC]] : $*P
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f160_testOpenedArchetype'
sil [ossa] @f160_testOpenedArchetype : $@convention(thin) (@in P) -> () {
bb0(%0 : @owned $P):
  %2 = alloc_stack $P, var, name "q"
  %3 = copy_value %0 : $P
  store %3 to [init] %2 : $*P
  %b = begin_borrow %0 : $P
  %8 = open_existential_value %b : $P to $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
  %9 = witness_method $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P, #P.foo, %8 : $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
  // Test that we can handle owned value of type opened archetype.
  %10 = copy_value %8 : $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
  end_borrow %b : $P
  %11 = apply %9<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>(%10) : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
  destroy_value %10 : $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
  destroy_addr %2 : $*P
  dealloc_stack %2 : $*P
  destroy_value %0 : $P
  %16 = tuple ()
  return %16 : $()
}

// CHECK-LABEL: sil [ossa] @f161_testOpenedArchetype : $@convention(thin) (@in P) -> () {
// CHECK: bb0(%0 : $*P):
// CHECK:   [[ALLOCP:%.*]] = alloc_stack $P, var, name "q"
// CHECK:   copy_addr %0 to [initialization] [[ALLOCP]] : $*P
// CHECK:   [[OPEN:%.*]] = open_existential_addr immutable_access %0 : $*P to $*@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
// CHECK:   [[OPTIONAL:%.*]] = alloc_stack $Optional<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>
// CHECK:   witness_method $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P, #P.foo : <Self where Self : P> (Self) -> () -> (), [[OPEN]] : $*@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
// CHECK:   [[INIT:%.*]] = init_enum_data_addr [[OPTIONAL]] : $*Optional<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>, #Optional.some!enumelt
// CHECK:   copy_addr [[OPEN]] to [initialization] [[INIT]] : $*@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
// CHECK:   inject_enum_addr [[OPTIONAL]] : $*Optional<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>, #Optional.some!enumelt
// CHECK:   [[DATA:%.*]] = unchecked_take_enum_data_addr [[OPTIONAL]] : $*Optional<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>, #Optional.some!enumelt
// CHECK:   %10 = apply %{{.*}}<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>([[DATA]]) : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
// CHECK:   destroy_addr %9 : $*@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
// CHECK:   destroy_addr [[ALLOCP]] : $*P
// CHECK:   destroy_addr %0 : $*P
// CHECK:   dealloc_stack [[OPTIONAL]] : $*Optional<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>
// CHECK:   dealloc_stack [[ALLOCP]] : $*P
// CHECK-LABEL: } // end sil function 'f161_testOpenedArchetype'
sil [ossa] @f161_testOpenedArchetype : $@convention(thin) (@in P) -> () {
bb0(%0 : @owned $P):
  %2 = alloc_stack $P, var, name "q"
  %3 = copy_value %0 : $P
  store %3 to [init] %2 : $*P
  %b = begin_borrow %0 : $P
  %8 = open_existential_value %b : $P to $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
  %9 = witness_method $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P, #P.foo, %8 : $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
  %cpy = copy_value %8 : $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
  end_borrow %b : $P
  // This optional is an aggregate that contains an opened existential. Make sure it is allocated after open_existential_addr.
  %opt = enum $Optional<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>, #Optional.some!enumelt, %cpy : $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
  %some = unchecked_enum_data %opt : $Optional<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>, #Optional.some!enumelt
  %11 = apply %9<@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P>(%some) : $@convention(witness_method: P) <τ_0_0 where τ_0_0 : P> (@in_guaranteed τ_0_0) -> ()
  destroy_value %some : $@opened("EF755EF2-B636-11E7-B7B4-A45E60ECC541") P
  destroy_addr %2 : $*P
  dealloc_stack %2 : $*P
  destroy_value %0 : $P
  %16 = tuple ()
  return %16 : $()
}

// CHECK-LABEL: sil [ossa] @f170_compare : $@convention(thin) <T where T : Comparable> (@in_guaranteed T, @in_guaranteed T) -> @out T {
// CHECK: bb0(%0 : $*T, %1 : $*T, %2 : $*T):
// CHECK:   [[WT:%.*]] = witness_method $T, #Comparable."<" : <Self where Self : Comparable> (Self.Type) -> (Self, Self) -> Builtin.Int1 : $@convention(witness_method: Comparable) <τ_0_0 where τ_0_0 : Comparable> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_0, @thick τ_0_0.Type) -> Builtin.Int1
// CHECK:   [[MT:%.*]] = metatype $@thick T.Type
// CHECK:   [[COND:%.*]] = apply [[WT]]<T>(%1, %2, [[MT]]) : $@convention(witness_method: Comparable) <τ_0_0 where τ_0_0 : Comparable> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_0, @thick τ_0_0.Type) -> Builtin.Int1
// CHECK:   cond_br [[COND]], bb2, bb1
// CHECK: bb1:
// CHECK:   copy_addr %1 to [initialization] %0 : $*T
// CHECK:   br bb3
// CHECK: bb2:
// CHECK:   copy_addr %2 to [initialization] %0 : $*T
// CHECK:   br bb3
// CHECK-LABEL: } // end sil function 'f170_compare'
sil [ossa] @f170_compare : $@convention(thin) <T where T : Comparable> (@in_guaranteed T, @in_guaranteed T) -> @out T {
bb0(%0 : @guaranteed $T, %1 : @guaranteed $T):
  %2 = witness_method $T, #Comparable."<" : <Self where Self : Comparable> (Self.Type) -> (Self, Self) -> Bool : $@convention(witness_method: Comparable) <τ_0_0 where τ_0_0 : Comparable> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_0, @thick τ_0_0.Type) -> Bool
  %3 = metatype $@thick T.Type
  %4 = apply %2<T>(%0, %1, %3) : $@convention(witness_method: Comparable) <τ_0_0 where τ_0_0 : Comparable> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_0, @thick τ_0_0.Type) -> Bool
  cond_br %4, bb1, bb2

bb1:
  %6 = copy_value %1 : $T
  br bb3(%6 : $T)

bb2:
  %8 = copy_value %0 : $T
  br bb3(%8 : $T)

bb3(%15 : @owned $T):
  return %15 : $T
}

// Test switching on a single opaque value.
// CHECK-LABEL: sil [ossa] @f210_testSwitchEnum : $@convention(method) <T> (@in Optional<T>, @inout T) -> () {
// CHECK: bb0(%0 : $*Optional<T>, %1 : $*T):
// CHECK:   switch_enum_addr %0 : $*Optional<T>, case #Optional.some!enumelt: [[SOMEBB:bb[0-9]+]], case #Optional.none!enumelt: [[NONEBB:bb[0-9]+]]
// CHECK: [[NONEBB]]:
// CHECK:   br [[RETBB:bb[0-9]+]]
// CHECK: [[SOMEBB]]:
// CHECK:   [[CAST:%.*]] = unchecked_take_enum_data_addr %0 : $*Optional<T>, #Optional.some!enumelt
// CHECK:   copy_addr [take] [[CAST]] to [initialization] %1 : $*T
// CHECK:   br [[RETBB]]
// CHECK: [[RETBB]]:
// CHECK-LABEL: } // end sil function 'f210_testSwitchEnum'
sil [ossa] @f210_testSwitchEnum : $@convention(method) <T> (@in Optional<T>, @inout T) -> () {
bb0(%0 : @owned $Optional<T>, %1 : $*T):
  switch_enum %0 : $Optional<T>, case #Optional.some: bb2, case #Optional.none: bb1

bb1:
  br bb3

bb2(%some : @owned $T):
  destroy_addr %1 : $*T
  store %some to [init] %1 : $*T
  br bb3

bb3:
  %31 = tuple ()
  return %31 : $()
}

// f220_testSwitchMixed
// CHECK-LABEL: sil [ossa] @f220_testSwitchMixed : $@convention(method) <T> (@in Mixed<T>, @inout Builtin.Int64, @inout T) -> () {
// CHECK: bb0(%0 : $*Mixed<T>, %1 : $*Builtin.Int64, %2 : $*T):
// CHECK:   switch_enum_addr %0 : $*Mixed<T>, case #Mixed.i!enumelt: [[IBB:bb[0-9]+]], case #Mixed.t!enumelt: [[TBB:bb[0-9]+]], default [[DBB:bb[0-9]+]]
// CHECK: [[DBB]]:
// CHECK:   [[OBJADDR:%.*]] = unchecked_take_enum_data_addr %0 : $*Mixed<T>, #Mixed.o!enumelt
// CHECK:   [[LD:%.*]] = load [take] [[OBJADDR]] : $*AnyObject
// CHECK:   destroy_value [[LD]] : $AnyObject 
// CHECK:   br [[RBB:bb[0-9]+]]
// CHECK: [[TBB]]:
// CHECK:   [[CAST:%.*]] = unchecked_take_enum_data_addr %0 : $*Mixed<T>, #Mixed.t!enumelt
// CHECK:   destroy_addr %2 : $*T
// CHECK:   copy_addr [take] [[CAST]] to [initialization] %2 : $*T
// CHECK:   br [[RBB]]
// CHECK: [[IBB]]:
// CHECK:   [[CAST:%.*]] = unchecked_take_enum_data_addr %0 : $*Mixed<T>, #Mixed.i!enumelt
// CHECK:   [[VAL:%.*]] = load [trivial] [[CAST]] : $*Builtin.Int64
// CHECK:   store [[VAL]] to [trivial] %1 : $*Builtin.Int64
// CHECK:   br [[RBB]]
// CHECK: [[RBB]]:
// CHECK-LABEL: } // end sil function 'f220_testSwitchMixed'
sil [ossa] @f220_testSwitchMixed : $@convention(method) <T> (@in Mixed<T>, @inout Int, @inout T) -> () {
bb0(%0 : @owned $Mixed<T>, %1 : $*Int, %2 : $*T):
  switch_enum %0 : $Mixed<T>, case #Mixed.i: bb1, case #Mixed.t: bb2, default bb3

bb1(%13 : $Int):
  store %13 to [trivial] %1 : $*Int
  br bb4

bb2(%14 : @owned $T):
  destroy_addr %2 : $*T
  store %14 to [init] %2 : $*T
  br bb4

bb3(%18: @owned $AnyObject):
  destroy_value %18 : $AnyObject
  br bb4

bb4:
  %31 = tuple ()
  return %31 : $()
}

// CHECK-LABEL: sil [ossa] @f230_testTryApply : $@convention(thin) <T> (@in T) -> (@out T, @error Error) {
// CHECK: bb0(%0 : $*T, %1 : $*T):
// CHECK:   [[F:%.*]] = function_ref @throwsError : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @error Error)
// CHECK:   try_apply [[F]]<T>(%0, %1) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @error Error), normal bb2, error bb1
// CHECK: bb1([[E:%.*]] : $Error):
// CHECK:   throw [[E]] : $Error
// CHECK: bb2([[NONE:%.*]] : $()):
// CHECK:   %{{.*}} = tuple ()
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f230_testTryApply'
sil [ossa] @f230_testTryApply : $@convention(thin) <T> (@in T) -> (@out T, @error Error) {
bb0(%0 : @owned $T):
  %3 = function_ref @throwsError : $@convention(thin) <T> (@in T) -> (@out T, @error Error)
  try_apply %3<T>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, @error Error), normal bb1, error bb2

bb1(%5 : @owned $T):
  return %5 : $T

bb2(%7 : $Error):
  throw %7 : $Error
}

// CHECK-LABEL: sil [ossa] @f240_testTryApplyDirect : $@convention(thin) <T> (@in T) -> (Builtin.Int64, @error Error) {
// CHECK: bb0(%0 : $*T):
// CHECK:   [[F:%.*]] = function_ref @returnInt : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (Builtin.Int64, @error Error)
// CHECK:   try_apply [[F]]<T>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (Builtin.Int64, @error Error), normal bb2, error bb1
// CHECK: bb1([[E:%.*]] : $Error):
// CHECK:   throw [[E]] : $Error
// CHECK: bb2([[V:%.*]] : $Builtin.Int64):
// CHECK:   return [[V]] : $Builtin.Int64
// CHECK-LABEL: } // end sil function 'f240_testTryApplyDirect'
sil [ossa] @f240_testTryApplyDirect : $@convention(thin) <T> (@in T) -> (Int, @error Error) {
bb0(%0 : @owned $T):
  %3 = function_ref @returnInt : $@convention(thin) <T> (@in T) -> (Int, @error Error)
  try_apply %3<T>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (Int, @error Error), normal bb1, error bb2

bb1(%5 : $Int):
  return %5 : $Int

bb2(%7 : $Error):
  throw %7 : $Error
}

// CHECK-LABEL: sil [ossa] @f250_testTryApplyIndirect : $@convention(thin) <T> (@in T) -> (Builtin.Int64, @error Error) {
// CHECK: bb0(%0 : $*T):
// CHECK:   [[F:%.*]] = function_ref @returnIntOut : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out Builtin.Int64, @error Error)
// CHECK:   [[OUT_I:%.*]] = alloc_stack $Builtin.Int64
// CHECK:   try_apply %1<T>([[OUT_I]], %0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out Builtin.Int64, @error Error), normal bb2, error bb1
// CHECK: bb1([[E:%.*]] : $Error):
// CHECK:   dealloc_stack [[OUT_I]] : $*Builtin.Int64
// CHECK:   throw [[E]] : $Error
// CHECK: bb2(%{{.*}} : $()):
// CHECK:   [[V:%.*]] = load [trivial] [[OUT_I]] : $*Builtin.Int64
// CHECK:   dealloc_stack [[OUT_I]] : $*Builtin.Int64
// CHECK:   return [[V]] : $Builtin.Int64
// CHECK-LABEL: } // end sil function 'f250_testTryApplyIndirect'
sil [ossa] @f250_testTryApplyIndirect : $@convention(thin) <T> (@in T) -> (Int, @error Error) {
bb0(%0 : @owned $T):
  %3 = function_ref @returnIntOut : $@convention(thin) <T> (@in T) -> (@out Int, @error Error)
  try_apply %3<T>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out Int, @error Error), normal bb1, error bb2

bb1(%5 : $Int):
  return %5 : $Int

bb2(%7 : $Error):
  throw %7 : $Error
}

// CHECK-LABEL: sil [ossa] @f260_testTryApplyTuple : $@convention(thin) <T> (@in T) -> (@out T, @error Error) {
// CHECK: bb0(%0 : $*T, %1 : $*T):
// CHECK:   [[OUT_T:%.*]] = alloc_stack $T
// CHECK:   [[F:%.*]] = function_ref @returnTuple : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, Builtin.Int64, @out Builtin.Int64, @out τ_0_0, @error Error)
// CHECK:   [[OUT_I:%.*]] = alloc_stack $Builtin.Int64
// CHECK:   try_apply [[F]]<T>([[OUT_T]], [[OUT_I]], %0, %1) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> (@out τ_0_0, Builtin.Int64, @out Builtin.Int64, @out τ_0_0, @error Error), normal bb2, error bb1
// CHECK: bb1([[E:%.*]] : $Error):
// CHECK:   dealloc_stack [[OUT_I]] : $*Builtin.Int64
// CHECK:   dealloc_stack [[OUT_T]] : $*T
// CHECK:   throw [[E]] : $Error
// CHECK: bb2([[RESULT:%.*]] : $Builtin.Int64):
// CHECK:   dealloc_stack [[OUT_I]] : $*Builtin.Int64
// CHECK:   destroy_addr [[OUT_T]] : $*T
// CHECK:   %{{.*}} = tuple ()
// CHECK:   dealloc_stack [[OUT_T]] : $*T
// CHECK:   return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'f260_testTryApplyTuple'
sil [ossa] @f260_testTryApplyTuple : $@convention(thin) <T> (@in T) -> (@out T, @error Error) {
bb0(%0 : @owned $T):
  %1 = function_ref @returnTuple : $@convention(thin) <T> (@in T) -> (@out T, Int, @out Int, @out T, @error Error)
  try_apply %1<T>(%0) : $@convention(thin) <T> (@in T) -> (@out T, Int, @out Int, @out T, @error Error), normal bb1, error bb2

bb1(%3 : @owned $(T, Int, Int, T)):
  (%4, %5, %6, %7) = destructure_tuple %3 : $(T, Int, Int, T)
  destroy_value %4 : $T
  return %7 : $T

bb2(%9 : $Error):
  throw %9 : $Error
}

sil [ossa] @use_T : $@convention(thin) <T> (@in T) -> ()

// CHECK-LABEL: sil [ossa] @test_checked_cast_br1 : $@convention(method) <T> (@in Any) -> () {
// CHECK: bb0(%0 : $*Any):
// CHECK:   [[SUCCESS_DST:%.*]] = alloc_stack $T
// CHECK:   checked_cast_addr_br take_on_success Any in %0 : $*Any to T in [[SUCCESS_DST]] : $*T, bb2, bb1
// CHECK: bb1:
// CHECK:   destroy_addr %0 : $*Any
// CHECK:   br bb3
// CHECK: bb2:
// CHECK:   [[FUNC:%.*]] = function_ref @use_T : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
// CHECK:   apply [[FUNC]]<T>([[SUCCESS_DST]]) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
// CHECK:   br bb3
// CHECK: bb3:
// CHECK:   [[RES:%.*]] = tuple ()
// CHECK:   dealloc_stack [[SUCCESS_DST]] : $*T
// CHECK:   return [[RES]] : $()
// CHECK-LABEL: } // end sil function 'test_checked_cast_br1'
sil [ossa] @test_checked_cast_br1 : $@convention(method) <T> (@in Any) -> () {
bb0(%0 : @owned $Any):
   checked_cast_br %0 : $Any to T, bb1, bb2

bb1(%3 : @owned $T):
  %f = function_ref @use_T : $@convention(thin) <T> (@in T) -> ()
  %call = apply %f<T>(%3) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
  br bb3

bb2(%4 : @owned $Any):
  destroy_value %4 : $Any
  br bb3

bb3:
  %31 = tuple ()
  return %31 : $()
}

sil [ossa] @use_C : $@convention(thin) (@owned C) -> ()

// CHECK-LABEL: sil [ossa] @test_checked_cast_br2 : $@convention(method) (@in Any) -> () {
// CHECK: bb0(%0 : $*Any):
// CHECK:   [[SUCCESS_DST:%.*]] = alloc_stack $C
// CHECK:   checked_cast_addr_br take_on_success Any in %0 : $*Any to C in [[SUCCESS_DST]] : $*C, bb2, bb1
// CHECK: bb1:
// CHECK:   dealloc_stack [[SUCCESS_DST]] : $*C
// CHECK:   destroy_addr %0 : $*Any
// CHECK:   br bb3
// CHECK: bb2:
// CHECK:   [[LD:%.*]] = load [take] [[SUCCESS_DST]] : $*C
// CHECK:   dealloc_stack [[SUCCESS_DST]] : $*C
// CHECK:   [[FUNC:%.*]] = function_ref @use_C : $@convention(thin) (@owned C) -> ()
// CHECK:   apply [[FUNC]]([[LD]]) : $@convention(thin) (@owned C) -> ()
// CHECK:   br bb3
// CHECK: bb3:
// CHECK:   [[RES:%.*]] = tuple ()
// CHECK:   return [[RES]] : $()
// CHECK-LABEL: }
sil [ossa] @test_checked_cast_br2 : $@convention(method) (@in Any) -> () {
bb0(%0 : @owned $Any):
   checked_cast_br %0 : $Any to C, bb1, bb2

bb1(%3 : @owned $C):
  %f = function_ref @use_C : $@convention(thin) (@owned C) -> ()
  %call = apply %f(%3) : $@convention(thin) (@owned C) -> ()
  br bb3

bb2(%4 : @owned $Any):
  destroy_value %4 : $Any
  br bb3

bb3:
  %31 = tuple ()
  return %31 : $()
}

sil @use_Any : $@convention(thin) (@in Any) -> ()

// CHECK-LABEL:  sil [ossa] @test_checked_cast_br3 : $@convention(method) (@owned C) -> () {
// CHECK: bb0(%0 : @owned $C):
// CHECK:   [[DST:%.*]] = alloc_stack $Any
// CHECK:   [[SRC_TMP:%.*]] = alloc_stack $C
// CHECK:   store %0 to [init] [[SRC_TMP]] : $*C
// CHECK:   checked_cast_addr_br take_on_success C in [[SRC_TMP]] : $*C to Any in [[DST]] : $*Any, bb2, bb1
// CHECK: bb1:
// CHECK:   [[LD:%.*]] = load [take] [[SRC_TMP]] : $*C
// CHECK:   dealloc_stack [[SRC_TMP]] : $*C
// CHECK:   destroy_value [[LD]] : $C
// CHECK:   br bb3
// CHECK: bb2:
// CHECK:   dealloc_stack [[SRC_TMP]] : $*C
// CHECK:   [[FUNC:%.*]] = function_ref @use_Any : $@convention(thin) (@in Any) -> ()
// CHECK:   apply [[FUNC]]([[DST]]) : $@convention(thin) (@in Any) -> ()
// CHECK:   br bb3
// CHECK: bb3:
// CHECK:   [[RES:%.*]] = tuple ()
// CHECK:   dealloc_stack [[DST]] : $*Any
// CHECK:   return [[RES]] : $()
// CHECK: }
sil [ossa] @test_checked_cast_br3 : $@convention(method) (@owned C) -> () {
bb0(%0 : @owned $C):
   checked_cast_br %0 : $C to Any, bb1, bb2

bb1(%3 : @owned $Any):
  %f = function_ref @use_Any : $@convention(thin) (@in Any) -> ()
  %call = apply %f(%3) : $@convention(thin) (@in Any) -> ()
  br bb3

bb2(%4 : @owned $C):
  destroy_value %4 : $C
  br bb3

bb3:
  %31 = tuple ()
  return %31 : $()
}

// CHECK-LABEL: sil hidden [ossa] @test_unchecked_bitwise_cast :
// CHECK: bb0(%0 : $*U, %1 : $*T, %2 : $@thick U.Type):
// CHECK:   [[STK:%.*]] = alloc_stack $T
// CHECK:   copy_addr %1 to [initialization] [[STK]] : $*T
// CHECK:   [[CAST:%.*]] = unchecked_addr_cast [[STK]] : $*T to $*U
// CHECK:   copy_addr [[CAST]] to [initialization] %0 : $*U
// CHECK:   destroy_addr [[STK]] : $*T
// CHECK:   dealloc_stack [[STK]] : $*T
// CHECK-LABEL: } // end sil function 'test_unchecked_bitwise_cast'
sil hidden [ossa] @test_unchecked_bitwise_cast : $@convention(thin) <T, U> (@in_guaranteed T, @thick U.Type) -> @out U {
bb0(%0 : @guaranteed $T, %1 : $@thick U.Type):
  %4 = copy_value %0 : $T
  %5 = unchecked_bitwise_cast %4 : $T to $U
  %6 = copy_value %5 : $U
  destroy_value %4 : $T
  return %6 : $U
}

// CHECK-LABEL: sil hidden [ossa] @test_unconditional_checked_cast1 : $@convention(thin) <T> (Builtin.Int64) -> @out T {
// CHECK: bb0(%0 : $*T, %1 : $Builtin.Int64):
// CHECK:   [[INT:%.*]] = alloc_stack $Builtin.Int64
// CHECK:   store %1 to [trivial] [[INT]] : $*Builtin.Int64
// CHECK:   unconditional_checked_cast_addr Builtin.Int64 in [[INT]] : $*Builtin.Int64 to T in %0 : $*T
// CHECK:   %5 = tuple ()
// CHECK:   dealloc_stack %2 : $*Builtin.Int64
// CHECK:   return %5 : $()
// CHECK: } // end sil function 'test_unconditional_checked_cast1'
sil hidden [ossa] @test_unconditional_checked_cast1 : $@convention(thin) <T> (Int) -> @out T {
bb0(%0 : $Int):
  %2 = unconditional_checked_cast %0 : $Int to T
  return %2 : $T
}

// CHECK: sil hidden [ossa] @test_unconditional_checked_cast2 : $@convention(thin) <T> (@in_guaranteed T) -> Builtin.Int64 {
// CHECK: bb0(%0 : $*T):
// CHECK:   [[SRC:%.*]] = alloc_stack $T
// CHECK:   copy_addr %0 to [initialization] [[SRC]] : $*T
// CHECK:   [[INT:%.*]] = alloc_stack $Builtin.Int64
// CHECK:   unconditional_checked_cast_addr T in [[SRC]] : $*T to Builtin.Int64 in [[INT]] : $*Builtin.Int64
// CHECK:   [[RES:%.*]] = load [trivial] [[INT]] : $*Builtin.Int64
// CHECK:   return [[RES]] : $Builtin.Int64
// CHECK: } // end sil function 'test_unconditional_checked_cast2'
sil hidden [ossa] @test_unconditional_checked_cast2 : $@convention(thin) <T> (@in_guaranteed T) -> Int {
bb0(%0 : @guaranteed $T):
  %2 = copy_value %0 : $T
  %3 = unconditional_checked_cast %2 : $T to Int
  return %3 : $Int
}

// CHECK-LABEL: sil hidden [ossa] @test_unconditional_checked_cast3 : $@convention(thin) <T, U> (@in_guaranteed T) -> @out U {
// CHECK: bb0(%0 : $*U, %1 : $*T):
// CHECK:   [[TTMP:%.*]] = alloc_stack $T
// CHECK:   [[UTMP:%.*]] = alloc_stack [lexical] $U
// CHECK:   copy_addr %1 to [initialization] [[TTMP]] : $*T
// CHECK:   unconditional_checked_cast_addr T in [[TTMP]] : $*T to U in [[UTMP]] : $*U
// CHECK:   copy_addr [[UTMP]] to [initialization] %0 : $*U
// CHECK:   destroy_addr [[UTMP]] : $*U
// CHECK:   %8 = tuple ()
// CHECK:   dealloc_stack [[UTMP]] : $*U
// CHECK:   dealloc_stack [[TTMP]] : $*T
// CHECK:   return %8 : $()
// CHECK-LABEL: } // end sil function 'test_unconditional_checked_cast3'
sil hidden [ossa] @test_unconditional_checked_cast3 : $@convention(thin) <T, U> (@in_guaranteed T) -> @out U {
bb0(%0 : @guaranteed $T):
  %2 = copy_value %0 : $T
  %3 = unconditional_checked_cast %2 : $T to U
  %4 = begin_borrow [lexical] %3 : $U
  %6 = copy_value %4 : $U
  end_borrow %4 : $U
  destroy_value %3 : $U
  return %6 : $U
}

