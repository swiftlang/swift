// RUN: %target-sil-opt -loop-rotate -looprotate-single-block-loop=true -looprotate-infinite-budget %s | %FileCheck %s
sil_stage canonical

import Builtin
import Swift

class Klass {
}

struct BoxStruct {
    var guts: Klass
}

sil [ossa] @useKlass : $@convention(thin) (@guaranteed Klass) -> ()

sil [ossa] @klassIdentity : $@convention(thin) (@owned Klass) -> @owned Klass

sil [ossa] @increment : $@convention(thin) (Builtin.Int32) -> Builtin.Int32

// CHECK-LABEL: sil [ossa] @testLoopSimple : 
// CHECK: bb0(%0 : $Int32, %1 : @owned $Klass):
// CHECK:   cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK-LABEL: } // end sil function 'testLoopSimple'
sil [ossa] @testLoopSimple : $@convention(thin) (Int32, @owned Klass) -> (){
bb0(%0 : $Int32, %1: @owned $Klass):
  %2 = struct_extract %0 : $Int32, #Int32._value
  %one = integer_literal $Builtin.Int32, 1
  br bb1(%2 : $Builtin.Int32, %1 : $Klass)

bb1(%3 : $Builtin.Int32, %4: @owned $Klass):
  %f1 = function_ref @klassIdentity : $@convention(thin) (@owned Klass) -> @owned Klass
  %c1 = apply %f1(%4) : $@convention(thin) (@owned Klass) -> @owned Klass
  %f2 = function_ref @increment : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %c2 = apply %f2(%3) : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %5 = struct $Int32 (%c2 : $Builtin.Int32)
  %6 = builtin "cmp_eq_Word"(%5 : $Int32, %one : $Builtin.Int32) : $Builtin.Int1
  cond_br %6, bb3, bb2

bb2:
  br bb1(%c2 : $Builtin.Int32, %c1: $Klass)

bb3:
  destroy_value %c1 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @testLoopCopy : 
// CHECK: bb0(%0 : $Int32, %1 : @owned $Klass):
// CHECK:   cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK-LABEL: } // end sil function 'testLoopCopy'
sil [ossa] @testLoopCopy : $@convention(thin) (Int32, @owned Klass) -> (){
bb0(%0 : $Int32, %1: @owned $Klass):
  %2 = struct_extract %0 : $Int32, #Int32._value
  %one = integer_literal $Builtin.Int32, 1
  br bb1(%2 : $Builtin.Int32, %1 : $Klass)

bb1(%3 : $Builtin.Int32, %4: @owned $Klass):
  %f1 = function_ref @klassIdentity : $@convention(thin) (@owned Klass) -> @owned Klass
  %copy = copy_value %4 : $Klass
  destroy_value %4 : $Klass
  %c1 = apply %f1(%copy) : $@convention(thin) (@owned Klass) -> @owned Klass
  %f2 = function_ref @increment : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %c2 = apply %f2(%3) : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %5 = struct $Int32 (%c2 : $Builtin.Int32)
  %6 = builtin "cmp_eq_Word"(%5 : $Int32, %one : $Builtin.Int32) : $Builtin.Int1
  cond_br %6, bb3, bb2

bb2:
  br bb1(%c2 : $Builtin.Int32, %c1: $Klass)

bb3:
  destroy_value %c1 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @testLoopBorrow1 : 
// CHECK: bb0(%0 : $Int32, %1 : @owned $Klass):
// CHECK:   cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK-LABEL: } // end sil function 'testLoopBorrow1'
sil [ossa] @testLoopBorrow1 : $@convention(thin) (Int32, @owned Klass) -> (){
bb0(%0 : $Int32, %1: @owned $Klass):
  %2 = struct_extract %0 : $Int32, #Int32._value
  %one = integer_literal $Builtin.Int32, 1
  br bb1(%2 : $Builtin.Int32, %1 : $Klass)

bb1(%3 : $Builtin.Int32, %4: @owned $Klass):
  %f1 = function_ref @useKlass : $@convention(thin) (@guaranteed Klass) -> ()
  %borrow = begin_borrow %4 : $Klass
  %c1 = apply %f1(%borrow) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %borrow : $Klass
  %f2 = function_ref @increment : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %c2 = apply %f2(%3) : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %5 = struct $Int32 (%c2 : $Builtin.Int32)
  %6 = builtin "cmp_eq_Word"(%5 : $Int32, %one : $Builtin.Int32) : $Builtin.Int1
  cond_br %6, bb3, bb2

bb2:
  br bb1(%c2 : $Builtin.Int32, %4 : $Klass)

bb3:
  destroy_value %4 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @testLoopBorrow2 : 
// CHECK: bb0(%0 : $Int32, %1 : @owned $Klass):
// CHECK:   cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK-LABEL: } // end sil function 'testLoopBorrow2'
sil [ossa] @testLoopBorrow2 : $@convention(thin) (Int32, @owned Klass) -> () {
bb0(%0 : $Int32, %1 : @owned $Klass):
  %2 = struct_extract %0, #Int32._value
  %3 = integer_literal $Builtin.Int32, 1
  %4 = begin_borrow %1
  br bb1(%2, %4)

bb1(%6 : $Builtin.Int32, %7 : @reborrow $Klass):
  %8 = borrowed %7 from (%1)
  %9 = function_ref @useKlass : $@convention(thin) (@guaranteed Klass) -> ()
  %10 = apply %9(%8) : $@convention(thin) (@guaranteed Klass) -> ()
  %11 = function_ref @increment : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %12 = apply %11(%6) : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %13 = struct $Int32 (%12)
  %14 = builtin "cmp_eq_Word"(%13, %3) : $Builtin.Int1
  cond_br %14, bb3, bb2

bb2:
  br bb1(%12, %8)

bb3:
  end_borrow %8
  destroy_value %1
  %19 = tuple ()
  return %19
}

// CHECK-LABEL: sil [ossa] @testLoopBorrow3 : 
// CHECK: bb0(%0 : $Int32, %1 : @owned $Klass):
// CHECK:   cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK-LABEL: } // end sil function 'testLoopBorrow3'
sil [ossa] @testLoopBorrow3 : $@convention(thin) (Int32, @owned Klass) -> () {
bb0(%0 : $Int32, %1 : @owned $Klass):
  %2 = struct_extract %0, #Int32._value
  %3 = integer_literal $Builtin.Int32, 1
  %4 = begin_borrow %1
  br bb1(%2, %4)

bb1(%6 : $Builtin.Int32, %7 : @reborrow $Klass):
  %8 = borrowed %7 from (%1)
  %9 = function_ref @useKlass : $@convention(thin) (@guaranteed Klass) -> ()
  %10 = apply %9(%8) : $@convention(thin) (@guaranteed Klass) -> ()
  %11 = function_ref @increment : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %12 = apply %11(%6) : $@convention(thin) (Builtin.Int32) -> Builtin.Int32
  %13 = struct $Int32 (%12)
  %14 = builtin "cmp_eq_Word"(%13, %3) : $Builtin.Int1
  end_borrow %8
  %16 = begin_borrow %1
  cond_br %14, bb3, bb2

bb2:
  br bb1(%12, %16)

bb3:
  end_borrow %16
  destroy_value %1
  %21 = tuple ()
  return %21
}

// CHECK-LABEL: sil [ossa] @guaranteed_phi_argument : $@convention(thin) (@owned Klass) -> () {
// CHECK:         {{bb[0-9]+}}({{%[^,]+}} : @reborrow $Klass):
// CHECK-LABEL: } // end sil function 'guaranteed_phi_argument'
sil [ossa] @guaranteed_phi_argument : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = begin_borrow [lexical] %0
  br bb1(%1)

bb1(%3 : @reborrow $Klass):
  %4 = borrowed %3 from (%0)
  cond_br undef, bb2, bb3

bb2:
  br bb1(%4)

bb3:
  cond_br undef, bb4, bb5

bb4:
  br bb1(%4)

bb5:
  end_borrow %4
  destroy_value %0
  %11 = tuple ()
  return %11
}

// A guaranteed value whose ownership has been forwarded must not be reborrowed. 
//
// CHECK-LABEL: sil [ossa] @forwarded_borrow_cant_be_reborrowed : $@convention(thin) (@owned BoxStruct) -> () {
// CHECK-LABEL: } // end sil function 'forwarded_borrow_cant_be_reborrowed'
sil [ossa] @forwarded_borrow_cant_be_reborrowed : $@convention(thin) (@owned BoxStruct) -> () {
bb0(%0 : @owned $BoxStruct):
  br bb1

bb1:
  %2 = integer_literal $Builtin.Int1, 0
  cond_br %2, bb2, bb3

bb2:
  br bb9

bb3:
  %5 = begin_borrow %0 : $BoxStruct
  %6 = struct_extract %5 : $BoxStruct, #BoxStruct.guts
  %7 = integer_literal $Builtin.Int1, 0
  br bb4

bb4:
  %10 = begin_borrow %6 : $Klass
  end_borrow %10 : $Klass
  end_borrow %5 : $BoxStruct
  br bb5

bb5:
  br bb6


bb6:
  %16 = integer_literal $Builtin.Int1, -1
  cond_br %16, bb7, bb8

bb7:
  br bb9

bb8:
  br bb1

bb9:
  destroy_value [dead_end] %0
  unreachable
}

// Ensure no verifier error

sil @foo : $@convention(thin) (@in_guaranteed UInt64, @in_guaranteed UInt64) -> (Bool, @error any Error) 

sil [ossa] @looprotate_ownership_results : $@convention(thin) (Int32, @guaranteed Klass) -> Int32 {
bb0(%0 : $Int32, %1 : @guaranteed $Klass):
  %2 = struct_extract %0, #Int32._value
  %3 = integer_literal $Builtin.Int32, 0
  br bb1(%2, %3)

bb1(%5 : $Builtin.Int32, %6 : $Builtin.Int32):
  %7 = function_ref @foo : $@convention(thin) (@in_guaranteed UInt64, @in_guaranteed UInt64) -> (Bool, @error any Error) 
  %8 = thin_to_thick_function %7 to $@noescape @callee_guaranteed (@in_guaranteed UInt64, @in_guaranteed UInt64) -> (Bool, @error any Error) 
  %9 = convert_function %8 to $@noescape @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error any Error) for <UInt64, UInt64>, forwarding: @owned 
  destroy_value %9
  %11 = struct $Int32 (%6)
  %12 = builtin "cmp_eq_Word"(%6, %2) : $Builtin.Int1
  cond_br %12, bb3, bb2

bb2:
  %14 = integer_literal $Builtin.Int32, 1
  %15 = integer_literal $Builtin.Int1, -1
  %16 = builtin "sadd_with_overflow_Word"(%6, %14, %15) : $(Builtin.Int32, Builtin.Int1)
  %17 = tuple_extract %16, 0
  %18 = enum $Optional<Int32>, #Optional.some!enumelt, %11
  %19 = unchecked_enum_data %18, #Optional.some!enumelt
  %20 = struct_extract %19, #Int32._value
  %21 = integer_literal $Builtin.Int1, -1
  %22 = builtin "sadd_with_overflow_Word"(%5, %20, %21) : $(Builtin.Int32, Builtin.Int1)
  %23 = tuple_extract %22, 0
  br bb1(%23, %17)

bb3:
  %25 = struct $Int32 (%5)
  return %25
}

