// RUN: %target-sil-opt %s -simplification -simplify-instruction=load_borrow | %FileCheck %s

import Swift
import Builtin

class B { }

class E : B {
  @_hasStorage var i: Int
}

struct S {
  let b: B
  let i: Int
}

// CHECK-LABEL: sil [ossa] @load_borrow_and_copy :
// CHECK:         %1 = load [copy] %0
// CHECK:         %2 = begin_borrow %1
// CHECK:         %3 = ref_element_addr %2, #E.i
// CHECK:         %4 = load [trivial] %3
// CHECK:         end_borrow %2
// CHECK:         destroy_value %1 
// CHECK:         return %4
// CHECK:       } // end sil function 'load_borrow_and_copy'
sil [ossa] @load_borrow_and_copy : $@convention(thin) (@inout E) -> Int {
bb0(%0 : $*E):
  %1 = load_borrow %0
  %2 = copy_value %1
  end_borrow %1
  %4 = begin_borrow %2
  %5 = ref_element_addr %4, #E.i
  %6 = load [trivial] %5
  end_borrow %4
  destroy_value %2
  return %6
}

// CHECK-LABEL: sil [ossa] @load_borrow_and_copy_forwarding :
// CHECK:         %1 = load [copy] %0
// CHECK:         %2 = unchecked_ref_cast %1 to $E
// CHECK:         %3 = begin_borrow %2
// CHECK:         %4 = ref_element_addr %3, #E.i
// CHECK:         %5 = load [trivial] %4
// CHECK:         end_borrow %3
// CHECK:         destroy_value %2 
// CHECK:         return %5
// CHECK:       } // end sil function 'load_borrow_and_copy_forwarding'
sil [ossa] @load_borrow_and_copy_forwarding : $@convention(thin) (@inout B) -> Int {
bb0(%0 : $*B):
  %1 = load_borrow %0
  %2 = unchecked_ref_cast %1 to $E
  %3 = copy_value %2
  end_borrow %1
  %5 = begin_borrow %3
  %6 = ref_element_addr %5, #E.i
  %7 = load [trivial] %6
  end_borrow %5
  destroy_value %3
  return %7
}

// CHECK-LABEL: sil [ossa] @load_borrow_and_copy_different_block :
// CHECK:         %1 = load_borrow %0
// CHECK:         %3 = copy_value %1
// CHECK:       } // end sil function 'load_borrow_and_copy_different_block'
sil [ossa] @load_borrow_and_copy_different_block : $@convention(thin) (@inout E) -> () {
bb0(%0 : $*E):
  %1 = load_borrow %0
  cond_br undef, bb1, bb2
bb1:
  %3 = copy_value %1
  %4 = begin_borrow %3
  %5 = ref_element_addr %4, #E.i
  %6 = load [trivial] %5
  fix_lifetime %6
  end_borrow %4
  destroy_value %3
  br bb3
bb2:
  br bb3
bb3:
  end_borrow %1
  %r = tuple ()
  return %r
}

// CHECK-LABEL: sil [ossa] @dead_load_borrow :
// CHECK-NOT:     load_borrow
// CHECK:         %1 = tuple ()
// CHECK:         return %1
// CHECK:       } // end sil function 'dead_load_borrow'
sil [ossa] @dead_load_borrow : $@convention(thin) (@inout B) -> () {
bb0(%0 : $*B):
  %1 = load_borrow %0
  debug_value %1, var, name "x"
  end_borrow %1
  %4 = tuple ()
  return %4
}

// CHECK-LABEL: sil [ossa] @load_of_addr_cast :
// CHECK:         %1 = load_borrow %0
// CHECK:         %2 = unchecked_ref_cast %1 to $AnyObject
// CHECK:         fix_lifetime %2
// CHECK:         end_borrow %1
// CHECK:       } // end sil function 'load_of_addr_cast'
sil [ossa] @load_of_addr_cast : $@convention(thin) (@inout B) -> () {
bb0(%0 : $*B):
  %1 = unchecked_addr_cast %0 to $*AnyObject
  %2 = load_borrow %1
  fix_lifetime %2
  end_borrow %2
  %6 = tuple ()
  return %6
}

// CHECK-LABEL: sil [ossa] @load_of_store_borrow :
// CHECK:       bb1:
// CHECK-NEXT:    %4 = begin_borrow %0
// CHECK-NEXT:    fix_lifetime %4
// CHECK-NEXT:    end_borrow %4
// CHECK:       } // end sil function 'load_of_store_borrow'
sil [ossa] @load_of_store_borrow : $@convention(thin) (@guaranteed B) -> () {
bb0(%0 : @guaranteed $B):
  %1 = alloc_stack $B
  %2 = store_borrow %0 to %1
  cond_br undef, bb1, bb2

bb1:
  %4 = load_borrow %2
  fix_lifetime %4
  end_borrow %4
  br bb3

bb2:
  br bb3

bb3:
  end_borrow %2
  dealloc_stack %1
  %r = tuple ()
  return %r
}

// CHECK-LABEL: sil [ossa] @load_of_store_borrow2 :
// CHECK:       bb1:
// CHECK-NEXT:    %4 = begin_borrow %0
// CHECK-NEXT:    %5 = struct_extract %4, #S.b
// CHECK-NEXT:    fix_lifetime %5
// CHECK-NEXT:    end_borrow %4
// CHECK:       } // end sil function 'load_of_store_borrow2'
sil [ossa] @load_of_store_borrow2 : $@convention(thin) (@owned S) -> @owned S {
bb0(%0 : @owned $S):
  %1 = alloc_stack $S
  %2 = store_borrow %0 to %1
  cond_br undef, bb1, bb2

bb1:
  %4 = struct_element_addr %2, #S.b
  %5 = load_borrow %4
  fix_lifetime %5
  end_borrow %5
  br bb3

bb2:
  br bb3

bb3:
  end_borrow %2
  dealloc_stack %1
  return %0
}

// CHECK-LABEL: sil [ossa] @dont_optimize_load_borrow_with_reborrow :
// CHECK:         %4 = load_borrow %3
// CHECK:       } // end sil function 'dont_optimize_load_borrow_with_reborrow'
sil [ossa] @dont_optimize_load_borrow_with_reborrow : $@convention(thin) (@owned S) -> @owned S {
bb0(%0 : @owned $S):
  %1 = alloc_stack $S
  %2 = store_borrow %0 to %1
  %3 = struct_element_addr %2, #S.b
  %4 = load_borrow %3
  br bb1(%4)

bb1(%5 : @reborrow $B):
  %6 = borrowed %5 from ()
  end_borrow %6
  end_borrow %2
  dealloc_stack %1
  return %0
}

