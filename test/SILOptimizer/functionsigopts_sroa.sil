// RUN: %target-sil-opt -sil-print-types -enable-objc-interop -enable-sil-verify-all -enable-expand-all -inline -function-signature-opts %s | %FileCheck %s

import Builtin

/////////////////////
// Data Structures //
/////////////////////

struct S0 {
  var f : Builtin.Int16
}

struct S1 {
  var f1 : Builtin.Int16
  var f2 : Builtin.Int32
}

sil @i16_user : $@convention(thin) (Builtin.Int16) -> ()
sil @i32_user : $@convention(thin) (Builtin.Int32) -> ()

sil @s1_user : $@convention(thin) (S1) -> ()
sil @s1_ptr_user : $@convention(thin) (@in S1) -> ()

struct S2 {
  var f1 : S1
  var f2 : Builtin.Int64
}

struct S3 {
  var f1 : S2
  var f2 : S1
}

sil @s2_user : $@convention(thin) (S2) -> ()

class C1 {
  var f1 : Builtin.Int32

  init()
  deinit
}

sil @c1_user : $@convention(thin) (C1) -> ()

class C2 {
  var f1 : S3
  var f2 : C1

  init()
  deinit
}

struct S4 {
  var f1 : Builtin.NativeObject
}

sil @s4_user : $@convention(thin) (S4) -> ()
sil @s4_pointer_user : $@convention(thin) (@in S4) -> ()
sil @s4_user_twice : $@convention(thin) (S4, S4) -> ()

struct S4Pair {
  var f1 : S4
  var f2 : S4
}

struct S4Triple {
  var f1 : S4
  var f2 : S4
  var f3 : S4
}

struct S4Octet {
  var f1 : S4
  var f2 : S4
  var f3 : S4
  var f4 : S4
  var f5 : S4
  var f6 : S4
  var f7 : S4
  var f8 : S4
}

struct S4Fourtytet {
  var f1 : S4Octet
  var f2 : S4Octet
  var f3 : S4Octet
  var f4 : S4Octet
  var f5 : S4Octet
}

struct S5 {
  var f1 : S4
  var f2 : S1
}

sil @s5_user : $@convention(thin) (S5) -> ()

struct S6 {
  var f1 : S1
  var f2 : S1
  var f3 : (Builtin.Int32, Builtin.Int16, S1)
}

struct FakeStaticString {
  var f1 : Builtin.RawPointer
  var f2 : Builtin.Word
  var f3 : Builtin.Word
}

sil @fakestaticstring_user : $@convention(thin) (FakeStaticString) -> ()

@objc protocol FakeAnyObject {}
struct FakeOpaquePointer {
  var rawValue : Builtin.RawPointer
}
enum FakeOptional<T> {
  case none
  case some(T)
}
struct FakeUWord {
  var value: Builtin.Word
}

struct FakeStringCore {
  var baseAddress : FakeOpaquePointer
  var countAndFlags : FakeUWord
  var owner : FakeOptional<FakeAnyObject>
}

struct FakeString {
  var core : FakeStringCore
}
sil @fakestring_user : $@convention(thin) (FakeString) -> ()

sil @tuple_user : $@convention(thin) ((Builtin.Int32, Builtin.Int16, S1)) ->  ()

struct EightFieldStruct {
  var a1 : Builtin.Int32
  var a2 : Builtin.Int32
  var a3 : Builtin.Int32
  var a4 : Builtin.Int32
  var a5 : Builtin.Int32
  var a6 : Builtin.Int32
  var a7 : Builtin.Int32
  var a8 : Builtin.Int32
}

struct ThirtySixFieldStruct {
  var b1 : EightFieldStruct
  var b2 : EightFieldStruct
  var b3 : EightFieldStruct
  var b4 : EightFieldStruct
  var b5 : EightFieldStruct
}

struct SingleFieldLvl1 {
  var s2: SingleFieldLvl2
}
struct SingleFieldLvl2 {
  var s3: SingleFieldLvl3
}
struct SingleFieldLvl3 {
  var s4: Builtin.Int16
}


///////////
// Tests //
///////////

/// Verify that an argument is not exploded if it is entirely trivial even if it
/// is partly dead.
// CHECK-LABEL: sil [serialized] @single_level_dead_root_callee : $@convention(thin) (S1) -> Builtin.Int32 {
// CHECK: bb0([[INPUT:%[0-9]+]] : $S1):
// CHECK: [[RESULT:%.*]] = struct_extract [[INPUT]] : $S1, #S1.f2
// CHECK: return [[RESULT]] : $Builtin.Int32
sil [serialized] @single_level_dead_root_callee : $@convention(thin) (S1) -> Builtin.Int32 {
bb0(%0 : $S1):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %1 = struct_extract %0 : $S1, #S1.f2
  return %1 : $Builtin.Int32
}

// CHECK-LABEL: sil [serialized] @single_level_dead_root_caller : $@convention(thin) (S1) -> () {
// CHECK: bb0([[INPUT:%[0-9]+]] : $S1):
// CHECK: [[FN:%[0-9]+]] = function_ref @single_level_dead_root_callee
// CHECK: apply [[FN]]([[INPUT]])
// CHECK-LABEL: } // end sil function 'single_level_dead_root_caller'
sil [serialized] @single_level_dead_root_caller : $@convention(thin) (S1) -> () {
bb0(%0 : $S1):
  %1 = function_ref @single_level_dead_root_callee : $@convention(thin) (S1) -> Builtin.Int32
  %2 = apply %1(%0) : $@convention(thin) (S1) -> Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that fully live trivial arguments are not exploded.
// CHECK-LABEL: sil [serialized] @single_level_live_root_callee : $@convention(thin) (S1) -> Builtin.Int32 {
// CHECK: bb0([[INPUT:%[0-9]+]] : $S1):
// CHECK: [[RESULT:%.*]] = struct_extract [[INPUT]] : $S1, #S1.f2
// CHECK: [[FN:%.*]] = function_ref @s1_user : $@convention(thin) (S1) -> ()
// CHECK: apply [[FN]]([[INPUT]])
// CHECK: return [[RESULT]]
// CHECK-LABEL: } // end sil function 'single_level_live_root_callee'
sil [serialized] @single_level_live_root_callee : $@convention(thin) (S1) -> Builtin.Int32 {
bb0(%0 : $S1):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %1 = struct_extract %0 : $S1, #S1.f2
  %2 = function_ref @s1_user : $@convention(thin) (S1) -> ()
  apply %2(%0) : $@convention(thin) (S1) -> ()
  return %1 : $Builtin.Int32
}

// CHECK-LABEL: sil [serialized] @single_level_live_root_caller : $@convention(thin) (S1) -> () {
// CHECK: bb0([[INPUT:%[0-9]+]] : $S1):
// CHECK: [[FN:%[0-9]+]] = function_ref @single_level_live_root_callee
// CHECK: apply [[FN]]([[INPUT]])
// CHECK-LABEL: } // end sil function 'single_level_live_root_caller'
sil [serialized] @single_level_live_root_caller : $@convention(thin) (S1) -> () {
bb0(%0 : $S1):
  %1 = function_ref @single_level_live_root_callee : $@convention(thin) (S1) -> Builtin.Int32
  %2 = apply %1(%0) : $@convention(thin) (S1) -> Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that a two-level aggregate argument which is entirely trivial, whose 
/// root is dead but all of whose leaves are live will not be exploded.
// CHECK-LABEL: sil [serialized] @multiple_level_all_root_fields_used_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64) {
// CHECK: bb0([[INPUT:%.*]] : $S2):
// CHECK: [[INPUTF1:%.*]] = struct_extract [[INPUT]] : $S2, #S2.f1
// CHECK: [[INPUTF1F1:%.*]] = struct_extract [[INPUTF1]] : $S1, #S1.f1
// CHECK: [[INPUTF2:%.*]] = struct_extract [[INPUT]] : $S2, #S2.f2
// CHECK: [[OUT:%.*]] = tuple ([[INPUTF1F1]] : $Builtin.Int16, [[INPUTF2]] : $Builtin.Int64)
// CHECK: return [[OUT]]
// CHECK-LABEL: } // end sil function 'multiple_level_all_root_fields_used_callee'
sil [serialized] @multiple_level_all_root_fields_used_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64) {
bb0(%0 : $S2):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  debug_value %0 : $S2 // debug_value should not prevent function signature optimization
  %1 = struct_extract %0 : $S2, #S2.f1
  debug_value %1 : $S1 // debug_value should not prevent function signature optimization
  %2 = struct_extract %1 : $S1, #S1.f1
  %3 = struct_extract %0 : $S2, #S2.f2
  %4 = tuple(%2 : $Builtin.Int16, %3 : $Builtin.Int64)
  return %4 : $(Builtin.Int16, Builtin.Int64)
}

// CHECK-LABEL: sil [serialized] @multiple_level_all_root_fields_used_caller : $@convention(thin) (S2) -> () {
// CHECK: bb0([[INPUT:%.*]] : $S2):
// CHECK: [[FN:%.*]] = function_ref @multiple_level_all_root_fields_used_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64)
// CHECK: apply [[FN]]([[INPUT]])
// CHECK-LABEL: } // end sil function 'multiple_level_all_root_fields_used_caller'
sil [serialized] @multiple_level_all_root_fields_used_caller : $@convention(thin) (S2) -> () {
bb0(%0 : $S2):
  %1 = function_ref @multiple_level_all_root_fields_used_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64)
  %2 = apply %1(%0) : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64)
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that a three-level aggregate argument which is entirely trivial, 
/// whose first level nodes are dead but some of whose leaves are live will not
/// be exploded.
// CHECK-LABEL: sil [serialized] @multiple_level_no_root_fields_have_direct_uses_callee : $@convention(thin) (S3) -> (Builtin.Int16, Builtin.Int64) {
// CHECK: bb0([[INPUT:%.*]] : $S3):
// CHECK: [[INPUTF1:%.*]] = struct_extract [[INPUT]] : $S3, #S3.f1
// CHECK: [[INPUTF1F1:%.*]] = struct_extract [[INPUTF1]] : $S2, #S2.f1
// CHECK: [[INPUTF1F1F1:%.*]] = struct_extract [[INPUTF1F1]] : $S1, #S1.f1
// CHECK: [[INPUTF1F2:%.*]] = struct_extract [[INPUTF1]] : $S2, #S2.f2
// CHECK: [[RESULT:%.*]] = tuple ([[INPUTF1F1F1]] : $Builtin.Int16, [[INPUTF1F2]] : $Builtin.Int64)
// CHECK-LABEL: } // end sil function 'multiple_level_no_root_fields_have_direct_uses_callee'
sil [serialized] @multiple_level_no_root_fields_have_direct_uses_callee : $@convention(thin) (S3) -> (Builtin.Int16, Builtin.Int64) {
bb0(%0 : $S3):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  debug_value %0 : $S3
  %1 = struct_extract %0 : $S3, #S3.f1
  %2 = struct_extract %1 : $S2, #S2.f1
  %3 = struct_extract %2 : $S1, #S1.f1
  %4 = struct_extract %1 : $S2, #S2.f2
  %5 = tuple(%3 : $Builtin.Int16, %4 : $Builtin.Int64)
  return %5 : $(Builtin.Int16, Builtin.Int64)
}

// CHECK-LABEL: sil [serialized] @multiple_level_no_root_fields_have_direct_uses_caller : $@convention(thin) (S3) -> () {
// CHECK: bb0([[INPUT:%.*]] : $S3):
// CHECK: [[FUNCTION:%.*]] = function_ref @multiple_level_no_root_fields_have_direct_uses_callee : $@convention(thin) (S3) -> (Builtin.Int16, Builtin.Int64)
// CHECK: apply [[FUNCTION]]([[INPUT]])
// CHECK-LABEL: } // end sil function 'multiple_level_no_root_fields_have_direct_uses_caller'
sil [serialized] @multiple_level_no_root_fields_have_direct_uses_caller : $@convention(thin) (S3) -> () {
bb0(%0 : $S3):
  %1 = function_ref @multiple_level_no_root_fields_have_direct_uses_callee : $@convention(thin) (S3) -> (Builtin.Int16, Builtin.Int64)
  %2 = apply %1(%0) : $@convention(thin) (S3) -> (Builtin.Int16, Builtin.Int64)
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that a two-level aggregate argument which is entirely trivial, some
/// of whose leaves are live and which itself is live will not be exploded.
// CHECK-LABEL: sil [serialized] @multiple_level_root_must_be_reformed_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64) {
// CHECK: bb0([[INPUT:%.*]] : $S2):
// CHECK: [[INPUTF1:%.*]] = struct_extract [[INPUT]] : $S2, #S2.f1
// CHECK: [[INPUTF1F1:%.*]] = struct_extract [[INPUTF1]] : $S1, #S1.f1
// CHECK: [[INPUTF2:%.*]] = struct_extract [[INPUT]] : $S2, #S2.f2
// CHECK: [[OUT:%.*]] = tuple ([[INPUTF1F1]] : $Builtin.Int16, [[INPUTF2]] : $Builtin.Int64)
// CHECK: [[FN:%.*]] = function_ref @s2_user : $@convention(thin) (S2) -> ()
// CHECK: apply [[FN]]([[INPUT]]) : $@convention(thin) (S2) -> ()
// CHECK-LABEL: } // end sil function 'multiple_level_root_must_be_reformed_callee'
sil [serialized] @multiple_level_root_must_be_reformed_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64) {
bb0(%0 : $S2):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %2 = struct_extract %0 : $S2, #S2.f1
  %3 = struct_extract %2 : $S1, #S1.f1
  %4 = struct_extract %0 : $S2, #S2.f2
  %5 = tuple(%3 : $Builtin.Int16, %4 : $Builtin.Int64)
  %6 = function_ref @s2_user : $@convention(thin) (S2) -> ()
  apply %6(%0) : $@convention(thin) (S2) -> ()
  return %5 : $(Builtin.Int16, Builtin.Int64)
}

// CHECK-LABEL: sil [serialized] @multiple_level_root_must_be_reformed_caller : $@convention(thin) (S2) -> () {
// CHECK: bb0([[INPUT:%.*]] : $S2):
// CHECK: [[FUNCTION:%.*]] = function_ref @multiple_level_root_must_be_reformed_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64)
// CHECK: apply [[FUNCTION]]([[INPUT]])
// CHECK-LABEL: } // end sil function 'multiple_level_root_must_be_reformed_caller'
sil [serialized] @multiple_level_root_must_be_reformed_caller : $@convention(thin) (S2) -> () {
bb0(%0 : $S2):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %1 = function_ref @multiple_level_root_must_be_reformed_callee : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64)
  %2 = apply %1(%0) : $@convention(thin) (S2) -> (Builtin.Int16, Builtin.Int64)
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that an aggregate argument containing a single non-trivial live leaf
/// is not exploded.
// CHECK-LABEL: sil [serialized] [signature_optimized_thunk] [always_inline] @owned_struct_1_callee : $@convention(thin) (@owned S5, @owned S5) -> (Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32) {
// CHECK: bb0({{%.*}} : $S5, [[INPUT:%.*]] : $S5):
// CHECK: [[FUNCTION:%.*]] = function_ref @$s21owned_struct_1_calleeTfq4dg_n : $@convention(thin) (@guaranteed S5) -> (Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32)
// CHECK: [[RESULT:%.*]] = apply [[FUNCTION]]([[INPUT]])
// CHECK: release_value [[INPUT]] : $S5
// CHECK: release_value {{%.*}} : $S5
// CHECK: return [[RESULT]]
// CHECK-LABEL: } // end sil function 'owned_struct_1_callee'
sil [serialized] @owned_struct_1_callee : $@convention(thin) (@owned S5, @owned S5) -> (Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32) {
bb0(%0 : $S5, %1 : $S5):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %2 = struct_extract %0 : $S5, #S5.f2
  %3 = struct_extract %2 : $S1, #S1.f1
  %4 = struct_extract %2 : $S1, #S1.f2
  %5 = struct_extract %1 : $S5, #S5.f2
  %6 = struct_extract %5 : $S1, #S1.f1
  %7 = struct_extract %5 : $S1, #S1.f2
  release_value %1 : $S5
  release_value %0 : $S5
  release_value %1 : $S5
  %8 = tuple(%6 : $Builtin.Int16, %7 : $Builtin.Int32, %6 : $Builtin.Int16, %7 : $Builtin.Int32)
  return %8 : $(Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32)
}

// CHECK-LABEL: sil [serialized] @owned_struct_1_caller : $@convention(thin) (S5) -> () {
// CHECK: bb0([[INPUT:%.*]] : $S5):
// CHECK: [[INPUTF2:%.*]] = struct_extract [[INPUT]] : $S5, #S5.f2
// CHECK: [[INPUTF2F1:%.*]] = struct_extract [[INPUTF2]] : $S1, #S1.f1
// CHECK: [[INPUTF2F2:%.*]] = struct_extract [[INPUTF2]] : $S1, #S1.f2
// CHECK: [[OUT:%.*]] = tuple ([[INPUTF2F1]] : $Builtin.Int16, [[INPUTF2F2]] : $Builtin.Int32, [[INPUTF2F1]] : $Builtin.Int16, [[INPUTF2F2]] : $Builtin.Int32)
// CHECK-LABEL: } // end sil function 'owned_struct_1_caller'
sil [serialized] @owned_struct_1_caller : $@convention(thin) (S5) -> () {
bb0(%0 : $S5):
  %1 = function_ref @owned_struct_1_callee : $@convention(thin) (@owned S5, @owned S5) -> (Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32)
  %2 = apply %1(%0, %0) : $@convention(thin) (@owned S5, @owned S5) -> (Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32)
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that argument explosion that increases argument count before and
/// after dead argument elimination behaves properly.
// CHECK-LABEL: sil [serialized] [signature_optimized_thunk] [always_inline] @owned_struct_2_callee : $@convention(thin) (Builtin.Int256, Builtin.Int256, @owned S4Triple, Builtin.Int128, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128) {
// CHECK: bb0([[IN1:%.*]] : $Builtin.Int256, [[IN2:%.*]] : $Builtin.Int256, [[TRIPLE:%.*]] : $S4Triple, [[IN4:%.*]] : $Builtin.Int128, [[IN5:%.*]] : $Builtin.Int128):
// CHECK: [[FN:%.*]] = function_ref @$s21owned_struct_2_calleeTfq4ndgXdn_n : $@convention(thin) (Builtin.Int256, @guaranteed S4, @guaranteed S4, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
// CHECK: [[TRIPLEF3:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f3
// CHECK: [[TRIPLEF2:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f2
// CHECK: [[RESULT:%.*]] = apply [[FN]]([[IN1]], [[TRIPLEF2]], [[TRIPLEF3]], [[IN5]]) : $@convention(thin) (Builtin.Int256, @guaranteed S4, @guaranteed S4, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
// CHECK: release_value [[TRIPLE]] : $S4Triple
// CHECK: return [[RESULT]]
// CHECK-LABEL: } // end sil function 'owned_struct_2_callee'
sil [serialized] @owned_struct_2_callee : $@convention(thin) (Builtin.Int256, Builtin.Int256, @owned S4Triple, Builtin.Int128, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128) {
bb0(%0 : $Builtin.Int256, %1 : $Builtin.Int256, %triple : $S4Triple, %3 : $Builtin.Int128, %4 : $Builtin.Int128):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %triple_field2 = struct_extract %triple : $S4Triple, #S4Triple.f2
  %triple_field3 = struct_extract %triple : $S4Triple, #S4Triple.f3
  %func = function_ref @s4_user_twice : $@convention(thin) (S4, S4) -> ()
  %_ = apply %func(%triple_field2, %triple_field3) : $@convention(thin) (S4, S4) -> ()
  release_value %triple : $S4Triple
  %result = tuple (%0 : $Builtin.Int256, %0 : $Builtin.Int256, %4 : $Builtin.Int128, %4 : $Builtin.Int128)
  return %result : $(Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
}


// CHECK-LABEL: sil [serialized] @owned_struct_2_caller : $@convention(thin) (Builtin.Int256, S4Triple, Builtin.Int128) -> () {
// CHECK: bb0([[IN1:%.*]] : $Builtin.Int256, [[TRIPLE:%.*]] : $S4Triple, [[IN3:%.*]] : $Builtin.Int128):
// CHECK: [[FN:%.*]] = function_ref @$s21owned_struct_2_calleeTfq4ndgXdn_n : $@convention(thin) (Builtin.Int256, @guaranteed S4, @guaranteed S4, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
// CHECK: [[TRIPLEF3:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f3
// CHECK: [[TRIPLEF2:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f2
// CHECK: apply [[FN]]([[IN1]], [[TRIPLEF2]], [[TRIPLEF3]], [[IN3]]) : $@convention(thin) (Builtin.Int256, @guaranteed S4, @guaranteed S4, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
// CHECK-LABEL: } // end sil function 'owned_struct_2_caller'
sil [serialized] @owned_struct_2_caller : $@convention(thin) (Builtin.Int256, S4Triple, Builtin.Int128) -> () {
bb0(%0 : $Builtin.Int256, %1 : $S4Triple, %2 : $Builtin.Int128):
  %3 = function_ref @owned_struct_2_callee : $@convention(thin) (Builtin.Int256, Builtin.Int256, @owned S4Triple, Builtin.Int128, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
  %4 = apply %3(%0, %0, %1, %2, %2) : $@convention(thin) (Builtin.Int256, Builtin.Int256, @owned S4Triple, Builtin.Int128, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that pointer arguments are ignored for now.
// CHECK-LABEL: sil [serialized] [signature_optimized_thunk] [always_inline] @ignore_ptrs_callee : $@convention(thin) (@in S4Pair, S4Pair, S4Pair) -> (S4, S4) {
// CHECK: bb0([[POINTER:%.*]] : $*S4Pair, [[PAIR1:%.*]] : $S4Pair, [[PAIR2:%.*]] : $S4Pair):
// CHECK: [[FN:%.*]] = function_ref @$s18ignore_ptrs_calleeTfq4nxx_n : $@convention(thin) (@in S4Pair, S4, S4) -> (S4, S4)
// CHECK: [[VALUE1:%.*]] = struct_extract [[PAIR1]] : $S4Pair, #S4Pair.f1
// CHECK: [[VALUE2:%.*]] = struct_extract [[PAIR2]] : $S4Pair, #S4Pair.f1
// CHECK: [[RESULT:%.*]] = apply [[FN]]([[POINTER]], [[VALUE1]], [[VALUE2]]) : $@convention(thin) (@in S4Pair, S4, S4) -> (S4, S4)
// CHECK: return [[RESULT]]
// CHECK-LABEL: } // end sil function 'ignore_ptrs_callee'
sil [serialized] @ignore_ptrs_callee : $@convention(thin) (@in S4Pair, S4Pair, S4Pair) -> (S4, S4) {
bb0(%pointer : $*S4Pair, %pair1 : $S4Pair, %pair2 : $S4Pair):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %func = function_ref @s4_user : $@convention(thin) (S4) -> ()
  %pointee = load %pointer : $*S4Pair
  %first_pointee = struct_extract %pointee : $S4Pair, #S4Pair.f1
  %_ = apply %func(%first_pointee) : $@convention(thin) (S4) -> ()
  %first1 = struct_extract %pair1 : $S4Pair, #S4Pair.f1
  %first2 = struct_extract %pair2 : $S4Pair, #S4Pair.f1
  %result = tuple (%first1 : $S4, %first2 : $S4)
  return %result : $(S4, S4)
}

// CHECK-LABEL: sil [serialized] @ignore_ptrs_caller : $@convention(thin) (@in S4Pair, S4Pair, S4Pair) -> () {
// CHECK: bb0([[POINTER:%.*]] : $*S4Pair, [[PAIR1:%.*]] : $S4Pair, [[PAIR2:%.*]] : $S4Pair):
// CHECK: [[FN:%.*]] = function_ref @$s18ignore_ptrs_calleeTfq4nxx_n : $@convention(thin) (@in S4Pair, S4, S4) -> (S4, S4)
// CHECK: [[VALUE1:%.*]] = struct_extract [[PAIR1]] : $S4Pair, #S4Pair.f1
// CHECK: [[VALUE2:%.*]] = struct_extract [[PAIR2]] : $S4Pair, #S4Pair.f1
// CHECK: apply [[FN]]([[POINTER]], [[VALUE1]], [[VALUE2]]) : $@convention(thin) (@in S4Pair, S4, S4) -> (S4, S4)
// CHECK-LABEL: } // end sil function 'ignore_ptrs_caller'
sil [serialized] @ignore_ptrs_caller : $@convention(thin) (@in S4Pair, S4Pair, S4Pair) -> () {
bb0(%0 : $*S4Pair, %1 : $S4Pair, %2 : $S4Pair):
  %3 = function_ref @ignore_ptrs_callee : $@convention(thin) (@in S4Pair, S4Pair, S4Pair) -> (S4, S4)
  %4 = apply %3(%0, %1, %2) : $@convention(thin) (@in S4Pair, S4Pair, S4Pair) -> (S4, S4)
  %9999 = tuple()
  return %9999 : $()
}

// This test makes sure that we can handle multiple SROA arguments.
// CHECK-LABEL: sil [serialized] @multiple_sroa_callee : $@convention(thin) (FakeStaticString, @owned FakeString, FakeStaticString) -> () {
// CHECK: bb0([[IN1:%.*]] : $FakeStaticString, [[IN2:%.*]] : $FakeString, [[IN3:%.*]] : $FakeStaticString):
// CHECK: [[FN:%.*]] = function_ref @fakestaticstring_user : $@convention(thin) (FakeStaticString) -> ()
// CHECK: apply [[FN]]([[IN1]]) : $@convention(thin) (FakeStaticString) -> ()
// CHECK-LABEL: } // end sil function 'multiple_sroa_callee'
sil [serialized] @multiple_sroa_callee : $@convention(thin) (FakeStaticString, @owned FakeString, FakeStaticString) -> () {
bb0(%0 : $FakeStaticString, %1 : $FakeString, %2 : $FakeStaticString):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %3 = function_ref @fakestaticstring_user : $@convention(thin) (FakeStaticString) -> ()
  %4 = function_ref @fakestring_user : $@convention(thin) (FakeString) -> ()
  apply %3(%0) : $@convention(thin) (FakeStaticString) -> ()
  apply %4(%1) : $@convention(thin) (FakeString) -> ()
  apply %3(%2) : $@convention(thin) (FakeStaticString) -> ()
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [serialized] @multiple_sroa_caller : $@convention(thin) (FakeStaticString, @owned FakeString, FakeStaticString) -> () {
// CHECK: bb0([[IN1:%.*]] : $FakeStaticString, [[IN2:%.*]] : $FakeString, [[IN3:%.*]] : $FakeStaticString):
// CHECK: [[FN:%.*]] = function_ref @multiple_sroa_callee : $@convention(thin) (FakeStaticString, @owned FakeString, FakeStaticString) -> ()
// CHECK-LABEL: } // end sil function 'multiple_sroa_caller'
sil [serialized] @multiple_sroa_caller : $@convention(thin) (FakeStaticString, @owned FakeString, FakeStaticString) -> () {
bb0(%0 : $FakeStaticString, %1 : $FakeString, %2 : $FakeStaticString):
  %3 = function_ref @multiple_sroa_callee : $@convention(thin) (FakeStaticString, @owned FakeString, FakeStaticString) -> ()
  %4 = apply %3(%0, %1, %2) : $@convention(thin) (FakeStaticString, @owned FakeString, FakeStaticString) -> ()
  %9999 = tuple()
  return %9999 : $()
}

/// Verify that in the face of an exploded argument the ordering of arguments is
/// based on ordering of fields in the original argument rather than ordering of
/// usage in the function being specialized.
// CHECK-LABEL: sil [serialized] [signature_optimized_thunk] [always_inline] @check_out_of_order_uses_callee : $@convention(thin) (S4Triple) -> () {
// CHECK: bb0([[TRIPLE:%.*]] : $S4Triple):
// CHECK: [[FUNCTION:%.*]] = function_ref @$s30check_out_of_order_uses_calleeTfq4x_n : $@convention(thin) (S4, S4) -> ()
// CHECK: [[INPUT1F2:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f2
// CHECK: [[INPUT1F1:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f1
// CHECK: apply [[FUNCTION]]([[INPUT1F1]], [[INPUT1F2]]) : $@convention(thin) (S4, S4) -> ()
// CHECK-LABEL: } // end sil function 'check_out_of_order_uses_callee'
sil [serialized] @check_out_of_order_uses_callee : $@convention(thin) (S4Triple) -> () {
only(%triple : $S4Triple):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %second = struct_extract %triple : $S4Triple, #S4Triple.f2
  %func = function_ref @s4_user : $@convention(thin) (S4) -> ()
  apply %func(%second) : $@convention(thin) (S4) -> ()
  %first = struct_extract %triple : $S4Triple, #S4Triple.f1
  apply %func(%first) : $@convention(thin) (S4) -> ()
  %result = tuple()
  return %result : $()
}

// CHECK-LABEL: sil [serialized] @check_out_of_order_uses_caller : $@convention(thin) (S4Triple) -> () {
// CHECK: bb0([[TRIPLE:%.*]] : $S4Triple):
// CHECK: [[FUNCTION:%.*]] = function_ref @$s30check_out_of_order_uses_calleeTfq4x_n : $@convention(thin) (S4, S4) -> ()
// CHECK: [[TRIPLEF2:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f2
// CHECK: [[TRIPLEF1:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f1
// CHECK: [[RESULT:%.*]] = apply [[FUNCTION]]([[TRIPLEF1]], [[TRIPLEF2]]) : $@convention(thin) (S4, S4) -> ()
// CHECK: return [[RESULT]] : $()
// CHECK-LABEL: } // end sil function 'check_out_of_order_uses_caller'
sil [serialized] @check_out_of_order_uses_caller : $@convention(thin) (S4Triple) -> () {
bb0(%0 : $S4Triple):
  %1 = function_ref @check_out_of_order_uses_callee : $@convention(thin) (S4Triple) -> ()
  %result = apply %1(%0) : $@convention(thin) (S4Triple) -> ()
  return %result : $()
}

// Make sure that we do not SROA classes.
// CHECK-LABEL: sil [serialized] [signature_optimized_thunk] [always_inline] @class_callee_1 : $@convention(thin) (@owned C1, Builtin.Int32) -> Builtin.Int32 {
// CHECK: bb0([[IN1:%.*]] : $C1, [[IN2:%.*]] : $Builtin.Int32):
// CHECK: [[FN:%.*]] = function_ref @$s14class_callee_1Tfq4gn_n : $@convention(thin) (@guaranteed C1, Builtin.Int32) -> Builtin.Int32
// CHECK: apply [[FN]]([[IN1]], [[IN2]]) : $@convention(thin) (@guaranteed C1, Builtin.Int32) -> Builtin.Int32
// CHECK: release_value [[IN1]]
sil [serialized] @class_callee_1 : $@convention(thin) (@owned C1, Builtin.Int32) -> Builtin.Int32 {
bb0(%0 : $C1, %1 : $Builtin.Int32):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  // This use is needed so that we do not perform dead arg + owned -> guaranteed.
  strong_retain %0 : $C1
  %2 = function_ref @c1_user : $@convention(thin) (C1) -> ()
  apply %2(%0) : $@convention(thin) (C1) -> ()
  strong_release %0 : $C1
  return %1 : $Builtin.Int32
}

// CHECK-LABEL: sil [serialized] [signature_optimized_thunk] [always_inline] @class_caller_1 : $@convention(thin) (@owned C1, Builtin.Int32) -> Builtin.Int32 {
// CHECK: bb0([[IN1:%.*]] : $C1, [[IN2:%.*]] : $Builtin.Int32):
// CHECK: [[FN:%.*]] = function_ref @$s14class_callee_1Tfq4gn_n : $@convention(thin) (@guaranteed C1, Builtin.Int32) -> Builtin.Int32
// CHECK: apply [[FN]]([[IN1]], [[IN2]]) : $@convention(thin) (@guaranteed C1, Builtin.Int32) -> Builtin.Int32
// CHECK: release_value [[IN1]]
sil [serialized] @class_caller_1 : $@convention(thin) (@owned C1, Builtin.Int32) -> Builtin.Int32 {
bb0(%0 : $C1, %1 : $Builtin.Int32):
  %2 = function_ref @class_callee_1 : $@convention(thin) (@owned C1, Builtin.Int32) -> Builtin.Int32
  %3 = apply %2(%0, %1) : $@convention(thin) (@owned C1, Builtin.Int32) -> Builtin.Int32
  return %3 : $Builtin.Int32
}

// Make sure we don't clone this despite the projection tree able to
// explode S0 if it was a loadable value.
// CHECK-LABEL: sil [serialized] @inarg_callee : $@convention(thin) (@in S1) -> () {
// CHECK: bb0([[IN:%.*]] : $*S1):
// CHECK: function_ref s1_ptr_user
// CHECK: [[FN:%.*]] = function_ref @s1_ptr_user : $@convention(thin) (@in S1) -> ()
// CHECK: apply [[FN]]
// CHECK: tuple
// CHECK: return
sil [serialized] @inarg_callee : $@convention(thin) (@in S1) -> () {
bb0(%0 : $*S1):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %1 = function_ref @s1_ptr_user : $@convention(thin) (@in S1) -> ()
	%2 = apply %1(%0) : $@convention(thin) (@in S1) -> ()
	%9999 = tuple()
	return %9999 : $()
}

// CHECK-LABEL: sil [serialized] @inarg_caller : $@convention(thin) (@in S1) -> () {
// CHECK: bb0([[IN:%.*]] : $*S1):
// CHECK-NEXT: function_ref inarg_callee
// CHECK-NEXT: [[FN:%.*]] = function_ref @inarg_callee : $@convention(thin) (@in S1) -> ()
// CHECK-NEXT: apply [[FN]]
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK-LABEL: } // end sil function 'inarg_caller'
sil [serialized] @inarg_caller : $@convention(thin) (@in S1) -> () {
bb0(%0 : $*S1):
  %1 = function_ref @inarg_callee : $@convention(thin) (@in S1) -> ()
	%2 = apply %1(%0) : $@convention(thin) (@in S1) -> ()
	%9999 = tuple()
	return %9999 : $()
}

// This test makes sure we can handle functions with more than 32 fields
// (including each subtype's field in that count). This fixes a bug where we
// were not handling the possibility of an std::vector resize invalidated
// references. This cause the this pointer to become invalidated and other
// shenanigans. So just make sure we don't crash
// CHECK-LABEL: sil [serialized] @more_than_32_type_sized_caller : $@convention(thin) (S4Fourtytet) -> S4 {
// CHECK-LABEL: } // end sil function 'more_than_32_type_sized_caller'
sil [serialized] @more_than_32_type_sized_caller : $@convention(thin) (S4Fourtytet) -> S4 {
only(%tet : $S4Fourtytet):
  %func = function_ref @more_than_32_type_sized_callee : $@convention(thin) (S4Fourtytet) -> S4
  %result = apply %func(%tet) : $@convention(thin) (S4Fourtytet) -> S4
  return %result : $S4
}

// CHECK-LABEL: sil [serialized] [signature_optimized_thunk] [always_inline] @more_than_32_type_sized_callee : $@convention(thin) (S4Fourtytet) -> S4 {
// CHECK-LABEL: } // end sil function 'more_than_32_type_sized_callee'
sil [serialized] @more_than_32_type_sized_callee : $@convention(thin) (S4Fourtytet) -> S4 {
bb0(%tet : $S4Fourtytet):
  // make it a non-trivial function
  %c1 = builtin "assert_configuration"() : $Builtin.Int32
  %c2 = builtin "assert_configuration"() : $Builtin.Int32
  %c3 = builtin "assert_configuration"() : $Builtin.Int32
  %c4 = builtin "assert_configuration"() : $Builtin.Int32
  %c5 = builtin "assert_configuration"() : $Builtin.Int32
  %c6 = builtin "assert_configuration"() : $Builtin.Int32
  %c7 = builtin "assert_configuration"() : $Builtin.Int32
  %c8 = builtin "assert_configuration"() : $Builtin.Int32
  %c9 = builtin "assert_configuration"() : $Builtin.Int32
  %c10 = builtin "assert_configuration"() : $Builtin.Int32
  %c11 = builtin "assert_configuration"() : $Builtin.Int32
  %c12 = builtin "assert_configuration"() : $Builtin.Int32
  %c13 = builtin "assert_configuration"() : $Builtin.Int32
  %c14 = builtin "assert_configuration"() : $Builtin.Int32
  %c15 = builtin "assert_configuration"() : $Builtin.Int32
  %c16 = builtin "assert_configuration"() : $Builtin.Int32
  %c17 = builtin "assert_configuration"() : $Builtin.Int32
  %c18 = builtin "assert_configuration"() : $Builtin.Int32
  %c19 = builtin "assert_configuration"() : $Builtin.Int32
  %c20 = builtin "assert_configuration"() : $Builtin.Int32
  %c21 = builtin "assert_configuration"() : $Builtin.Int32
  %c22 = builtin "assert_configuration"() : $Builtin.Int32

  %octet = struct_extract %tet : $S4Fourtytet, #S4Fourtytet.f1
  %result = struct_extract %octet : $S4Octet, #S4Octet.f1
  return %result : $S4
}

// We should not specialize this since SingleFieldLvl1 is a struct that is layout compatible with its only leaf node, %0.s2.s3.s4
// CHECK-LABEL: sil [serialized] @multiple_level_all_single_field_struct_callee : $@convention(thin) (SingleFieldLvl1) -> Builtin.Int16 {
sil [serialized] @multiple_level_all_single_field_struct_callee : $@convention(thin) (SingleFieldLvl1) -> Builtin.Int16 {
bb0(%0 : $SingleFieldLvl1):
  %1 = struct_extract %0 : $SingleFieldLvl1, #SingleFieldLvl1.s2
  %2 = struct_extract %1 : $SingleFieldLvl2, #SingleFieldLvl2.s3
  %3 = struct_extract %2 : $SingleFieldLvl3, #SingleFieldLvl3.s4
  return %3 : $Builtin.Int16
}

// CHECK-LABEL: sil [serialized] @multiple_level_all_single_field_struct_caller : $@convention(thin) (SingleFieldLvl1) -> Builtin.Int16 {
sil [serialized] @multiple_level_all_single_field_struct_caller : $@convention(thin) (SingleFieldLvl1) -> Builtin.Int16 {
bb0(%0 : $SingleFieldLvl1):
  %1 = function_ref @multiple_level_all_single_field_struct_callee : $@convention(thin) (SingleFieldLvl1) -> Builtin.Int16
  %2 = apply %1(%0) : $@convention(thin) (SingleFieldLvl1) -> Builtin.Int16
  return %2 : $Builtin.Int16
}

// Check Statements for generated code.



// CHECK-LABEL: sil shared [serialized] @$s21owned_struct_1_calleeTfq4dg_n : $@convention(thin) (@guaranteed S5) -> (Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32) {
// CHECK: bb0([[INPUT:%.*]] : $S5):
// CHECK: [[INPUTF2:%.*]] = struct_extract [[INPUT]] : $S5, #S5.f2
// CHECK: [[INPUTF2F1:%.*]] = struct_extract [[INPUTF2]] : $S1, #S1.f1
// CHECK: [[INPUTF2F2:%.*]] = struct_extract [[INPUTF2]] : $S1, #S1.f2
// CHECK: [[OUT:%.*]] = tuple ([[INPUTF2F1]] : $Builtin.Int16, [[INPUTF2F2]] : $Builtin.Int32, [[INPUTF2F1]] : $Builtin.Int16, [[INPUTF2F2]] : $Builtin.Int32)
// CHECK: return [[OUT]] : $(Builtin.Int16, Builtin.Int32, Builtin.Int16, Builtin.Int32)
// CHECK-LABEL: } // end sil function '$s21owned_struct_1_calleeTfq4dg_n'

// CHECK-LABEL: sil shared [serialized] @$s21owned_struct_2_calleeTfq4ndgXdn_n : $@convention(thin) (Builtin.Int256, @guaranteed S4, @guaranteed S4, Builtin.Int128) -> (Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128) {
// CHECK: bb0([[O1:%.*]] : $Builtin.Int256, [[INPUT1:%.*]] : $S4, [[INPUT2:%.*]] : $S4, [[O4:%.*]] : $Builtin.Int128):
// CHECK: [[FUNCTION:%.*]] = function_ref @s4_user_twice : $@convention(thin) (S4, S4) -> ()
// CHECK: apply [[FUNCTION]]([[INPUT1]], [[INPUT2]]) : $@convention(thin) (S4, S4) -> ()
// CHECK: [[RESULT:%.*]] = tuple ([[O1]] : $Builtin.Int256, [[O1]] : $Builtin.Int256, [[O4]] : $Builtin.Int128, [[O4]] : $Builtin.Int128)
// CHECK: return [[RESULT]] : $(Builtin.Int256, Builtin.Int256, Builtin.Int128, Builtin.Int128)
// CHECK-LABEL: } // end sil function '$s21owned_struct_2_calleeTfq4ndgXdn_n'


// CHECK-LABEL: sil shared [serialized] @$s18ignore_ptrs_calleeTfq4nxx_n : $@convention(thin) (@in S4Pair, S4, S4) -> (S4, S4) {
// CHECK: bb0([[POINTER:%.*]] : $*S4Pair, [[VALUE1:%.*]] : $S4, [[VALUE2:%.*]] : $S4):
// CHECK: [[FUNCTION:%.*]] = function_ref @s4_user : $@convention(thin) (S4) -> ()
// CHECK: [[POINTEE:%.*]] = load [[POINTER]] : $*S4Pair
// CHECK: [[VALUE:%.*]] = struct_extract [[POINTEE]] : $S4Pair, #S4Pair.f1
// CHECK: apply [[FUNCTION]]([[VALUE]]) : $@convention(thin) (S4) -> ()
// CHECK: [[OUT:%.*]] = tuple ([[VALUE1]] : $S4, [[VALUE2]] : $S4)
// CHECK: return [[OUT]] : $(S4, S4)
// CHECK-LABEL: } // end sil function '$s18ignore_ptrs_calleeTfq4nxx_n'

// CHECK-LABEL: sil shared [serialized] @$s30check_out_of_order_uses_calleeTfq4x_n : $@convention(thin) (S4, S4) -> () {
// CHECK: bb{{[0-9]+}}([[FIRST:%.*]] : $S4, [[SECOND:%.*]] : $S4):
// CHECK: [[TRIPLE:%.*]] = struct $S4Triple ([[FIRST]] : $S4, [[SECOND]] : $S4, undef : $S4)
// CHECK: [[UNUSED_SECOND:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f2
// CHECK: [[FUNCTION:%.*]] = function_ref @s4_user : $@convention(thin) (S4) -> ()
// CHECK: apply [[FUNCTION]]([[IN2]]) : $@convention(thin) (S4) -> ()
// CHECK: [[UNUSED_FIRST:%.*]] = struct_extract [[TRIPLE]] : $S4Triple, #S4Triple.f1
// CHECK: apply [[FUNCTION]]([[IN1]]) : $@convention(thin) (S4) -> ()
// CHECK-LABEL: } // end sil function '$s30check_out_of_order_uses_calleeTfq4x_n'


// CHECK-LABEL: sil shared [serialized] @$s14class_callee_1Tfq4gn_n : $@convention(thin) (@guaranteed C1, Builtin.Int32) -> Builtin.Int32 {
// CHECK: bb0({{%.*}} : $C1, [[IN:%.*]] : $Builtin.Int32):
// CHECK: return [[IN]] : $Builtin.Int32
