// RUN: %target-sil-opt -silgen-cleanup %s | %FileCheck %s

import Builtin

sil_stage raw

protocol Error {}

class Klass {}
class SubKlass : Klass {}

sil @use_klass_guaranteed : $@convention(thin) (@guaranteed Klass) -> ()
sil @use_klass_owned : $@convention(thin) (@owned Klass) -> ()
sil @use_klass_unowned : $@convention(thin) (Klass) -> ()

enum FakeOptional<T> {
case none
case some(T)
}

sil @use_fakeoptional_klass_guaranteed : $@convention(thin) (@guaranteed FakeOptional<Klass>) -> ()

struct Int {
  var _value : Builtin.Int32
}

struct UInt8 {
  var _value : Builtin.Int8
}

// CHECK-LABEL: sil [ossa] @struct_extract_load_to_load_struct_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*UInt8):
// CHECK-NEXT:  [[IN_GEP:%[0-9]+]] = struct_element_addr [[IN]] : $*UInt8, #UInt8._value
// CHECK-NEXT:  [[IN_LOADED:%[0-9]+]] = load [trivial] [[IN_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  [[LITERAL:%[0-9]+]] = integer_literal $Builtin.Int8, 1
// CHECK-NEXT:  [[UINT8:%.*]] = struct $UInt8 ([[LITERAL]] : $Builtin.Int8)
// CHECK-NEXT:  store [[UINT8]] to [trivial] [[IN]] : $*UInt8
// CHECK-NEXT:  return [[IN_LOADED]] : $Builtin.Int8
sil [ossa] @struct_extract_load_to_load_struct_element_addr : $@convention(thin) (@inout UInt8) -> (Builtin.Int8) {
bb0(%0 : $*UInt8):
  %1 = load [trivial] %0 : $*UInt8
  %2 = integer_literal $Builtin.Int8, 1
  %3 = struct_element_addr %0 : $*UInt8, #UInt8._value
  store %2 to [trivial] %3 : $*Builtin.Int8
  %5 = struct_extract %1 : $UInt8, #UInt8._value
  return %5 : $Builtin.Int8
}

// CHECK-LABEL: sil [ossa] @tuple_extract_load_to_load_tuple_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*(Builtin.Int8, Builtin.Int8)):
// CHECK-NEXT:  [[IN_GEP:%[0-9]+]] = tuple_element_addr [[IN]] : $*(Builtin.Int8, Builtin.Int8), 0
// CHECK-NEXT:  [[IN_LOADED:%[0-9]+]] = load [trivial] [[IN_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  [[LITERAL:%[0-9]+]] = integer_literal $Builtin.Int8, 1
// CHECK-NEXT:  [[IN_STORE_GEP:%[0-9]+]] = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
// CHECK-NEXT:  store [[LITERAL]] to [trivial] [[IN_STORE_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  return [[IN_LOADED]] : $Builtin.Int8
sil [ossa] @tuple_extract_load_to_load_tuple_element_addr : $@convention(thin) (@inout (Builtin.Int8, Builtin.Int8)) -> (Builtin.Int8) {
bb0(%0 : $*(Builtin.Int8, Builtin.Int8)):
  %1 = load [trivial] %0 : $*(Builtin.Int8, Builtin.Int8)
  %2 = integer_literal $Builtin.Int8, 1
  %3 = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
  store %2 to [trivial] %3 : $*Builtin.Int8
  %5 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int8), 0
  return %5 : $Builtin.Int8
}

// Do not perform the optimization of the input load has multiple uses.
//
// CHECK-LABEL: sil [ossa] @multiple_use_struct_extract_load_to_load_struct_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*UInt8):
// CHECK-NEXT: load
// CHECK-NEXT: integer_literal
// CHECK-NEXT: struct
// CHECK-NEXT: store
// CHECK-NEXT: struct_extract
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil [ossa] @multiple_use_struct_extract_load_to_load_struct_element_addr : $@convention(thin) (@inout UInt8) -> (UInt8, Builtin.Int8) {
bb0(%0 : $*UInt8):
  %1 = load [trivial] %0 : $*UInt8
  %2 = integer_literal $Builtin.Int8, 1
  %3 = struct_element_addr %0 : $*UInt8, #UInt8._value
  store %2 to [trivial] %3 : $*Builtin.Int8
  %5 = struct_extract %1 : $UInt8, #UInt8._value
  %6 = tuple (%1 : $UInt8, %5 : $Builtin.Int8)
  return %6 : $(UInt8, Builtin.Int8)
}

// Do not perform the optimization of the input load has multiple uses.
//
// CHECK-LABEL: sil [ossa] @multiple_use_tuple_extract_load_to_load_tuple_element_addr
// CHECK: bb0
// CHECK-NEXT: load
// CHECK-NEXT: integer_literal
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: store
// CHECK-NEXT: tuple_extract
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil [ossa] @multiple_use_tuple_extract_load_to_load_tuple_element_addr : $@convention(thin) (@inout (Builtin.Int8, Builtin.Int8)) -> ((Builtin.Int8, Builtin.Int8), Builtin.Int8) {
bb0(%0 : $*(Builtin.Int8, Builtin.Int8)):
  %1 = load [trivial] %0 : $*(Builtin.Int8, Builtin.Int8)
  %2 = integer_literal $Builtin.Int8, 1
  %3 = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
  store %2 to [trivial] %3 : $*Builtin.Int8
  %5 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int8), 0
  %6 = tuple (%1 : $(Builtin.Int8, Builtin.Int8), %5 : $Builtin.Int8)
  return %6 : $((Builtin.Int8, Builtin.Int8), Builtin.Int8)
}

// Handle a combination of trivial and nontrivial elements.

struct X1 {
  @_hasStorage @_hasInitialValue let a: Int { get }
  @_hasStorage @_hasInitialValue var obj1: Builtin.NativeObject { get set }
  @_hasStorage @_hasInitialValue var obj2: Builtin.NativeObject { get set }
  init(a: Int, obj1: Builtin.NativeObject, obj2: Builtin.NativeObject)
}

// CHECK-LABEL: sil private [ossa] @testLoadNontrivial : $@convention(thin) (@inout_aliasable X1) -> (Int, @owned Builtin.NativeObject, @owned Builtin.NativeObject) {
// CHECK-LABEL: bb0(%0 : $*X1):
// CHECK: [[ACCESS:%.*]] = begin_access [read] [unknown] %0 : $*X1
// CHECK: [[AA:%.*]] = struct_element_addr [[ACCESS]] : $*X1, #X1.a
// CHECK: load [trivial] [[AA]] : $*Int
// CHECK: [[OA1:%.*]] = struct_element_addr [[ACCESS]] : $*X1, #X1.obj1
// CHECK: [[OV1:%.*]] = load [copy] [[OA1]] : $*Builtin.NativeObject
// CHECK: [[OA2:%.*]] = struct_element_addr [[ACCESS]] : $*X1, #X1.obj2
// CHECK: [[OV2:%.*]] = load [copy] [[OA2]] : $*Builtin.NativeObject
// CHECK: end_access [[ACCESS]] : $*X1
// CHECK: copy_value [[OV1]] : $Builtin.NativeObject
// CHECK: copy_value [[OV2]] : $Builtin.NativeObject
// CHECK: return
// CHECK-LABEL: } // end sil function 'testLoadNontrivial'
sil private [ossa] @testLoadNontrivial : $@convention(thin) (@inout_aliasable X1) -> (Int, @owned Builtin.NativeObject, @owned Builtin.NativeObject) {
bb0(%0 : $*X1):
  %access = begin_access [read] [unknown] %0 : $*X1
  %load = load [copy] %access : $*X1
  end_access %access : $*X1

  %borrowa = begin_borrow %load : $X1
  %a = struct_extract %borrowa : $X1, #X1.a
  end_borrow %borrowa : $X1

  %borrow1 = begin_borrow %load : $X1
  %o1 = struct_extract %borrow1 : $X1, #X1.obj1
  %copy1 = copy_value %o1 : $Builtin.NativeObject
  end_borrow %borrow1 : $X1

  %borrow2 = begin_borrow %load : $X1
  %o2 = struct_extract %borrow2 : $X1, #X1.obj2
  %copy2 = copy_value %o2 : $Builtin.NativeObject
  end_borrow %borrow2 : $X1

  destroy_value %load : $X1

  %result = tuple (%a : $Int, %copy1 : $Builtin.NativeObject, %copy2 : $Builtin.NativeObject)
  return %result : $(Int, Builtin.NativeObject, Builtin.NativeObject)
}

// CHECK-LABEL: sil private [ossa] @testLoadBorrowNontrivial : $@convention(thin) (@in_guaranteed X1) -> (Int, @owned Builtin.NativeObject, @owned Builtin.NativeObject) {
// CHECK: bb0([[ADDRESS:%.*]] : $*X1):
// CHECK: [[AA:%.*]] = struct_element_addr [[ADDRESS]] : $*X1, #X1.a
// CHECK: load [trivial] [[AA]] : $*Int
// CHECK: [[OA1:%.*]] = struct_element_addr [[ADDRESS]] : $*X1, #X1.obj1
// CHECK: [[OV1:%.*]] = load_borrow [[OA1]] : $*Builtin.NativeObject
// CHECK: [[OA2:%.*]] = struct_element_addr [[ADDRESS]] : $*X1, #X1.obj2
// CHECK: [[OV2:%.*]] = load_borrow [[OA2]] : $*Builtin.NativeObject
// CHECK: copy_value [[OV1]] : $Builtin.NativeObject
// CHECK: copy_value [[OV2]] : $Builtin.NativeObject
// CHECK: end_borrow [[OV1]]
// CHECK: end_borrow [[OV2]]
// CHECK: return
// CHECK-LABEL: } // end sil function 'testLoadBorrowNontrivial'
sil private [ossa] @testLoadBorrowNontrivial : $@convention(thin) (@in_guaranteed X1) -> (Int, @owned Builtin.NativeObject, @owned Builtin.NativeObject) {
bb0(%0 : $*X1):
  %load = load_borrow %0 : $*X1

  %a = struct_extract %load : $X1, #X1.a

  %o1 = struct_extract %load : $X1, #X1.obj1
  %copy1 = copy_value %o1 : $Builtin.NativeObject

  %o2 = struct_extract %load : $X1, #X1.obj2
  %copy2 = copy_value %o2 : $Builtin.NativeObject

  end_borrow %load : $X1

  %result = tuple (%a : $Int, %copy1 : $Builtin.NativeObject, %copy2 : $Builtin.NativeObject)
  return %result : $(Int, Builtin.NativeObject, Builtin.NativeObject)
}


struct X2 {
  @_hasStorage @_hasInitialValue var obj: Builtin.NativeObject { get set }
}

struct X3 {
  @_hasStorage @_hasInitialValue var x2: X2 { get set }
}

// CHECK-LABEL: sil private [ossa] @testStoreNontrivial : $@convention(thin) (@inout X3, @guaranteed Builtin.NativeObject) -> () {
// CHECK: bb0(%0 : $*X3, %1 : @guaranteed $Builtin.NativeObject):
// CHECK: [[CP:%.*]] = copy_value %1 : $Builtin.NativeObject
// CHECK: [[ACCESS:%.*]] = begin_access [modify] [unknown] %0 : $*X3
// CHECK: [[X2:%.*]] = struct $X2 ([[CP]] : $Builtin.NativeObject)
// CHECK: [[X3:%.*]] = struct $X3 ([[X2]] : $X2)
// CHECK: store [[X3]] to [assign] [[ACCESS]] : $*X3
// CHECK: end_access [[ACCESS]] : $*X3
// CHECK: } // end sil function 'testStoreNontrivial'
sil private [ossa] @testStoreNontrivial : $@convention(thin) (@inout X3, @guaranteed Builtin.NativeObject) -> () {
bb0(%0 : $*X3, %1 : @guaranteed $Builtin.NativeObject):
  %4 = copy_value %1 : $Builtin.NativeObject
  %5 = begin_access [modify] [unknown] %0 : $*X3
  %6 = struct_element_addr %5 : $*X3, #X3.x2
  %7 = struct_element_addr %6 : $*X2, #X2.obj
  store %4 to [assign] %7 : $*Builtin.NativeObject
  end_access %5 : $*X3
  %12 = tuple ()
  return %12 : $()
}

// We used to hit a memory error on this test.
//
// CHECK-LABEL: sil [ossa] @testDestructureTupleNoCrash : $@convention(thin) (@owned (Builtin.NativeObject, Builtin.NativeObject)) -> () {
// CHECK: bb0(
// CHECK-NEXT: destroy_value
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK: } // end sil function 'testDestructureTupleNoCrash'
sil [ossa] @testDestructureTupleNoCrash : $@convention(thin) (@owned (Builtin.NativeObject, Builtin.NativeObject)) -> () {
bb0(%0 : @owned $(Builtin.NativeObject, Builtin.NativeObject)):
  (%1, %2) = destructure_tuple %0 : $(Builtin.NativeObject, Builtin.NativeObject)
  debug_value %1 : $Builtin.NativeObject, let, name "key"
  debug_value %2 : $Builtin.NativeObject, let, name "value"
  %3 = begin_borrow %1 : $Builtin.NativeObject
  end_borrow %3 : $Builtin.NativeObject
  %4 = begin_borrow %2 : $Builtin.NativeObject
  end_borrow %4 : $Builtin.NativeObject
  destroy_value %2 : $Builtin.NativeObject
  destroy_value %1 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRoundTripDestructureTuple : $@convention(thin) (@owned (Klass, Klass)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK-NOT: tuple ({{%.*}} : $Klass,
// CHECK: } // end sil function 'testRoundTripDestructureTuple'
sil [ossa] @testRoundTripDestructureTuple : $@convention(thin) (@owned (Klass, Klass)) -> () {
bb0(%0 : @owned $(Klass, Klass)):
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  %3 = tuple(%1 : $Klass, %2: $Klass)
  destroy_value %3 : $(Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// Fail case where the tuple is partially from a destructure and partially from
// something else.
//
// CHECK-LABEL: sil [ossa] @testRoundTripDestructureTuple2 : $@convention(thin) (@owned (Klass, Klass), @owned Klass) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRoundTripDestructureTuple2'
sil [ossa] @testRoundTripDestructureTuple2 : $@convention(thin) (@owned (Klass, Klass), @owned Klass) -> () {
bb0(%0 : @owned $(Klass, Klass), %0a : @owned $Klass):
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  %3 = tuple (%1 : $Klass, %0a: $Klass)
  destroy_value %2 : $Klass
  destroy_value %3 : $(Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// Make sure we don't crash when we check if %0a is a destructure_tuple.
// CHECK-LABEL: sil [ossa] @testRoundTripDestructureTuple3 : $@convention(thin) (@owned (Klass, Klass), @owned Klass) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRoundTripDestructureTuple3'
sil [ossa] @testRoundTripDestructureTuple3 : $@convention(thin) (@owned (Klass, Klass), @owned Klass) -> () {
bb0(%0 : @owned $(Klass, Klass), %0a : @owned $Klass):
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  %3 = tuple (%0a : $Klass, %1 : $Klass)
  destroy_value %2 : $Klass
  destroy_value %3 : $(Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We are very conservative and do not perform this optimization if we have any
// uses of the destructure elements.
//
// CHECK-LABEL: sil [ossa] @testRoundTripDestructureTuple4 : $@convention(thin) (@owned (Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRoundTripDestructureTuple4'
sil [ossa] @testRoundTripDestructureTuple4 : $@convention(thin) (@owned (Klass, Klass)) -> () {
bb0(%0 : @owned $(Klass, Klass)):
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  debug_value %1 : $Klass, let, name "oops"
  %3 = tuple(%1 : $Klass, %2: $Klass)
  destroy_value %3 : $(Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// Can't handle this case because of named parameters of the tuple.
//
// CHECK-LABEL: sil [ossa] @testRoundTripDestructureTuple5 : $@convention(thin) (@owned (Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRoundTripDestructureTuple5'
sil [ossa] @testRoundTripDestructureTuple5 : $@convention(thin) (@owned (Klass, Klass)) -> () {
bb0(%0 : @owned $(Klass, Klass)):
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  %3 = tuple $(bar: Klass, baz: Klass) (%1, %2)
  destroy_value %3 : $(bar: Klass, baz: Klass)
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRoundTripTupleDestructure : $@convention(thin) (@owned Klass, @owned Klass) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRoundTripTupleDestructure'
sil [ossa] @testRoundTripTupleDestructure : $@convention(thin) (@owned Klass, @owned Klass) -> () {
bb0(%0 : @owned $Klass, %1 : @owned $Klass):
  %2 = tuple(%0 : $Klass, %1 : $Klass)
  (%3, %4) = destructure_tuple %2 : $(Klass, Klass)
  destroy_value %3 : $Klass
  destroy_value %4 : $Klass
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRoundTripTupleDestructure2 : $@convention(thin) (@owned Klass, @owned Klass) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRoundTripTupleDestructure2'
sil [ossa] @testRoundTripTupleDestructure2 : $@convention(thin) (@owned Klass, @owned Klass) -> () {
bb0(%0 : @owned $Klass, %1 : @owned $Klass):
  %2 = tuple(%0 : $Klass, %1 : $Klass)
  debug_value %2 : $(Klass, Klass), let, name "oops2"
  (%3, %4) = destructure_tuple %2 : $(Klass, Klass)
  destroy_value %3 : $Klass
  destroy_value %4 : $Klass
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureElimination1 : $@convention(thin) (@owned (Klass, Klass, Int)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureElimination1'
sil [ossa] @testRValueTupleDestructureElimination1 : $@convention(thin) (@owned (Klass, Klass, Int)) -> () {
bb0(%arg : @owned $(Klass, Klass, Int)):
  %alloc = alloc_stack $(Klass, Klass, Int)
  %t0 = tuple_element_addr %alloc : $*(Klass, Klass, Int), 0
  %t1 = tuple_element_addr %alloc : $*(Klass, Klass, Int), 1
  %t2 = tuple_element_addr %alloc : $*(Klass, Klass, Int), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Klass, Klass, Int)
  store %0 to [init] %t0 : $*Klass
  store %1 to [init] %t1 : $*Klass
  store %2 to [trivial] %t2 : $*Int
  destroy_addr %alloc : $*(Klass, Klass, Int)
  dealloc_stack %alloc : $*(Klass, Klass, Int)
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureElimination2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureElimination2'
sil [ossa] @testRValueTupleDestructureElimination2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  store %0 to [trivial] %t0 : $*Int
  store %1 to [init] %t1 : $*Klass
  store %2 to [init] %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureElimination3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureElimination3'
sil [ossa] @testRValueTupleDestructureElimination3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  assign %0 to %t0 : $*Int
  assign %1 to %t1 : $*Klass
  assign %2 to %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do handle this case despite having multiple uses since our tuple_element_addr isn't an interleaved case.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureElimination4 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureElimination4'
sil [ossa] @testRValueTupleDestructureElimination4 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  store %0 to [trivial] %t0 : $*Int
  store %1 to [init] %t1 : $*Klass
  store %2 to [init] %t2 : $*Klass
  %3 = load_borrow %t2 : $*Klass
  end_borrow %3 : $Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since the SILGen cases that we want to handle
// /always/ are consistently either stores or assigns... never mixes.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureEliminationFail1 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureEliminationFail1'
sil [ossa] @testRValueTupleDestructureEliminationFail1 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  store %0 to [trivial] %t0 : $*Int
  store %1 to [init] %t1 : $*Klass
  assign %2 to %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since the SILGen cases that we want to handle
// never mix store assign or store trivial.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureEliminationFail2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureEliminationFail2'
sil [ossa] @testRValueTupleDestructureEliminationFail2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  // This extra tuple_element_addr is important since we require that our
  // tuple_element_addr only have a single use to directly match the SILGen
  // pattern. We test that we fail when we have multiple uses in a different
  // test.
  %t22 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %2a = copy_value %2 : $Klass
  store %2a to [init] %t22 : $*Klass
  store %0 to [trivial] %t0 : $*Int
  store %1 to [init] %t1 : $*Klass
  store %2 to [assign] %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since our stores are in the wrong order. We are
// pattern matching SILGen exactly.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureEliminationFail3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureEliminationFail3'
sil [ossa] @testRValueTupleDestructureEliminationFail3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  store %0 to [trivial] %t0 : $*Int
  store %2 to [init] %t2 : $*Klass
  store %1 to [init] %t1 : $*Klass
  %3 = load_borrow %t2 : $*Klass
  end_borrow %3 : $Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since the SILGen cases that we want to handle
// never mix different kinds of assigns
//
// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureEliminationFail4 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureEliminationFail4'
sil [ossa] @testRValueTupleDestructureEliminationFail4 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  // This extra tuple_element_addr is important since we require that our
  // tuple_element_addr only have a single use to directly match the SILGen
  // pattern. We test that we fail when we have multiple uses in a different
  // test.
  %t22 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %2a = copy_value %2 : $Klass
  store %2a to [init] %t22 : $*Klass
  assign %0 to %t0 : $*Int
  assign %1 to [init] %t1 : $*Klass
  assign %2 to %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// This makes sure that we do not handle a case if one of our tuple_element_addr
// has the right tuple element but stores into a different allocation.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureEliminationFail5 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureEliminationFail5'
sil [ossa] @testRValueTupleDestructureEliminationFail5 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %alloc2 = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc2 : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  store %0 to [trivial] %t0 : $*Int
  store %1 to [init] %t1 : $*Klass
  store %2 to [init]%t2 : $*Klass
  dealloc_stack %alloc2 : $*(Int, Klass, Klass)
  %t0a = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0a : $*Int
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// Fail because of typed elts
//
// CHECK-LABEL: sil [ossa] @testRValueTupleDestructureEliminationFail6 : $@convention(thin) (@owned (biz: Int, baz: Klass, buz: Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleDestructureEliminationFail6'
sil [ossa] @testRValueTupleDestructureEliminationFail6 : $@convention(thin) (@owned (biz: Int, baz: Klass, buz: Klass)) -> () {
bb0(%arg : @owned $(biz: Int, baz: Klass, buz: Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(biz: Int, baz: Klass, buz: Klass)
  store %0 to [trivial] %t0 : $*Int
  store %1 to [init] %t1 : $*Klass
  store %2 to [init] %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureElimination1 : $@convention(thin) (@owned (Klass, Klass, Int)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureElimination1'
sil [ossa] @testRValueTupleInterleavedDestructureElimination1 : $@convention(thin) (@owned (Klass, Klass, Int)) -> () {
bb0(%arg : @owned $(Klass, Klass, Int)):
  %alloc = alloc_stack $(Klass, Klass, Int)
  (%0, %1, %2) = destructure_tuple %arg : $(Klass, Klass, Int)
  %t0 = tuple_element_addr %alloc : $*(Klass, Klass, Int), 0
  store %0 to [init] %t0 : $*Klass
  %t1 = tuple_element_addr %alloc : $*(Klass, Klass, Int), 1
  store %1 to [init] %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Klass, Klass, Int), 2
  store %2 to [trivial] %t2 : $*Int
  destroy_addr %alloc : $*(Klass, Klass, Int)
  dealloc_stack %alloc : $*(Klass, Klass, Int)
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureElimination2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureElimination2'
sil [ossa] @testRValueTupleInterleavedDestructureElimination2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0 : $*Int
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  store %2 to [init] %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureElimination3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK-NOT: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureElimination3'
sil [ossa] @testRValueTupleInterleavedDestructureElimination3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  assign %0 to %t0 : $*Int
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  assign %1 to %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  assign %2 to %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since the SILGen cases that we want to handle
// /always/ are consistently either stores or assigns... never mixes.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail1 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureEliminationFail1'
sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail1 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0 : $*Int
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  assign %2 to %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since the SILGen cases that we want to handle
// never mix store assign or store trivial.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureEliminationFail2'
sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail2 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  // This extra tuple_element_addr is important since we require that our
  // tuple_element_addr only have a single use to directly match the SILGen
  // pattern. We test that we fail when we have multiple uses in a different
  // test.
  %t22 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %2a = copy_value %2 : $Klass
  store %2a to [init] %t22 : $*Klass
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0 : $*Int
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  store %2 to [assign] %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since our stores are in the wrong order. We are
// pattern matching SILGen exactly.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureEliminationFail3'
sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail3 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0 : $*Int
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  store %2 to [init] %t2 : $*Klass
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  %3 = load_borrow %t2 : $*Klass
  end_borrow %3 : $Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since our stores are in the wrong order. We are
// pattern matching SILGen exactly.
//
// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail3a : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureEliminationFail3a'
sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail3a : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0 : $*Int
  store %2 to [init] %t2 : $*Klass
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  %3 = load_borrow %t2 : $*Klass
  end_borrow %3 : $Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since the SILGen cases that we want to handle
// never mix different kinds of assigns
//
// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail4 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureEliminationFail4'
sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail4 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  // This extra tuple_element_addr is important since we require that our
  // tuple_element_addr only have a single use to directly match the SILGen
  // pattern. We test that we fail when we have multiple uses in a different
  // test.
  %t22 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %2a = copy_value %2 : $Klass
  store %2a to [init] %t22 : $*Klass
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  assign %0 to %t0 : $*Int
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  assign %1 to [init] %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  assign %2 to %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this case since we are in an interleaved case and our
// tuple_element_addr has multiple uses
//
// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail5 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureEliminationFail5'
sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail5 : $@convention(thin) (@owned (Int, Klass, Klass)) -> () {
bb0(%arg : @owned $(Int, Klass, Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  (%0, %1, %2) = destructure_tuple %arg : $(Int, Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0 : $*Int
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  store %2 to [init] %t2 : $*Klass
  %3 = load_borrow %t2 : $*Klass
  end_borrow %3 : $Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// Fail because of typed elts
//
// CHECK-LABEL: sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail6 : $@convention(thin) (@owned (biz: Int, baz: Klass, buz: Klass)) -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testRValueTupleInterleavedDestructureEliminationFail6'
sil [ossa] @testRValueTupleInterleavedDestructureEliminationFail6 : $@convention(thin) (@owned (biz: Int, baz: Klass, buz: Klass)) -> () {
bb0(%arg : @owned $(biz: Int, baz: Klass, buz: Klass)):
  %alloc = alloc_stack $(Int, Klass, Klass)
  (%0, %1, %2) = destructure_tuple %arg : $(biz: Int, baz: Klass, buz: Klass)
  %t0 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 0
  store %0 to [trivial] %t0 : $*Int
  %t1 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  %t2 = tuple_element_addr %alloc : $*(Int, Klass, Klass), 2
  store %2 to [init] %t2 : $*Klass
  destroy_addr %alloc : $*(Int, Klass, Klass)
  dealloc_stack %alloc : $*(Int, Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// We do not support this case since the destructure_tuple is needed to split
// the Int so we do not need to deal with the named tuple elements of the out
// parameter.
//
// CHECK-LABEL: sil [ossa] @testDestructureNamedLabelAddress : $@convention(thin) (@noescape @callee_guaranteed () -> ((Int, Int), @error Error)) -> (@out (lhs: Int, rhs: Int), @error Error) {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'testDestructureNamedLabelAddress'
sil [ossa] @testDestructureNamedLabelAddress : $@convention(thin) (@noescape @callee_guaranteed () -> ((Int, Int), @error Error)) -> (@out (lhs: Int, rhs: Int), @error Error) {
bb0(%0 : $*(lhs: Int, rhs: Int), %1 : $@noescape @callee_guaranteed () -> ((Int, Int), @error Error)):
  %3 = tuple_element_addr %0 : $*(lhs: Int, rhs: Int), 0
  %4 = tuple_element_addr %0 : $*(lhs: Int, rhs: Int), 1
  try_apply %1() : $@noescape @callee_guaranteed () -> ((Int, Int), @error Error), normal bb1, error bb2

bb1(%6 : $(Int, Int)):
  (%7, %8) = destructure_tuple %6 : $(Int, Int)
  store %7 to [trivial] %3 : $*Int
  store %8 to [trivial] %4 : $*Int
  %11 = tuple ()
  return %11 : $()

bb2(%13 : @owned $Error):
  throw %13 : $Error
}

sil @return_tuple_nativeobject : $@convention(thin) () -> (@owned Klass, @owned Klass)

// CHECK-LABEL: sil [ossa] @test_noopt_apply_result_tuple_destructure : $@convention(thin)
// CHECK: destructure_tuple
// CHECK: } // end sil function 'test_noopt_apply_result_tuple_destructure'
sil [ossa] @test_noopt_apply_result_tuple_destructure : $@convention(thin) () -> () {
bb0:
  %f = function_ref @return_tuple_nativeobject : $@convention(thin) () -> (@owned Klass, @owned Klass)
  %0 = apply %f() : $@convention(thin) () -> (@owned Klass, @owned Klass)
  (%1, %2) = destructure_tuple %0 : $(Klass, Klass)
  %3 = tuple(%1 : $Klass, %2: $Klass)
  destroy_value %3 : $(Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @test_noopt_apply_result_tuple_destructure_2 : $@convention(thin) () -> () {
// CHECK: destructure_tuple
// CHECK: } // end sil function 'test_noopt_apply_result_tuple_destructure_2'
sil [ossa] @test_noopt_apply_result_tuple_destructure_2 : $@convention(thin) () -> () {
bb0:
  %alloc = alloc_stack $(Klass, Klass)
  %f = function_ref @return_tuple_nativeobject : $@convention(thin) () -> (@owned Klass, @owned Klass)
  %result = apply %f() : $@convention(thin) () -> (@owned Klass, @owned Klass)
  (%0, %1) = destructure_tuple %result : $(Klass, Klass)
  %t0 = tuple_element_addr %alloc : $*(Klass, Klass), 0
  store %0 to [init] %t0 : $*Klass
  %t1 = tuple_element_addr %alloc : $*(Klass, Klass), 1
  store %1 to [init] %t1 : $*Klass
  destroy_addr %alloc : $*(Klass, Klass)
  dealloc_stack %alloc : $*(Klass, Klass)
  %9999 = tuple()
  return %9999 : $()
}
