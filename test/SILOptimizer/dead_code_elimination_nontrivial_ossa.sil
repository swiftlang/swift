// RUN: %target-sil-opt -sil-print-types -enable-sil-verify-all -dce %s | %FileCheck %s

// REQUIRES: swift_in_compiler

sil_stage canonical

import Builtin
import Swift

class Klass {

}

enum EitherNoneOrAnyObject {
case none
case any(AnyObject)
}

struct NonTrivialStruct {
  var val:Klass
}

enum FakeOptional<T> {
case none
case some(T)
}

struct Wrapper1 {
  var val1: Wrapper2
}

struct Wrapper2 {
  var val2: Klass
}

sil [ossa] @$testtryapplyklassgen : $@convention(thin) () -> (@owned Klass, @error any Error)
sil [ossa] @$use_klass1 : $@convention(thin) (@owned Klass) -> ()
sil [ossa] @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
sil [ossa] @$use_nontrivialstruct1 : $@convention(thin) (@owned NonTrivialStruct) -> ()
sil [ossa] @$use_nontrivialstruct2 : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()

// We cannot DCE a function argument
// CHECK-LABEL: sil [ossa] @dce_dontoptarg1 :
// CHECK: destroy_value %0
// CHECK-LABEL: } // end sil function 'dce_dontoptarg1'
sil [ossa] @dce_dontoptarg1 : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  destroy_value %0 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_dontoptarg2 :
// CHECK: copy_value
// CHECK: destroy_value
// CHECK-LABEL: } // end sil function 'dce_dontoptarg2'
sil [ossa] @dce_dontoptarg2 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  br bb1(%1 : $Klass)

bb1(%2 : @owned $Klass):
  %3 = copy_value %2 : $Klass
  %4 = function_ref @$use_klass1 : $@convention(thin) (@owned Klass) -> ()
  %5 = apply %4(%3) : $@convention(thin) (@owned Klass) -> ()
  destroy_value %2 : $Klass
  %res = tuple ()
  return %res : $()
}

// Don't dce due to a useful dependency due to apply
// CHECK-LABEL: sil [ossa] @dce_dontoptrevdep1 :
// CHECK: [[RES:%.*]] = load_borrow %0
// CHECK: end_borrow [[RES]]
// CHECK-LABEL: } // end sil function 'dce_dontoptrevdep1'
sil [ossa] @dce_dontoptrevdep1 : $@convention(thin) (@in Klass) -> () {
bb0(%0 : $*Klass):
  %1 = load_borrow %0 : $*Klass
  %2 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %3 = apply %2(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %1 : $Klass
  destroy_addr %0 : $*Klass
  %res = tuple ()
  return %res : $()
}

// Don't dce due to a useful dependency due to apply
// CHECK-LABEL: sil [ossa] @dce_dontoptendborrow1 :
// CHECK: [[RES:%.*]] = begin_borrow %0
// CHECK: end_borrow
// CHECK-LABEL: } // end sil function 'dce_dontoptendborrow1'
sil [ossa] @dce_dontoptendborrow1 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = begin_borrow %0
  br bb1(%1)

bb1(%3 : @reborrow $Klass):
  %4 = borrowed %3 from (%0)
  %5 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %6 = apply %5(%4) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %4
  %8 = tuple ()
  return %8
}

// Cannot optimize dead non phi args
// CHECK-LABEL: sil [ossa] @dce_dontoptarg3 :
// CHECK: destroy_value
// CHECK-LABEL: } // end sil function 'dce_dontoptarg3'
sil [ossa] @dce_dontoptarg3 : $@convention(thin) (@guaranteed Klass) -> @error any Error {
bb0(%0 : @guaranteed $Klass):
  %2 = function_ref @$testtryapplyklassgen : $@convention(thin) () -> (@owned Klass, @error any Error)
  try_apply %2() : $@convention(thin) () -> (@owned Klass, @error any Error), normal bb1, error bb2

bb1(%3 : @owned $Klass):
  destroy_value %3 : $Klass
  %res = tuple ()
  return %res : $()

bb2(%4 : $Error):
  throw %4 : $Error
}

// CHECK-LABEL: sil [ossa] @dce_deadcopy1 :
// CHECK:         copy_value
// CHECK:         destroy_value %1
// CHECK:         destroy_value %0
// CHECK-LABEL: } // end sil function 'dce_deadcopy1'
sil [ossa] @dce_deadcopy1 : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = copy_value %0 : $Klass
  destroy_value %1 : $Klass
  destroy_value %0 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadcopy2 :
// CHECK:         copy_value
// CHECK:         destroy_value
// CHECK-LABEL: } // end sil function 'dce_deadcopy2'
sil [ossa] @dce_deadcopy2 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  destroy_value %1 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadcopy3 :
// CHECK:       bb0([[ARG:%.*]])
// CHECK-NEXT:    copy_value
// CHECK:       bb1({{.*}}):
// CHECK-NEXT:    destroy_value
// CHECK-LABEL: } // end sil function 'dce_deadcopy3'
sil [ossa] @dce_deadcopy3 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  br bb1(%1 : $Klass)

bb1(%2 : @owned $Klass):
  destroy_value %2 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadcopy4 :
// CHECK:        copy_value
// CHECK:        destroy_value
// CHECK-LABEL: } // end sil function 'dce_deadcopy4'
sil [ossa] @dce_deadcopy4 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  cond_br undef, bb1, bb2

bb1:
  br bb3(%1 : $Klass)

bb2:
  br bb3(%1 : $Klass)

bb3(%2 : @owned $Klass):
  destroy_value %2 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadcopy5 :
// CHECK:       bb0([[ARG:%.*]])
// CHECK-NEXT:    copy_value 
// CHECK:       bb1({{.*}}):
// CHECK-NEXT:    destroy_value
// CHECK-LABEL: } // end sil function 'dce_deadcopy5'
sil [ossa] @dce_deadcopy5 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  cond_br undef, bb1, bb2

bb3(%2 : @owned $Klass):
  destroy_value %2 : $Klass
  %res = tuple ()
  return %res : $()

bb1:
  br bb3(%1 : $Klass)

bb2:
  br bb3(%1 : $Klass)
}

// CHECK-LABEL: sil [ossa] @dce_deadcopy6 :
// CHECK:       bb0([[ARG:%.*]])
// CHECK-NEXT:    copy_value
// CHECK:       bb5({{.*}}):
// CHECK-NEXT:    destroy_value
// CHECK-LABEL: } // end sil function 'dce_deadcopy6'
sil [ossa] @dce_deadcopy6 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  cond_br undef, bb1a, bb2a

bb1a:
  br bb1(%1 : $Klass)

bb2a:
  br bb2(%1 : $Klass)

bb1(%1a : @owned $Klass):
  br bb3(%1a : $Klass)

bb2(%1b : @owned $Klass):
  br bb3(%1b : $Klass)

bb3(%2 : @owned $Klass):
  destroy_value %2 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadcopy7 :
// CHECK:         load [copy]
// CHECK-LABEL: } // end sil function 'dce_deadcopy7'
sil [ossa] @dce_deadcopy7 : $@convention(thin) (@in Klass) -> () {
bb0(%0 : $*Klass):
  %1 = load [copy] %0 : $*Klass
  br bb1(%1 : $Klass)

bb1(%2 : @owned $Klass):
  destroy_value %2 : $Klass
  destroy_addr %0 : $*Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_destructure1 :
// CHECK:       bb0(%0 : {{.*}})
// CHECK-NEXT:    %1 = destructure_struct
// CHECK-NEXT:    destroy_value %1
// CHECK-LABEL: } // end sil function 'dce_destructure1'
sil [ossa] @dce_destructure1 : $@convention(thin) (@owned NonTrivialStruct) -> () {
bb0(%0 : @owned $NonTrivialStruct):
  (%1) = destructure_struct %0 : $NonTrivialStruct
  destroy_value %1 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_destructure2 :
// CHECK: bb0(%0 : {{.*}})
// CHECK-NEXT: [[RES:%.*]] = tuple ()
// CHECK-NEXT: return [[RES]]
// CHECK-LABEL: } // end sil function 'dce_destructure2'
sil [ossa] @dce_destructure2 : $@convention(thin) (@guaranteed NonTrivialStruct) -> () {
bb0(%0 : @guaranteed $NonTrivialStruct):
  (%1) = destructure_struct %0 : $NonTrivialStruct
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_destructure3 :
// CHECK:       bb0(%0 : {{.*}})
// CHECK:         destructure_struct
// CHECK-LABEL: } // end sil function 'dce_destructure3'
sil [ossa] @dce_destructure3 : $@convention(thin) (@guaranteed NonTrivialStruct) -> () {
bb0(%0 : @guaranteed $NonTrivialStruct):
  %1 = copy_value %0 : $NonTrivialStruct
  %func = function_ref @$use_nontrivialstruct2 : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
  %funcres = apply %func(%1) : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
  (%2) = destructure_struct %1 : $NonTrivialStruct
  destroy_value %2 : $Klass
  %res = tuple ()
  return %res : $()
}

// This test shows that when we delete a dead instruction which has lifetime ending ops,
// we need to insert destroys of ops to end their lifetime correctly
// CHECK-LABEL: sil [ossa] @dce_insertdestroy1 :
// CHECK:         struct
// CHECK-LABEL: } // end sil function 'dce_insertdestroy1'
sil [ossa] @dce_insertdestroy1 : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = copy_value %0 : $Klass
  %func = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %funcres = apply %func(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  %3 = struct $NonTrivialStruct(%1 : $Klass)
  destroy_value %3 : $NonTrivialStruct
  destroy_value %0 : $Klass
  %res = tuple ()
  return %res : $()
}

// This test shows that when we delete a dead phi arg and its incoming values are live,
// we need to insert destroys of the incoming values in its pred blocks.
// CHECK-LABEL: sil [ossa] @dce_insertdestroy2 :
// CHECK:       bb3({{.*}}):
// CHECK-NEXT:    destroy_value
// CHECK-LABEL: } // end sil function 'dce_insertdestroy2'
sil [ossa] @dce_insertdestroy2 : $@convention(thin) (@guaranteed Klass) -> @error any Error {
bb0(%0 : @guaranteed $Klass):
  %2 = function_ref @$testtryapplyklassgen : $@convention(thin) () -> (@owned Klass, @error any Error)
  try_apply %2() : $@convention(thin) () -> (@owned Klass, @error any Error), normal bb1, error bb2

bb1(%3 : @owned $Klass):
  br bb3(%3 : $Klass)

bb2(%4 : $Error):
  throw %4 : $Error

bb3(%5 : @owned $Klass):
  destroy_value %5 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_multiplerevdepdests :
// CHECK:         destroy_value
// CHECK-LABEL: } // end sil function 'dce_multiplerevdepdests'
sil [ossa] @dce_multiplerevdepdests : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  br bb1(%1 : $Klass)

bb1(%2 : @owned $Klass):
  cond_br undef, bb2, bb3

bb2:
  destroy_value %2 : $Klass
  br bb4

bb3:
  destroy_value %2 : $Klass
  br bb4

bb4:
  %res = tuple()
  return %res : $()
}

struct TestStruct {
  var val:Klass
  var index:Int
}

// CHECK-LABEL: sil [ossa] @dce_destructurenotfullydead :
// CHECK-NOT: copy_value
// CHECK-LABEL: } // end sil function 'dce_destructurenotfullydead'
sil [ossa] @dce_destructurenotfullydead : $@convention(thin) (@owned TestStruct) -> Int {
bb0(%0 : @owned $TestStruct):
  %stk = alloc_stack $TestStruct
  store %0 to [init] %stk : $*TestStruct
  %copy = load [take] %stk : $*TestStruct
  (%2, %3) = destructure_struct %copy : $TestStruct
  %4 = struct $TestStruct (%2 : $Klass, %3 : $Int)
  destroy_value %4 : $TestStruct
  dealloc_stack %stk : $*TestStruct
  return %3 : $Int
}

// CHECK-LABEL: sil [ossa] @dce_borrowlifetime1 :
// CHECK: bb1([[ARG1:%.*]] : @owned $NonTrivialStruct, [[ARG2:%.*]] : @reborrow $NonTrivialStruct):
// CHECK-LABEL: } // end sil function 'dce_borrowlifetime1'
sil [ossa] @dce_borrowlifetime1 : $@convention(thin) (@guaranteed NonTrivialStruct) -> @owned NonTrivialStruct {
bb0(%0 : @guaranteed $NonTrivialStruct):
  %1 = copy_value %0
  %2 = begin_borrow %1
  br bb1(%1, %2)

bb1(%4 : @owned $NonTrivialStruct, %5 : @reborrow $NonTrivialStruct):
  %6 = borrowed %5 from (%4)
  %7 = copy_value %6
  end_borrow %6
  destroy_value %4
  return %7
}

// CHECK-LABEL: sil [ossa] @dce_borrowlifetime2 :
// CHECK:       bb1({{.*}}):
// CHECK-LABEL: } // end sil function 'dce_borrowlifetime2'
sil [ossa] @dce_borrowlifetime2 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0
  %2 = begin_borrow %1
  %3 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %4 = apply %3(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  %5 = apply %3(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%1, %2)

bb1(%7 : @owned $Klass, %8 : @reborrow $Klass):
  %9 = borrowed %8 from (%7)
  end_borrow %9
  destroy_value %7
  %12 = tuple ()
  return %12
}

// CHECK-LABEL: sil [ossa] @dce_borrowlifetime3 :
// CHECK:       bb1({{.*}}):
// CHECK-LABEL: } // end sil function 'dce_borrowlifetime3'
sil [ossa] @dce_borrowlifetime3 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0
  %2 = begin_borrow %1
  %3 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %4 = apply %3(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  %5 = apply %3(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%2, %1)

bb1(%7 : @reborrow $Klass, %8 : @owned $Klass):
  %9 = borrowed %7 from (%8)
  end_borrow %9
  destroy_value %8
  %12 = tuple ()
  return %12
}

// CHECK-LABEL: sil [ossa] @dce_borrowlifetime4 :
// CHECK: bb1:
// CHECK-LABEL: } // end sil function 'dce_borrowlifetime4'
sil [ossa] @dce_borrowlifetime4 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0
  %2 = begin_borrow %1
  %3 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %4 = apply %3(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  %5 = apply %3(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%2)

bb1(%7 : @reborrow $Klass):
  %8 = borrowed %7 from (%1)
  end_borrow %8
  br bb2(%1)

bb2(%11 : @owned $Klass):
  destroy_value %11
  %13 = tuple ()
  return %13
}

// CHECK-LABEL: sil [ossa] @dce_borrowlifetime5 :
// CHECK:         bb1({{.*}}):
// CHECK-LABEL: } // end sil function 'dce_borrowlifetime5'
sil [ossa] @dce_borrowlifetime5 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0
  %2 = copy_value %0
  %3 = begin_borrow %1
  %4 = begin_borrow %2
  %5 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %6 = apply %5(%3) : $@convention(thin) (@guaranteed Klass) -> ()
  %7 = apply %5(%4) : $@convention(thin) (@guaranteed Klass) -> ()
  %8 = apply %5(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  %9 = apply %5(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%1, %3, %4)

bb1(%11 : @owned $Klass, %12 : @reborrow $Klass, %13 : @reborrow $Klass):
  %14 = borrowed %13 from (%2)
  %15 = borrowed %12 from (%11)
  end_borrow %15
  end_borrow %14
  destroy_value %11
  destroy_value %2
  %20 = tuple ()
  return %20
}

// Nested borrows are currently not optimized in DCE
sil [ossa] @dce_nestedborrowlifetime1 : $@convention(thin) (@guaranteed NonTrivialStruct) -> @owned NonTrivialStruct {
bb0(%0 : @guaranteed $NonTrivialStruct):
  %1 = begin_borrow %0
  %2 = begin_borrow %1
  br bb1(%1, %2)

bb1(%4 : @reborrow $NonTrivialStruct, %5 : @reborrow $NonTrivialStruct):
  %6 = borrowed %5 from (%4)
  %7 = borrowed %4 from (%0)
  %8 = copy_value %6
  end_borrow %6
  end_borrow %7
  return %8
}

sil [ossa] @dce_nestedborrowlifetime2 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = begin_borrow %0
  %2 = begin_borrow %1

  %3 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %4 = apply %3(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  %5 = apply %3(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%1, %2)

bb1(%7 : @reborrow $Klass, %8 : @reborrow $Klass):
  %9 = borrowed %8 from (%7)
  %10 = borrowed %7 from (%0)
  end_borrow %9
  end_borrow %10
  %13 = tuple ()
  return %13
}

// This test shows it is non trivial to find the insert point of an outer reborrow.
// Here %newborrowo and %newborrowi are both dead phis.
// First end_borrow for the incoming value of %newborrowi is added
// It is non straight forward to find the insert pt for the end_borrow of the incoming value of %newborrowo
// This may not be important once OSSACanonicalizeOwned supports rewrite of multi-block borrows.
sil [ossa] @dce_nestedborrowlifetime3 : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = begin_borrow %0
  %2 = begin_borrow %1
  %3 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %4 = apply %3(%2) : $@convention(thin) (@guaranteed Klass) -> ()
  %5 = apply %3(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%2, %1)

bb1(%7 : @reborrow $Klass, %8 : @reborrow $Klass):
  %9 = borrowed %8 from (%0)
  %10 = borrowed %7 from (%8)
  end_borrow %10
  end_borrow %9
  %13 = tuple ()
  return %13
}


sil [ossa] @dce_nestedborrowlifetime4 : $@convention(thin) (@guaranteed Wrapper1, @guaranteed Wrapper1) -> () {
bb0(%0 : @guaranteed $Wrapper1, %1 : @guaranteed $Wrapper1):
  cond_br undef, bb1, bb2

bb1:
  %3 = begin_borrow %0
  %4 = struct_extract %3, #Wrapper1.val1
  %5 = struct_extract %4, #Wrapper2.val2
  br bb3(%5, %3)

bb2:
  %7 = begin_borrow %1
  %8 = struct_extract %7, #Wrapper1.val1
  %9 = struct_extract %8, #Wrapper2.val2
  br bb3(%9, %7)

bb3(%11 : @guaranteed $Klass, %12 : @reborrow $Wrapper1):
  %13 = borrowed %12 from (%1, %0)
  %14 = borrowed %11 from (%12)
  %15 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %16 = apply %15(%14) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %13
  %18 = tuple ()
  return %18
}

sil [ossa] @dce_nestedborrowlifetime5 : $@convention(thin) (@guaranteed Wrapper1) -> () {
bb0(%0 : @guaranteed $Wrapper1):
  %1 = begin_borrow %0
  %2 = begin_borrow %1
  %3 = struct_extract %2, #Wrapper1.val1
  %4 = struct_extract %3, #Wrapper2.val2
  br bb1(%4, %2)

bb1(%6 : @guaranteed $Klass, %7 : @reborrow $Wrapper1):
  %8 = borrowed %7 from (%1)
  %9 = borrowed %6 from (%7)
  %10 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %11 = apply %10(%9) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %8
  end_borrow %1
  %14 = tuple ()
  return %14
}

// CHECK-LABEL: sil [ossa] @infinite_loop :
// CHECK-LABEL: } // end sil function 'infinite_loop'
sil [ossa] @infinite_loop : $@convention(thin) (@guaranteed NonTrivialStruct, @guaranteed NonTrivialStruct) -> () {
bb0(%0 : @guaranteed $NonTrivialStruct, %1 : @guaranteed $NonTrivialStruct):
  cond_br undef, bb1, bb5

bb1:
  %3 = copy_value %0
  %4 = begin_borrow %3
  br bb2(%4, %3)

bb2(%6 : @guaranteed $NonTrivialStruct, %7 : @owned $NonTrivialStruct):
  %8 = borrowed %6 from (%7)
  cond_br undef, bb3, bb4

bb3:
  br bb2(%8, %7)

bb4:
  end_borrow %8
  destroy_value [dead_end] %7
  unreachable

bb5:
  %10 = tuple ()
  return %10
}

// CHECK-LABEL: sil [ossa] @dce_reborrow_with_different_basevalues :
// CHECK: bb3([[ARG1:%.*]] : @reborrow $NonTrivialStruct, [[ARG2:%.*]] : @owned $NonTrivialStruct, [[ARG3:%.*]] : @owned $NonTrivialStruct):
// CHECK-LABEL: } // end sil function 'dce_reborrow_with_different_basevalues'
sil [ossa] @dce_reborrow_with_different_basevalues : $@convention(thin) (@guaranteed NonTrivialStruct, @guaranteed NonTrivialStruct) -> @owned NonTrivialStruct {
bb0(%0 : @guaranteed $NonTrivialStruct, %1 : @guaranteed $NonTrivialStruct):
  cond_br undef, bb1, bb2

bb1:
  %3 = copy_value %0
  %4 = begin_borrow %3
  %5 = copy_value %1
  br bb3(%4, %3, %5)

bb2:
  %7 = copy_value %1
  %8 = begin_borrow %7
  %9 = copy_value %0
  br bb3(%8, %9, %7)

bb3(%11 : @reborrow $NonTrivialStruct, %12 : @owned $NonTrivialStruct, %13 : @owned $NonTrivialStruct):
  %14 = borrowed %11 from (%13, %12)
  %15 = copy_value %14
  end_borrow %14
  destroy_value %12
  destroy_value %13
  return %15
}

// CHECK-LABEL: sil [ossa] @dce_deadterm1 :
// CHECK:         switch_enum
// CHECK-LABEL: } // end sil function 'dce_deadterm1'
sil [ossa] @dce_deadterm1 : $@convention(thin) (@owned FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : @owned $FakeOptional<Builtin.NativeObject>):
  %0a = alloc_stack $FakeOptional<Builtin.NativeObject>
  store %0 to [init] %0a : $*FakeOptional<Builtin.NativeObject>
  %1 = load [take] %0a : $*FakeOptional<Builtin.NativeObject>
  switch_enum %1 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt: bb1, case #FakeOptional.none!enumelt: bb2

bb1(%2 : @owned $Builtin.NativeObject):
  destroy_value %2 : $Builtin.NativeObject
  br bb3

bb2:
  br bb3

bb3:
  dealloc_stack %0a : $*FakeOptional<Builtin.NativeObject>
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadterm2 :
// CHECK:         load [copy]
// CHECK:         switch_enum
// CHECK-LABEL: } // end sil function 'dce_deadterm2'
sil [ossa] @dce_deadterm2 : $@convention(thin) (@owned FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : @owned $FakeOptional<Builtin.NativeObject>):
  %0a = alloc_stack $FakeOptional<Builtin.NativeObject>
  store %0 to [init] %0a : $*FakeOptional<Builtin.NativeObject>
  %1 = load [copy] %0a : $*FakeOptional<Builtin.NativeObject>
  switch_enum %1 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt: bb1, case #FakeOptional.none!enumelt: bb2

bb1(%2 : @owned $Builtin.NativeObject):
  destroy_value %2 : $Builtin.NativeObject
  br bb3

bb2:
  br bb3

bb3:
  destroy_addr %0a :  $*FakeOptional<Builtin.NativeObject>
  dealloc_stack %0a : $*FakeOptional<Builtin.NativeObject>
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadendlifetime1 :
// CHECK: end_lifetime
// CHECK-LABEL: } // end sil function 'dce_deadendlifetime1'
sil [ossa] @dce_deadendlifetime1 : $@convention(thin) () -> () {
bb0:
  cond_br undef, bb1, bb2

bb1:
  br bb3(undef : $Klass)

bb2:
  br bb3(undef : $Klass)

bb3(%2 : @owned $Klass):
  end_lifetime %2 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadendlifetime2 :
// CHECK: end_lifetime
// CHECK-LABEL: } // end sil function 'dce_deadendlifetime2'
sil [ossa] @dce_deadendlifetime2 : $@convention(thin) () -> () {
bb0:
  cond_br undef, bb1, bb2

bb1:
  br bb3(undef : $Klass)

bb2:
  br bb3(undef : $Klass)

bb3(%2 : @owned $Klass):
  br bb4(%2 : $Klass)

bb4(%3 : @owned $Klass):
  end_lifetime %3 : $Klass
  %res = tuple ()
  return %res : $()
}

// CHECK-LABEL: sil [ossa] @looping_borrow : $@convention(thin) () -> () {
// CHECK:         destroy_value
// CHECK-LABEL: } // end sil function 'looping_borrow'
sil [ossa] @looping_borrow : $@convention(thin) () -> () {
bb0:
  %0 = enum $FakeOptional<Klass>, #FakeOptional.none!enumelt
  %1 = begin_borrow %0
  br bb1(%0, %1)

bb1(%3 : @owned $FakeOptional<Klass>, %4 : @reborrow $FakeOptional<Klass>):
  %5 = borrowed %4 from ()
  br bb2

bb2:
  cond_br undef, bb3, bb4

bb3:
  br bb1(%3, %5)

bb4:
  end_borrow %5
  destroy_value %3
  br bb5

bb5:
  %12 = tuple ()
  return %12
}

// CHECK-LABEL: sil hidden [ossa] @add_end_borrow_after_destroy_value : {{.*}} {
// CHECK:       bb0({{%[^,]+}} : $Builtin.Int1, [[INSTANCE_1:%[^,]+]] : @owned $Klass, {{%[^,]+}} : @owned $Klass):
// CHECK:         [[LIFETIME_1:%[^,]+]] = begin_borrow [[INSTANCE_1]]
// CHECK:         copy_value [[LIFETIME_1]]
// CHECK:         cond_br {{%[^,]+}}, [[LEFT:bb[0-9]+]], [[RIGHT:bb[0-9]+]]
// CHECK:       [[LEFT]]:
// CHECK:         end_borrow [[LIFETIME_1]]
// CHECK:         destroy_value [[INSTANCE_1]]
// CHECK:       [[RIGHT]]:
// CHECK:         end_borrow [[LIFETIME_1]]
// CHECK:         destroy_value [[INSTANCE_1]]
// CHECK-LABEL: } // end sil function 'add_end_borrow_after_destroy_value'
sil hidden [ossa] @add_end_borrow_after_destroy_value : $@convention(thin) (Builtin.Int1, @owned Klass, @owned Klass) -> () {
bb0(%0 : $Builtin.Int1, %1 : @owned $Klass, %2 : @owned $Klass):
  %3 = begin_borrow %1
  %4 = copy_value %3
  %5 = alloc_stack $Klass
  store %4 to [init] %5
  destroy_addr %5
  dealloc_stack %5
  cond_br %0, bb1, bb2

bb1:
  end_borrow %3
  destroy_value %1
  %12 = begin_borrow %2
  br bb3(%2, %12)

bb2:
  destroy_value %2
  br bb3(%1, %3)

bb3(%16 : @owned $Klass, %17 : @reborrow $Klass):
  %18 = borrowed %17 from (%16)
  end_borrow %18
  destroy_value %16
  %21 = tuple ()
  return %21
}

// CHECK-LABEL: sil [ossa] @borrow_none : {{.*}} {
// CHECK:       {{bb[0-9]+}}:
// CHECK-NEXT:    br [[EXIT:bb[0-9]+]]
// CHECK:       [[EXIT]]:
// CHECK-NEXT:    [[RETVAL:%[^,]+]] = tuple ()
// CHECK-NEXT:    return [[RETVAL]] : $()
// CHECK-LABEL: } // end sil function 'borrow_none'
sil [ossa] @borrow_none : $@convention(thin) () -> () {
entry:
  %outer_lifetime_1 = enum $FakeOptional<Klass>, #FakeOptional.none!enumelt
  switch_enum %outer_lifetime_1 : $FakeOptional<Klass>, case #FakeOptional.some!enumelt: work, case #FakeOptional.none!enumelt: to_exit, forwarding: @guaranteed
to_exit:
  br exit
work(%outer_lifetime_2 : @guaranteed $Klass):
  %inner_lifetime_1 = begin_borrow %outer_lifetime_2 : $Klass
  end_borrow %inner_lifetime_1 : $Klass
  br exit
exit:
  %retval = tuple ()
  return %retval : $()
}

// CHECK-LABEL: sil [ossa] @reborrowed_begin_borrow : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[INSTANCE:%[^,]+]] : @owned $Klass):
// CHECK:         [[OUTER_LIFETIME_1:%[^,]+]] = begin_borrow [[INSTANCE]]
// CHECK:         br [[EXIT:bb[0-9]+]]([[OUTER_LIFETIME_1]] : $Klass)
// CHECK:       [[EXIT]]([[OUTER_LIFETIME_2:%[^,]+]] : @reborrow $Klass):
// CHECK:         [[R:%.*]] = borrowed [[OUTER_LIFETIME_2]] : $Klass from (%0 : $Klass)
// CHECK:         end_borrow [[R]]
// CHECK:         destroy_value [[INSTANCE]]
// CHECK:         [[RETVAL:%[^,]+]] = tuple ()
// CHECK:         return [[RETVAL]]
// CHECK-LABEL: } // end sil function 'reborrowed_begin_borrow'
sil [ossa] @reborrowed_begin_borrow : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = begin_borrow %0
  %2 = begin_borrow %1
  br bb1(%1, %2)

bb1(%4 : @reborrow $Klass, %5 : @reborrow $Klass):
  %6 = borrowed %5 from (%4)
  %7 = borrowed %4 from (%0)
  end_borrow %6
  end_borrow %7
  destroy_value %0
  %11 = tuple ()
  return %11
}

// CHECK-LABEL: sil [ossa] @reborrowed_guaranteed_phi : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[INSTANCE:%[^,]+]] : @owned $Klass):
// CHECK:         [[LIFETIME:%[^,]+]] = begin_borrow [[INSTANCE]]
// CHECK:         br [[WORK:bb[0-9]+]]([[LIFETIME]] : $Klass)
// CHECK:       [[WORK]]([[LIFETIME_1:%[^,]+]] : @reborrow $Klass):
// CHECK:         [[R:%.*]] = borrowed [[LIFETIME_1]] : $Klass from (%0 : $Klass)
// CHECK:         br [[EXIT:bb[0-9]+]]([[R]] : $Klass)
// CHECK:       [[EXIT]]([[LIFETIME_2:%[^,]+]] : @reborrow $Klass):
// CHECK:         [[R2:%.*]] = borrowed [[LIFETIME_2]] : $Klass from (%0 : $Klass)
// CHECK:         end_borrow [[R2]]
// CHECK:         destroy_value [[INSTANCE]]
// CHECK:         [[RETVAL:%[^,]+]] = tuple ()
// CHECK:         return [[RETVAL]] : $()
// CHECK-LABEL: } // end sil function 'reborrowed_guaranteed_phi'
sil [ossa] @reborrowed_guaranteed_phi : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = begin_borrow %0
  br bb1(%1)

bb1(%3 : @reborrow $Klass):
  %4 = borrowed %3 from (%0)
  %5 = begin_borrow %4
  br bb2(%4, %5)

bb2(%7 : @reborrow $Klass, %8 : @reborrow $Klass):
  %9 = borrowed %8 from (%7)
  %10 = borrowed %7 from (%0)
  end_borrow %9
  end_borrow %10
  destroy_value %0
  %14 = tuple ()
  return %14
}

// CHECK-LABEL: sil [ossa] @reborrow_guaranteed_phi2 : {{.*}} {
// CHECK:         switch_enum
// CHECK-LABEL: } // end sil function 'reborrow_guaranteed_phi2'
sil [ossa] @reborrow_guaranteed_phi2 : $@convention(thin) (@owned EitherNoneOrAnyObject) -> () {
entry(%0 : @owned $EitherNoneOrAnyObject):
  %borrow_either = begin_borrow %0 : $EitherNoneOrAnyObject
  switch_enum %borrow_either : $EitherNoneOrAnyObject, case #EitherNoneOrAnyObject.none!enumelt: none_block, case #EitherNoneOrAnyObject.any!enumelt: any_block

any_block(%borrow : @guaranteed $AnyObject):
  %2 = begin_borrow %borrow : $AnyObject
  end_borrow %2 : $AnyObject
  end_borrow %borrow_either : $EitherNoneOrAnyObject
  destroy_value %0 : $EitherNoneOrAnyObject
  br exit

none_block:
  end_borrow %borrow_either : $EitherNoneOrAnyObject
  destroy_value %0 : $EitherNoneOrAnyObject
  br exit

exit:
  %retval = tuple ()
  return %retval : $()
}

// CHECK-LABEL: sil [ossa] @reborrowed_guaranteed_phi3 :
// CHECK: begin_borrow
// CHECK-NOT: begin_borrow
// CHECK-LABEL: } // end sil function 'reborrowed_guaranteed_phi3'
sil [ossa] @reborrowed_guaranteed_phi3 : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = begin_borrow %0
  %2 = begin_borrow %1
  br bb1(%2)

bb1(%4 : @reborrow $Klass):
  %5 = borrowed %4 from (%1)
  end_borrow %5
  end_borrow %1
  destroy_value %0
  %9 = tuple ()
  return %9
}

// CHECK-LABEL: sil [ossa] @reborrow_load_borrow : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[INSTANCE:%[^,]+]] : $*Klass):
// CHECK:         [[LIFETIME:%[^,]+]] = load_borrow [[INSTANCE]]
// CHECK:         br [[BASIC_BLOCK1:bb[0-9]+]]([[LIFETIME]] : $Klass)
// CHECK:       [[BASIC_BLOCK1]]([[LIFETIME_2:%[^,]+]] : @reborrow $Klass):
// CHECK:         [[R:%.*]] = borrowed [[LIFETIME_2]] : $Klass from ()
// CHECK:         end_borrow [[R]]
// CHECK:         [[RETVAL:%[^,]+]] = tuple ()
// CHECK:         return [[RETVAL]]
// CHECK-LABEL: } // end sil function 'reborrow_load_borrow'
sil [ossa] @reborrow_load_borrow : $@convention(method) (@in Klass) -> () {
bb0(%0 : $*Klass):
  %1 = load_borrow %0
  %2 = begin_borrow %1
  br bb1(%1, %2)

bb1(%4 : @reborrow $Klass, %5 : @reborrow $Klass):
  %6 = borrowed %5 from (%4)
  %7 = borrowed %4 from ()
  end_borrow %6
  end_borrow %7
  %10 = tuple ()
  return %10
}

// CHECK-LABEL: sil [ossa] @reborrow_load_borrow2 : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[ADDR:%[^,]+]] : $*Klass):
// CHECK:         [[LIFETIME:%[^,]+]] = load_borrow [[ADDR]] : $*Klass
// CHECK:         br [[EXIT:bb[0-9]+]]([[LIFETIME]] : $Klass)
// CHECK:       [[EXIT]]([[LIFETIME_2:%[^,]+]] : @reborrow $Klass):
// CHECK:         [[R:%.*]] = borrowed [[LIFETIME_2]] : $Klass from ()
// CHECK:         end_borrow [[R]] : $Klass
// CHECK:         [[EXIT:%[^,]+]] = tuple ()
// CHECK:         return [[EXIT]] : $()
// CHECK-LABEL: } // end sil function 'reborrow_load_borrow2'
sil [ossa] @reborrow_load_borrow2 : $@convention(method) (@in Klass) -> () {
bb0(%0 : $*Klass):
  %1 = load_borrow %0
  %2 = begin_borrow %1
  br bb1(%2, %1)

bb1(%4 : @reborrow $Klass, %5 : @reborrow $Klass):
  %6 = borrowed %5 from ()
  %7 = borrowed %4 from (%5)
  end_borrow %7
  end_borrow %6
  %10 = tuple ()
  return %10
}

class Wrapper {
  let val: Klass
}

class DoubleWrapper {
  let s: StructWrapper
}

struct StructWrapper {
  let val: Klass
}

// CHECK-LABEL: sil [ossa] @reborrow_load_borrow3 : $@convention(method) (@owned Wrapper) -> () {
// CHECK: load_borrow
// CHECK: end_borrow
// CHECK: br bb1
// CHECK-LABEL: } // end sil function 'reborrow_load_borrow3'
sil [ossa] @reborrow_load_borrow3 : $@convention(method) (@owned Wrapper) -> () {
bb0(%0 : @owned $Wrapper):
  %1 = begin_borrow %0
  %2 = ref_element_addr %1, #Wrapper.val
  %3 = load_borrow %2
  %4 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %5 = apply %4(%3) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%1, %3)

bb1(%7 : @reborrow $Wrapper, %8 : @reborrow $Klass):
  %9 = borrowed %8 from ()
  %10 = borrowed %7 from (%0)
  end_borrow %9
  end_borrow %10
  destroy_value %0
  %14 = tuple ()
  return %14
}

// CHECK-LABEL: sil [ossa] @reborrow_load_borrow4 : $@convention(method) (@owned DoubleWrapper) -> () {
// CHECK: load_borrow
// CHECK: end_borrow
// CHECK: br bb1
// CHECK-LABEL: } // end sil function 'reborrow_load_borrow4'
sil [ossa] @reborrow_load_borrow4 : $@convention(method) (@owned DoubleWrapper) -> () {
bb0(%0 : @owned $DoubleWrapper):
  %1 = begin_borrow %0
  %2 = ref_element_addr %1, #DoubleWrapper.s
  %3 = struct_element_addr %2, #StructWrapper.val
  %4 = load_borrow %3
  %5 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %6 = apply %5(%4) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb1(%1, %4)

bb1(%8 : @reborrow $DoubleWrapper, %9 : @reborrow $Klass):
  %10 = borrowed %9 from ()
  %11 = borrowed %8 from (%0)
  end_borrow %10
  end_borrow %11
  destroy_value %0
  %15 = tuple ()
  return %15
}

// CHECK-LABEL: sil [ossa] @borrow_guaranteed_tuple : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[INSTANCE_1:%[^,]+]] : @owned $Klass, [[INSTANCE_2:%[^,]+]] : @owned $Klass):
// CHECK:         destroy_value [[INSTANCE_2]]
// CHECK:         destroy_value [[INSTANCE_1]]
// CHECK:         [[RETVAL:%[^,]+]] = tuple ()
// CHECK:         return [[RETVAL]] : $()
// CHECK-LABEL: } // end sil function 'borrow_guaranteed_tuple'
sil [ossa] @borrow_guaranteed_tuple : $@convention(thin) (@owned Klass, @owned Klass) -> () {
bb0(%0 : @owned $Klass, %1 : @owned $Klass):
  %2 = begin_borrow %0
  %3 = begin_borrow %1
  %4 = tuple (%2, %3)
  br bb1(%2, %3, %4)

bb1(%6 : @reborrow $Klass, %7 : @reborrow $Klass, %8 : @guaranteed $(Klass, Klass)):
  %9 = borrowed %8 from (%7, %6)
  %10 = borrowed %7 from (%1)
  %11 = borrowed %6 from (%0)
  end_borrow %10
  destroy_value %1
  end_borrow %11
  destroy_value %0
  %16 = tuple ()
  return %16
}

// CHECK-LABEL: sil [ossa] @borrow_guaranteed_struct : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[INSTANCE:%[^,]+]] : @owned $Klass):
// CHECK:         destroy_value [[INSTANCE]]
// CHECK:         [[RETVAL:%[^,]+]] = tuple ()
// CHECK:         return [[RETVAL]] : $()
// CHECK-LABEL: } // end sil function 'borrow_guaranteed_struct'
sil [ossa] @borrow_guaranteed_struct : $@convention(thin) (@owned Klass) -> () {
bb0(%0 : @owned $Klass):
  %1 = begin_borrow %0
  %2 = struct $NonTrivialStruct (%1)
  br bb1(%1, %2)

bb1(%4 : @reborrow $Klass, %5 : @guaranteed $NonTrivialStruct):
  %6 = borrowed %5 from (%4)
  %7 = borrowed %4 from (%0)
  end_borrow %7
  destroy_value %0
  %10 = tuple ()
  return %10
}

sil [ossa] @testBorrowedSwitch : $@convention(thin) (Optional<@sil_unmanaged AnyObject>) -> () {
bb0(%0 : $Optional<@sil_unmanaged AnyObject>):
  switch_enum %0 : $Optional<@sil_unmanaged AnyObject>, case #Optional.some!enumelt: bb1, case #Optional.none!enumelt: bb2

bb1(%2 : $@sil_unmanaged AnyObject):
  %3 = unmanaged_to_ref %2 : $@sil_unmanaged AnyObject to $AnyObject
  %4 = unchecked_ownership_conversion %3 : $AnyObject, @unowned to @guaranteed
  %5 = begin_borrow [lexical] %4 : $AnyObject
  end_borrow %5 : $AnyObject
  end_borrow %4 : $AnyObject
  br bb3

bb2:
  br bb3

bb3:
  %242 = tuple ()
  return %242 : $()
}

// rdar://87985420 - crash in nullptr returned by findGuaranteedReferenceRoots
// Test that a borrow scope introduced by unchecked_ownership_conversion is not
// deleted by DCE.
sil [ossa] @testUncheckedConvertToGuaranteed : $@convention(thin) (@sil_unmanaged AnyObject) -> () {
bb0(%0 : $@sil_unmanaged AnyObject):
  %3 = unmanaged_to_ref %0 : $@sil_unmanaged AnyObject to $AnyObject
  %4 = unchecked_ownership_conversion %3 : $AnyObject, @unowned to @guaranteed
  %5 = begin_borrow [lexical] %4 : $AnyObject
  end_borrow %5 : $AnyObject
  end_borrow %4 : $AnyObject
  %242 = tuple ()
  return %242 : $()
}

sil @foo : $@convention(thin) () -> ()

// CHECK-LABEL: sil [ossa] @test_escape1 : {{.*}} {
// CHECK: br bb1
// CHECK: end_borrow
// CHECK-LABEL: } // end sil function 'test_escape1'
sil [ossa] @test_escape1 : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @foo : $@convention(thin) () -> ()
  %1 = partial_apply [callee_guaranteed] %0() : $@convention(thin) () -> ()
  %2 = convert_escape_to_noescape %1 to $@noescape @callee_guaranteed () -> ()
  %3 = begin_borrow %1
  %4 = mark_dependence %2 on %3
  br bb1(%4, %3, %1)

bb1(%6 : @owned $@noescape @callee_guaranteed () -> (), %7 : @reborrow $@callee_guaranteed () -> (), %8 : @owned $@callee_guaranteed () -> ()):
  %9 = borrowed %7 from (%8)
  %10 = apply %6() : $@noescape @callee_guaranteed () -> ()
  destroy_value %6
  end_borrow %9
  destroy_value %8
  %14 = tuple ()
  return %14
}

// CHECK-LABEL: sil [ossa] @test_escape2 : {{.*}} {
// CHECK: br bb1
// CHECK: destroy_value
// CHECK: destroy_value
// CHECK-LABEL: } // end sil function 'test_escape2'
sil [ossa] @test_escape2 : $@convention(thin) () -> () {
bb0:
  %13 = function_ref @foo : $@convention(thin) () -> ()
  %14 = partial_apply [callee_guaranteed] %13() : $@convention(thin) () -> ()
  %15 = convert_escape_to_noescape %14 : $@callee_guaranteed () -> () to $@noescape @callee_guaranteed () -> ()
  %18 = mark_dependence %15 : $@noescape @callee_guaranteed () -> () on %14 : $@callee_guaranteed () -> ()
  br bb1(%18 : $@noescape @callee_guaranteed () -> (), %14 : $@callee_guaranteed () -> ())

bb1(%21 : @owned $@noescape @callee_guaranteed () -> (), %23 : @owned $@callee_guaranteed () -> ()):
  %27 = apply %21() : $@noescape @callee_guaranteed () -> ()
  destroy_value %21 : $@noescape @callee_guaranteed () -> ()
  destroy_value %23 : $@callee_guaranteed () -> ()
  %28 = tuple ()
  return %28: $()
}

sil @use_klass : $@convention(thin) (@guaranteed Klass) -> ()

// CHECK-LABEL: sil [ossa] @test_forwarded_phi1 :
// CHECK: br bb3
// CHECK: end_borrow
// CHECK-LABEL: } // end sil function 'test_forwarded_phi1'
sil [ossa] @test_forwarded_phi1 : $@convention(thin) (@owned Wrapper1) -> () {
bb0(%0 : @owned $Wrapper1):
  %1 = begin_borrow %0
  br bb1

bb1:
  %3 = struct_extract %1, #Wrapper1.val1
  br bb2(%3, %1)

bb2(%5 : @guaranteed $Wrapper2, %6 : @reborrow $Wrapper1):
  %7 = borrowed %6 from (%0)
  %8 = borrowed %5 from (%6)
  %9 = struct_extract %8, #Wrapper2.val2
  br bb3(%9, %7)

bb3(%11 : @guaranteed $Klass, %12 : @reborrow $Wrapper1):
  %13 = borrowed %12 from (%0)
  %14 = borrowed %11 from (%12)
  %15 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %16 = apply %15(%14) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %13
  destroy_value %0
  %19 = tuple ()
  return %19
}

// CHECK-LABEL: sil [ossa] @test_forwarded_phi2 :
// CHECK: br bb3
// CHECK: end_borrow
// CHECK-LABEL: } // end sil function 'test_forwarded_phi2'
sil [ossa] @test_forwarded_phi2 : $@convention(thin) (@owned Wrapper1) -> () {
bb0(%0 : @owned $Wrapper1):
  %1 = begin_borrow %0
  br bb1

bb1:
  br bb2(%1)

bb2(%4 : @reborrow $Wrapper1):
  %5 = borrowed %4 from (%0)
  %6 = struct_extract %5, #Wrapper1.val1
  %7 = struct_extract %6, #Wrapper2.val2
  br bb3(%7, %5)

bb3(%9 : @guaranteed $Klass, %10 : @reborrow $Wrapper1):
  %11 = borrowed %10 from (%0)
  %12 = borrowed %9 from (%10)
  %13 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %14 = apply %13(%12) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %11
  destroy_value %0
  %17 = tuple ()
  return %17
}

// CHECK-LABEL: sil [ossa] @test_forwarded_phi3 :
// CHECK: end_borrow
// CHECK: br bb3
// CHECK-LABEL: } // end sil function 'test_forwarded_phi3'
sil [ossa] @test_forwarded_phi3 : $@convention(thin) (@owned Wrapper1) -> () {
bb0(%0 : @owned $Wrapper1):
  %1 = begin_borrow %0
  br bb1

bb1:
  br bb2(%1)

bb2(%4 : @reborrow $Wrapper1):
  %5 = borrowed %4 from (%0)
  %6 = struct_extract %5, #Wrapper1.val1
  %7 = struct_extract %6, #Wrapper2.val2
  %8 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %9 = apply %8(%7) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb3(%7, %5)

bb3(%11 : @guaranteed $Klass, %12 : @reborrow $Wrapper1):
  %13 = borrowed %12 from (%0)
  %14 = borrowed %11 from (%12)
  end_borrow %13
  destroy_value %0
  %17 = tuple ()
  return %17
}

// CHECK-LABEL: sil [ossa] @test_loadborrow_dep :
// CHECK: br bb3
// CHECK: end_borrow
// CHECK-LABEL: } // end sil function 'test_loadborrow_dep'
sil [ossa] @test_loadborrow_dep : $@convention(thin) (@in Wrapper1) -> () {
bb0(%0 : $*Wrapper1):
  %1 = load_borrow %0
  br bb1

bb1:
  %3 = struct_extract %1, #Wrapper1.val1
  br bb2(%3, %1)

bb2(%5 : @guaranteed $Wrapper2, %6 : @reborrow $Wrapper1):
  %7 = borrowed %6 from ()
  %8 = borrowed %5 from (%6)
  %9 = struct_extract %8, #Wrapper2.val2
  br bb3(%9, %7)

bb3(%11 : @guaranteed $Klass, %12 : @reborrow $Wrapper1):
  %13 = borrowed %12 from ()
  %14 = borrowed %11 from (%12)
  %15 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %16 = apply %15(%14) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %13
  destroy_addr %0
  %19 = tuple ()
  return %19
}


class C {}

sil [ossa] @getC : $@convention(thin) () -> (@owned C)

// CHECK-LABEL: sil [ossa] @dont_dce_lexical_phi :
// CHECK: destroy_value
// CHECK-LABEL: } // end sil function 'dont_dce_lexical_phi'
sil [ossa] @dont_dce_lexical_phi : $() -> () {
 entry:
   %getC = function_ref @getC : $@convention(thin) () -> (@owned C)
   cond_br undef, left, right
 left:
   %c1 = apply %getC() : $@convention(thin) () -> (@owned C)
   %m1 = move_value [lexical] %c1 : $C
   br exit(%m1 : $C)
 right:
   %c2 = apply %getC() : $@convention(thin) () -> (@owned C)
   br exit(%c2 : $C)
 exit(%cm : @owned $C):
   destroy_value %cm : $C
   %retval = tuple ()
   return %retval : $()
}

class KlassWithDeinit {
  init()
  deinit
}

// DCE should not delete dead allocations, leave it to DOE
// CHECK-LABEL: sil [ossa] @dont_delete_allocation :
// CHECK: alloc_ref
// CHECK-LABEL: } // end sil function 'dont_delete_allocation'
sil [ossa] @dont_delete_allocation : $@convention(thin) () -> () {
bb0:
  %a = alloc_ref $KlassWithDeinit
  destroy_value %a : $KlassWithDeinit
  %t = tuple ()
  return %t : $()
}

// CHECK-LABEL: sil [ossa] @dce_dead_guaranteedphi :
// bb2:
// CHECK-LABEL: } // end sil function 'dce_dead_guaranteedphi'
sil [ossa] @dce_dead_guaranteedphi : $@convention(thin) (@owned NonTrivialStruct) -> () {
bb0(%0 : @owned $NonTrivialStruct):
  %1 = begin_borrow %0
  %2 = function_ref @$use_nontrivialstruct2 : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
  %3 = apply %2(%1) : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
  br bb1(%1, %1)

bb1(%5 : @reborrow $NonTrivialStruct, %6 : @guaranteed $NonTrivialStruct):
  %7 = borrowed %6 from (%0)
  %8 = borrowed %5 from (%0)
  end_borrow %8
  destroy_value %0
  %11 = tuple ()
  return %11
}

// CHECK-LABEL: sil [ossa] @dce_deadterm4 :
// CHECK:         switch_enum
// CHECK-LABEL: } // end sil function 'dce_deadterm4'
sil [ossa] @dce_deadterm4 : $@convention(thin) (@owned FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : @owned $FakeOptional<Builtin.NativeObject>):
  %0a = alloc_stack $FakeOptional<Builtin.NativeObject>
  store %0 to [init] %0a : $*FakeOptional<Builtin.NativeObject>
  %1 = load [take] %0a : $*FakeOptional<Builtin.NativeObject>
  %2 = copy_value %1 : $FakeOptional<Builtin.NativeObject>
  apply undef(%2) : $@convention(thin) (@guaranteed FakeOptional<Builtin.NativeObject>) -> ()
  switch_enum %1 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt: bb1, case #FakeOptional.none!enumelt: bb2

bb1(%3 : @owned $Builtin.NativeObject):
  destroy_value %3 : $Builtin.NativeObject
  br bb3

bb2:
  br bb3

bb3:
  switch_enum %2 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt: bb4, case #FakeOptional.none!enumelt: bb5

bb4(%4 : @owned $Builtin.NativeObject):
  destroy_value %4 : $Builtin.NativeObject
  br bb6

bb5:
  br bb6

bb6:
  dealloc_stack %0a : $*FakeOptional<Builtin.NativeObject>
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadterm5 :
// CHECK:         switch_enum
// CHECK:         switch_enum
// CHECK-LABEL: } // end sil function 'dce_deadterm5'
sil [ossa] @dce_deadterm5 : $@convention(thin) (@owned FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : @owned $FakeOptional<Builtin.NativeObject>):
  %0a = alloc_stack $FakeOptional<Builtin.NativeObject>
  store %0 to [init] %0a : $*FakeOptional<Builtin.NativeObject>
  %1 = load [take] %0a : $*FakeOptional<Builtin.NativeObject>
  %2 = copy_value %1 : $FakeOptional<Builtin.NativeObject>
  apply undef(%2) : $@convention(thin) (@guaranteed FakeOptional<Builtin.NativeObject>) -> ()
  switch_enum %1 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt: bb1, case #FakeOptional.none!enumelt: bb2

bb1(%3 : @owned $Builtin.NativeObject):
  destroy_value %3 : $Builtin.NativeObject
  br bb3

bb2:
  switch_enum %2 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt: bb4, case #FakeOptional.none!enumelt: bb5

bb3:
  destroy_value %2 : $FakeOptional<Builtin.NativeObject>
  br bb6

bb4(%4 : @owned $Builtin.NativeObject):
  destroy_value %4 : $Builtin.NativeObject
  br bb6

bb5:
  br bb6

bb6:
  dealloc_stack %0a : $*FakeOptional<Builtin.NativeObject>
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @dce_deadforwarding :
// CHECK:         cond_br
// CHECK-LABEL: } // end sil function 'dce_deadforwarding'
sil [ossa] @dce_deadforwarding : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1 = copy_value %0 : $Klass
  %func = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %funcres = apply %func(%1) : $@convention(thin) (@guaranteed Klass) -> ()
  cond_br undef, bb1, bb2

bb1:
  %3 = struct $NonTrivialStruct(%1 : $Klass)
  destroy_value %3 : $NonTrivialStruct
  br bb3

bb2:
  %4 = struct $NonTrivialStruct(%1 : $Klass)
  destroy_value %4 : $NonTrivialStruct
  br bb3

bb3:
  %res = tuple ()
  return %res : $()
}

// Ensure no verification error
sil [ossa] @dce_borrowedfromuser : $@convention(thin) (@guaranteed FakeOptional<Klass>) -> () {
bb0(%0 : @guaranteed $FakeOptional<Klass>):
  %1 = copy_value %0
  %2 = begin_borrow %1
  %3 = begin_borrow %1
  br bb1(%2, %3)

bb1(%5 : @reborrow $FakeOptional<Klass>, %6 : @reborrow $FakeOptional<Klass>):
  %7 = borrowed %6 from (%1)
  %8 = borrowed %5 from (%1)
  switch_enum %7, case #FakeOptional.some!enumelt: bb2, case #FakeOptional.none!enumelt: bb3

bb2(%10 : @guaranteed $Klass):
  %11 = function_ref @$use_klass2 : $@convention(thin) (@guaranteed Klass) -> ()
  %12 = apply %11(%10) : $@convention(thin) (@guaranteed Klass) -> ()
  br bb4

bb3:
  br bb4

bb4:
  br bb5(%8, %7)

bb5(%16 : @reborrow $FakeOptional<Klass>, %17 : @reborrow $FakeOptional<Klass>):
  %18 = borrowed %17 from (%1)
  %19 = borrowed %16 from (%1)
  end_borrow %19
  end_borrow %18
  destroy_value %1
  %23 = tuple ()
  return %23
}

