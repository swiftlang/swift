// RUN: %target-sil-opt -sil-print-types -copy-propagation -enable-sil-verify-all %s | %FileCheck %s --check-prefixes=CHECK,CHECK-OPT

// REQUIRES: swift_in_compiler

class X {}

enum FakeOptional<T> {
    case some(T)
    case none
}

sil [ossa] @getX : $@convention(thin) () -> (@owned X)
sil [ossa] @holdX : $@convention(thin) (@guaranteed X) -> () {
  [global:]
}

// CHECK-LABEL: sil [ossa] @nohoist_destroy_over_reborrow_endborrow : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[REBORROW:%[^,]+]] : @reborrow $X, [[VALUE:%[^,]+]] : @owned $X):
// CHECK:         [[BF:%.*]] = borrowed [[REBORROW]] : $X from ([[VALUE]] : $X)
// CHECK:         end_borrow [[BF]]
// CHECK:         destroy_value [[VALUE]]
// CHECK-LABEL: } // end sil function 'nohoist_destroy_over_reborrow_endborrow'
sil [ossa] @nohoist_destroy_over_reborrow_endborrow : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @getX : $@convention(thin) () -> @owned X
  %1 = apply %0() : $@convention(thin) () -> @owned X
  %2 = begin_borrow %1
  br bb1(%2, %1)

bb1(%4 : @reborrow $X, %5 : @owned $X):
  %6 = borrowed %4 from (%5)
  end_borrow %6
  destroy_value %5
  br bb2

bb2:
  %10 = tuple ()
  return %10
}

// CHECK-LABEL: sil [ossa] @hoist_destroy_over_unrelated_endborrow : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[UNRELATED:%[^,]+]] : @reborrow $X, [[VALUE:%[^,]+]] : @owned $X):
// CHECK:         [[BF:%.*]] = borrowed [[UNRELATED]] : $X from (%0 : $X)
// CHECK:         destroy_value [[VALUE]]
// CHECK:         end_borrow [[BF]]
// CHECK-LABEL: } // end sil function 'hoist_destroy_over_unrelated_endborrow'
sil [ossa] @hoist_destroy_over_unrelated_endborrow : $@convention(thin) (@guaranteed X) -> () {
bb0(%0 : @guaranteed $X):
  %1 = function_ref @getX : $@convention(thin) () -> @owned X
  %2 = apply %1() : $@convention(thin) () -> @owned X
  %3 = begin_borrow %0
  br bb1(%3, %2)

bb1(%5 : @reborrow $X, %6 : @owned $X):
  %7 = borrowed %5 from (%0)
  %8 = function_ref @holdX : $@convention(thin) (@guaranteed X) -> ()
  %9 = apply %8(%7) : $@convention(thin) (@guaranteed X) -> ()
  end_borrow %7
  destroy_value %6
  br bb2

bb2:
  %13 = tuple ()
  return %13
}

// CHECK-LABEL: sil [ossa] @nohoist_destroy_over_reborrow_reborrow_endborrow : {{.*}} {
// CHECK:       {{bb[0-9]+}}({{%[^,]+}} : @reborrow $X, {{%[^,]+}} : @owned $X):
// CHECK:       {{bb[0-9]+}}([[REBORROW:%[^,]+]] : @reborrow $X, [[VALUE:%[^,]+]] : @owned $X):
// CHECK:         [[BF:%.*]] = borrowed [[REBORROW]] : $X from ([[VALUE]] : $X)
// CHECK:         end_borrow [[BF]]
// CHECK:         destroy_value [[VALUE]]
// CHECK-LABEL: } // end sil function 'nohoist_destroy_over_reborrow_reborrow_endborrow'
sil [ossa] @nohoist_destroy_over_reborrow_reborrow_endborrow : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @getX : $@convention(thin) () -> @owned X
  %1 = apply %0() : $@convention(thin) () -> @owned X
  %2 = begin_borrow %1
  br bb1(%2, %1)

bb1(%4 : @reborrow $X, %5 : @owned $X):
  %6 = borrowed %4 from (%5)
  br bb2(%6, %5)

bb2(%8 : @reborrow $X, %9 : @owned $X):
  %10 = borrowed %8 from (%9)
  end_borrow %10
  destroy_value %9
  br bb3

bb3:
  %14 = tuple ()
  return %14
}

// CHECK-LABEL: sil [ossa] @hoist_destroy_over_unrelated_reborrow_reborrow_endborrow : {{.*}} {
// CHECK:       {{bb[0-9]+}}({{%[^,]+}} : @reborrow $X, {{%[^,]+}} : @owned $X):
// CHECK:       {{bb[0-9]+}}([[REBORROW:%[^,]+]] : @reborrow $X, [[VALUE:%[^,]+]] : @owned $X):
// CHECK:         [[BF:%.*]] = borrowed [[REBORROW]] : $X from (%0 : $X)
// CHECK:         destroy_value [[VALUE]]
// CHECK:         end_borrow [[BF]]
// CHECK-LABEL: } // end sil function 'hoist_destroy_over_unrelated_reborrow_reborrow_endborrow'
sil [ossa] @hoist_destroy_over_unrelated_reborrow_reborrow_endborrow : $@convention(thin) (@guaranteed X) -> () {
bb0(%0 : @guaranteed $X):
  %1 = function_ref @getX : $@convention(thin) () -> @owned X
  %2 = apply %1() : $@convention(thin) () -> @owned X
  %3 = begin_borrow %0
  br bb1(%3, %2)

bb1(%5 : @reborrow $X, %6 : @owned $X):
  %7 = borrowed %5 from (%0)
  br bb2(%7, %6)

bb2(%9 : @reborrow $X, %10 : @owned $X):
  %11 = borrowed %9 from (%0)
  %12 = function_ref @holdX : $@convention(thin) (@guaranteed X) -> ()
  %13 = apply %12(%11) : $@convention(thin) (@guaranteed X) -> ()
  end_borrow %11
  destroy_value %10
  br bb3

bb3:
  %17 = tuple ()
  return %17
}

// CHECK-LABEL: sil [ossa] @nohoist_destroy_over_forward_reborrow_endborrow : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[REBORROW:%[^,]+]] : @reborrow $X, [[VALUE:%[^,]+]] : @owned $X):
// CHECK:         [[BF:%.*]] = borrowed [[REBORROW]] : $X from ([[VALUE]] : $X)
// CHECK:         end_borrow [[BF]]
// CHECK:         destroy_value [[VALUE]]
// CHECK-LABEL: } // end sil function 'nohoist_destroy_over_forward_reborrow_endborrow'
sil [ossa] @nohoist_destroy_over_forward_reborrow_endborrow : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @getX : $@convention(thin) () -> @owned X
  %1 = apply %0() : $@convention(thin) () -> @owned X
  br bb1(%1)

bb1(%3 : @owned $X):
  %4 = begin_borrow %3
  br bb2(%4, %3)

bb2(%6 : @reborrow $X, %7 : @owned $X):
  %8 = borrowed %6 from (%7)
  end_borrow %8
  destroy_value %7
  br bb3

bb3:
  %12 = tuple ()
  return %12
}

// CHECK-LABEL: sil [ossa] @nohoist_destroy_over_reborrow_loop : {{.*}} {
// CHECK:       {{bb[0-9]+}}([[REBORROW:%[^,]+]] : @reborrow $FakeOptional<X>, [[VALUE:%[^,]+]] : @owned $FakeOptional<X>):
// CHECK:         [[BF:%.*]] = borrowed [[REBORROW]] : $FakeOptional<X> from ([[VALUE]] : $FakeOptional<X>)
// CHECK:         cond_br undef, [[LOOP:bb[0-9]+]], [[BODY:bb[0-9]+]]
// CHECK:       [[LOOP]]:
// CHECK:         end_borrow [[BF]] : $FakeOptional<X>
// CHECK:         destroy_value [[VALUE]] : $FakeOptional<X>
// CHECK:       [[BODY]]:
// CHECK:         end_borrow [[BF]] : $FakeOptional<X>
// CHECK:         destroy_value [[VALUE]] : $FakeOptional<X>
// CHECK-LABEL: } // end sil function 'nohoist_destroy_over_reborrow_loop'
sil [ossa] @nohoist_destroy_over_reborrow_loop : $@convention(thin) () -> () {
bb0:
  %0 = enum $FakeOptional<X>, #FakeOptional.none!enumelt
  %1 = enum $FakeOptional<X>, #FakeOptional.none!enumelt
  %2 = begin_borrow %1
  br bb1(%2, %0)

bb1(%4 : @reborrow $FakeOptional<X>, %5 : @owned $FakeOptional<X>):
  %6 = borrowed %4 from (%5)
  cond_br undef, bb2, bb3

bb2:
  %8 = function_ref @getX : $@convention(thin) () -> @owned X
  %9 = apply %8() : $@convention(thin) () -> @owned X
  end_borrow %6
  destroy_value %5
  %12 = enum $FakeOptional<X>, #FakeOptional.some!enumelt, %9
  %13 = begin_borrow %12
  br bb1(%13, %12)

bb3:
  %15 = tuple ()
  end_borrow %6
  destroy_value %5
  return %15
}

// Ensure that an adjacent reborrow phi being reborrowed doesn't get counted as
// a non-lifetime ending use and extend liveness beyond the instruction where
// the reborrow occurs.
// CHECK-LABEL: sil [ossa] @reborrow_adjacent_to_consume_doesnt_extend_lifetime : {{.*}} {
// CHECK:       bb1([[REBORROW:%[^,]+]] : @reborrow $X, [[VALUE:%[^,]+]] :
// CHECK:         [[R:%.*]] = borrowed [[REBORROW]] : $X from ([[VALUE]] : $X)
// CHECK:       {{bb[0-9]+}}:
// CHECK:         end_borrow [[R]]
// CHECK:         destroy_value [[VALUE]]
// CHECK-LABEL: } // end sil function 'reborrow_adjacent_to_consume_doesnt_extend_lifetime'
sil [ossa] @reborrow_adjacent_to_consume_doesnt_extend_lifetime : $@convention(thin) (@owned X) -> () {
bb0(%0 : @owned $X):
  %1 = begin_borrow %0
  br bb1(%1, %0)

bb1(%3 : @reborrow $X, %4 : @owned $X):
  %5 = borrowed %3 from (%4)
  cond_br undef, bb2, bb10

bb2:
  br bb3

bb3:
  br bb4(%5, %4)

bb4(%9 : @reborrow $X, %10 : @owned $X):
  %11 = borrowed %9 from (%10)
  cond_br undef, bb5, bb8

bb5:
  br bb6

bb6:
  br bb7

bb7:
  %15 = function_ref @getX : $@convention(thin) () -> @owned X
  %16 = apply %15() : $@convention(thin) () -> @owned X
  end_borrow %11
  destroy_value %10
  %19 = begin_borrow %16
  br bb4(%19, %16)

bb8:
  br bb9

bb9:
  br bb1(%11, %10)

bb10:
  %23 = tuple ()
  end_borrow %5
  destroy_value %4
  return %23
}

// CHECK-LABEL: sil [ossa] @nohoist_destroy_over_endborrow_nonadjacent_reborrow : {{.*}} {
// CHECK:         end_borrow {{%[^,]+}}
// CHECK:         destroy_value {{%[^,]+}}
// CHECK-LABEL: } // end sil function 'nohoist_destroy_over_endborrow_nonadjacent_reborrow'
sil [ossa] @nohoist_destroy_over_endborrow_nonadjacent_reborrow : $@convention(thin) (@owned X) -> () {
bb0(%0 : @owned $X):
  %1 = begin_borrow %0
  br bb1(%1, %0)

bb1(%3 : @reborrow $X, %4 : @owned $X):
  %5 = borrowed %3 from (%4)
  br bb2(%5)

bb2(%7 : @reborrow $X):
  %8 = borrowed %7 from (%4)
  br bb3

bb3:
  %10 = tuple ()
  end_borrow %8
  destroy_value %4
  return %10
}

// CHECK-LABEL: sil [ossa] @nohoist_destroy_over_endborrow_nonadjacent_reborrow_2 : {{.*}} {
// CHECK:         end_borrow {{%[^,]+}}
// CHECK:         destroy_value {{%[^,]+}}
// CHECK-LABEL: } // end sil function 'nohoist_destroy_over_endborrow_nonadjacent_reborrow_2'
sil [ossa] @nohoist_destroy_over_endborrow_nonadjacent_reborrow_2 : $@convention(thin) (@owned X) -> () {
bb0(%0 : @owned $X):
  %1 = begin_borrow %0
  br bb1(%1, %0)

bb1(%3 : @reborrow $X, %4 : @owned $X):
  %5 = borrowed %3 from (%4)
  br bb2(%5)

bb2(%7 : @reborrow $X):
  %8 = borrowed %7 from (%4)
  br bb3(%8)

bb3(%10 : @reborrow $X):
  %11 = borrowed %10 from (%4)
  br bb4

bb4:
  %13 = tuple ()
  end_borrow %11
  destroy_value %4
  return %13
}

// The owned phi %5 has an inner adjacent phi %4, so its end_borrow is
// considered a use of the owned lifetime. The end_borrow/destroy
// maintain their position.
//
// CHECK-LABEL: sil [ossa] @reborrow_adjacent_to_ownedphi : $@convention(thin) (@owned X) -> () {
// CHECK:   end_borrow
// CHECK:   destroy_value
sil [ossa] @reborrow_adjacent_to_ownedphi : $@convention(thin) (@owned X) -> () {
bb0(%0 : @owned $X):
  %1 = begin_borrow %0
  br bb1(%1, %0)

bb1(%3 : @reborrow $X, %4 : @owned $X):
  %5 = borrowed %3 from (%4)
  end_borrow %5
  destroy_value %4
  %8 = tuple ()
  return %8
}

// The owned phi %5 has an inner adjacent phi %4, so its reborrow use,
// %6 is considered a use of the owned value. Since %5 is also
// consumed by an owned phi in bb2, the owned lifetime extends no further.
//
// Lifetime analysis is successful; the copy/destroy in bb1 are removed. The
// end_borrow/destroy maintain their position.
//
// CHECK-LABEL: sil [ossa] @reborrow_adjacent_to_consume : $@convention(thin) () -> () {
// CHECK: bb1(%{{.*}} : @reborrow $X, %{{.*}} : @owned $X):
// CHECK-NEXT:   borrowed
// CHECK-NEXT:   br bb2
// CHECK: bb2(%{{.*}} : @reborrow $X, %{{.*}} : @owned $X):
// CHECK-NEXT:   borrowed
// CHECK-NEXT:   end_borrow
// CHECK-NEXT:   destroy_value
sil [ossa] @reborrow_adjacent_to_consume : $@convention(thin) () -> () {
bb0:
  %0 = apply undef() : $@convention(thin) () -> @owned X
  %1 = begin_borrow %0
  br bb1(%1, %0)

bb1(%3 : @reborrow $X, %4 : @owned $X):
  %5 = borrowed %3 from (%4)
  %6 = copy_value %4
  destroy_value %6
  br bb2(%5, %4)

bb2(%9 : @reborrow $X, %10 : @owned $X):
  %11 = borrowed %9 from (%10)
  end_borrow %11
  destroy_value %10
  %14 = tuple ()
  return %14
}

// The owned phi %5 has an inner adjacent phi %4, so its reborrow use,
// %6 is considered a use of the owned value. Since %5 is not consumed
// by an owned phi in bb2, the owned lifetime extends to the uses of
// the second reborrow, %6. The copy/destroy in bb2 are removed. The
// end_borrow/destroy maintain their position.
//
// Lifetime analysis is successful; the copy/destroy in bb2 are removed.
//
// CHECK-LABEL: sil [ossa] @reborrow_no_adjacent_consume : $@convention(thin) () -> () {
// CHECK: bb1(%{{.*}} : @reborrow $X, %{{.*}} : @owned $X):
// CHECK-NEXT:   borrowed
// CHECK-NEXT:   br bb2
// CHECK: bb2(%{{.*}} : @reborrow $X):
// CHECK-NEXT:   borrowed
// CHECK-NEXT:   end_borrow
// CHECK-NEXT:   destroy_value
sil [ossa] @reborrow_no_adjacent_consume : $@convention(thin) () -> () {
bb0:
  %0 = apply undef() : $@convention(thin) () -> @owned X
  %1 = begin_borrow %0
  br bb1(%1, %0)

bb1(%3 : @reborrow $X, %4 : @owned $X):
  %5 = borrowed %3 from (%4)
  br bb2(%5)

bb2(%7 : @reborrow $X):
  %8 = borrowed %7 from (%4)
  %9 = copy_value %4
  destroy_value %9
  end_borrow %8
  destroy_value %4
  %13 = tuple ()
  return %13
}
