// RUN: %target-sil-opt -sil-print-types -parse-serialized-sil -enable-sil-verify-all  -abcopts  %s | %FileCheck %s

sil_stage canonical

import Builtin
import Swift

struct _DependenceToken {}
struct ArrayIntBuffer {
  var storage : Builtin.NativeObject
}

final class StorageBase {
  @_hasStorage var header: Int64
}

struct ArrayInt{
  var buffer : ArrayIntBuffer
}

struct UnsafeMutablePointerInt {
  var _rawValue : Builtin.RawPointer
}

struct IntTupleStruct {
  var tuple: (Int32, Int32)
}

sil public_external [ossa] [_semantics "array.check_subscript"] @checkbounds_no_meth : $@convention(thin) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken {
bb0(%0: $Int32, %1: $Bool, %2: @guaranteed $ArrayInt):
    unreachable
}

sil public_external [ossa] [_semantics "array.props.isNativeTypeChecked"] @arrayPropertyIsNative : $@convention(method) (@guaranteed ArrayInt) -> Bool {
bb0(%0: @guaranteed $ArrayInt):
    unreachable
}

sil public_external [ossa] [_semantics "array.check_subscript"] @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken {
bb0(%0: $Int32, %1: $Bool, %2: @guaranteed $ArrayInt):
    unreachable
}

sil public_external [ossa] [_semantics "array.mutate_unknown"] @append : $@convention(method) (@in Int32, @inout ArrayInt) -> () {
bb0(%0: $*Int32, %1: $*ArrayInt):
    unreachable
}

sil public_external [ossa] [_semantics "array.get_element_address"] @getElementAddr : $@convention(method) (Int32, @guaranteed ArrayInt) -> UnsafeMutablePointerInt {
bb0(%0: $Int32, %1: @guaranteed $ArrayInt):
    unreachable
}

sil public_external [ossa] [_semantics "array.init"] @arrayinit : $@convention(thin) () -> @owned ArrayInt {
bb0:
  unreachable
}

sil public_external [ossa] [_semantics "array.get_count"] @getCount : $@convention(method) (@guaranteed ArrayInt) -> Int32 {
bb0(%0: @guaranteed $ArrayInt):
    unreachable
}

sil [ossa] @nonconst : $@convention(thin) () -> Builtin.Int32

sil [ossa] @unknown_func : $@convention(thin) () -> () {
bb0:
  unreachable
}

sil [ossa] @take_array : $@convention(thin) (@inout ArrayInt) -> () {
bb0(%0 : $*ArrayInt):
  unreachable
}

sil [ossa] @getArray : $@convention(thin) () -> @owned ArrayInt

sil [ossa] [_semantics "array.get_count"] @getCount2 : $@convention(method) (@guaranteed Array<Int>) -> Int32
sil [ossa] [_semantics "array.check_subscript"] @checkbounds2 : $@convention(method) (Int32, Bool, @guaranteed Array<Int>) -> _DependenceToken

sil [ossa] [_semantics "array.get_count"] @getCount3 : $@convention(method) (@guaranteed ArraySlice<Int>) -> Int32
sil [ossa] [_semantics "array.check_subscript"] @checkbounds3 : $@convention(method) (Int32, Bool, @guaranteed ArraySlice<Int>) -> _DependenceToken

// CHECK-LABEL: sil [ossa] @abcopt_singleblock :
sil [ossa] @abcopt_singleblock : $@convention(thin) (@inout ArrayInt, @inout ArrayInt) -> () {
bb0(%0 : $*ArrayInt, %1 : $*ArrayInt):
 // CHECK: [[LD1:%.*]] = load [copy] %0
  %2 = load [copy] %0 : $*ArrayInt
  %100 = function_ref @arrayPropertyIsNative : $@convention(method) (@guaranteed ArrayInt) -> Bool
  %102 = apply %100(%2) : $@convention(method) (@guaranteed ArrayInt) -> Bool

  // Don't assert on functions that are marked with array semantics but are not
  // methods.
  // CHECK: [[CHECKBOUNDSNO:%[0-9]+]] = function_ref @checkbounds_no_meth
  %302 = function_ref @checkbounds_no_meth : $@convention(thin) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %306 = integer_literal $Builtin.Int32, 0
  %307 = struct $Int32(%306 : $Builtin.Int32)
  %308 = apply %302(%307, %102, %2) : $@convention(thin) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken

  %200 = function_ref @arrayinit: $@convention(thin) () -> @owned ArrayInt
  %201 = apply %200() : $@convention(thin) () -> @owned ArrayInt
  destroy_value %201 : $ArrayInt

  // CHECK: [[CHECKBOUNDS:%[0-9]+]] = function_ref @checkbounds
  %func = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // First CHECK.
  %x1 = integer_literal $Builtin.Int32, 1
  %i1 = struct $Int32(%x1 : $Builtin.Int32)
  %8 = apply %func(%i1, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: [[IDX1:%[0-9]+]] = struct $Int32
  // CHECK: apply [[CHECKBOUNDS]]([[IDX1]]

  // Redundant same index and array.
  %9 = apply %func(%i1, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK-NOT: apply [[CHECKBOUNDS]]([[IDX1]]

  // Redundant same index and array
  %r9 = apply %func(%i1, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK-NOT: apply [[CHECKBOUNDS]]([[IDX1]]

  // Redundant same index and array
  %10 = apply %func(%i1, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK-NOT: apply [[CHECKBOUNDS]]([[IDX1]]

  // Not redundant - different index.
  %x2 = integer_literal $Builtin.Int32, 2
  %i2 = struct $Int32(%x2 : $Builtin.Int32)
  %12 = apply %func(%i2, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: [[IDX2:%[0-9]+]] = struct $Int32
  // CHECK: apply [[CHECKBOUNDS]]([[IDX2]]

  // Not redundant - different array.
  %13 = load [copy] %1 : $*ArrayInt
  %16 = apply %func(%i1, %102, %13) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  destroy_value %13 : $ArrayInt
  // CHECK: [[LD2:%[0-9]+]] = load [copy] %1
  // CHECK: apply [[CHECKBOUNDS]]([[IDX1]], {{.*}}[[LD2]]

  // Not redundant same index and array but append in between.
  %17 = function_ref @append : $@convention(method) (@in Int32, @inout ArrayInt) -> ()
  %18 = alloc_stack $Int32
  store %i2 to [trivial] %18 : $*Int32
  %19 = apply %17(%18, %0) : $@convention(method) (@in Int32, @inout ArrayInt) -> ()
  %20 = apply %func(%i1, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: apply [[CHECKBOUNDS]]([[IDX1]], {{.*}}[[LD1]]

  // CHECK: [[IDX3:%[0-9]+]] = struct $Int32
  // CHECK: apply [[CHECKBOUNDS]]([[IDX3]], {{.*}}[[LD1]]
  %x3 = integer_literal $Builtin.Int32, 3
  %i3 = struct $Int32(%x3 : $Builtin.Int32)
  %21 = apply %func(%i3, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %22 = function_ref @unknown_func : $@convention(thin) () -> ()
  %23 = apply %22() : $@convention(thin) () -> ()
  // CHECK: [[UNKNOWN:%[0-9]+]] = function_ref @unknown_func
  // CHECK: apply [[UNKNOWN]]()
  // CHECK: apply [[CHECKBOUNDS]]([[IDX3]], {{.*}}[[LD1]]
  // Not redundant same index and array but unknown function in between.
  %24 = apply %func(%i3, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken

  // Not redundant same index and array but odd store in between.
  %x4 = integer_literal $Builtin.Int32, 4
  %i4 = struct $Int32(%x4 : $Builtin.Int32)
  %25 = apply %func(%i4, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: [[IDX4:%[0-9]+]] = struct $Int32
  // CHECK: apply [[CHECKBOUNDS]]([[IDX4]], {{.*}}[[LD1]]
  %borrow2 = begin_borrow %2 : $ArrayInt
  %4 = struct_extract %borrow2 : $ArrayInt, #ArrayInt.buffer
  %5 = struct_extract %4 : $ArrayIntBuffer, #ArrayIntBuffer.storage
  %26 = ref_to_raw_pointer %5 : $Builtin.NativeObject to $Builtin.RawPointer
  %27 = pointer_to_address %26 : $Builtin.RawPointer to [strict] $*Builtin.Int32
  store %x1 to [trivial] %27 : $*Builtin.Int32
  end_borrow %borrow2 : $ArrayInt
  %30 = apply %func(%i4, %102, %2) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: store
  // CHECK: apply [[CHECKBOUNDS]]([[IDX4]], {{.*}}[[LD1]]

  destroy_value %2 : $ArrayInt
  dealloc_stack %18 : $*Int32
  %99 = tuple ()
  return %99 : $()
// CHECK: return
// CHECK-LABEL: } // end sil function 'abcopt_singleblock'
}

// CHECK-LABEL: sil [ossa] @not_dominating :
sil [ossa] @not_dominating : $@convention(thin) (Int32, @inout ArrayInt, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %24 : $*ArrayInt, %25 : $*ArrayInt):
  %100 = integer_literal $Builtin.Int1, -1
  %101 = struct $Bool(%100 : $Builtin.Int1)
  %1 = struct_extract %0 : $Int32, #Int32._value
  %2 = integer_literal $Builtin.Int32, 0
  // CHECK: [[LD1:%[0-9]+]] = load [copy] {{.*}} : $*ArrayInt
  %33 = load [copy] %24 : $*ArrayInt
  br bb1(%1 : $Builtin.Int32, %2 : $Builtin.Int32)

bb1(%4 : $Builtin.Int32, %5 : $Builtin.Int32):
  %6 = struct $Int32 (%5 : $Builtin.Int32)
  %8 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %8, bb3, bb4
  // CHECK: struct $Int32

bb4:
  %36 = integer_literal $Builtin.Int32, 0
  %37 = struct $Int32(%36 : $Builtin.Int32)
  cond_br %8, bb5, bb6
  // CHECK: [[IDX1:%[0-9]+]] = struct $Int32

bb5:
  %32 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %38 = apply %32(%37, %101, %33) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
 br bb2
  // CHECK: [[CHECKBOUNDS:%[0-9]+]] = function_ref @checkbounds
  // CHECK: apply [[CHECKBOUNDS]]([[IDX1]]

bb6:
  // CHECK: [[CHECKBOUNDS2:%[0-9]+]] = function_ref @checkbounds
  %42 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %48 = apply %42(%37, %101, %33) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: apply [[CHECKBOUNDS2]]([[IDX1]]
 br bb2

bb2:
  %10 = integer_literal $Builtin.Int32, 1
  %12 = integer_literal $Builtin.Int1, -1
  %13 = builtin "sadd_with_overflow_Int32"(%5 : $Builtin.Int32, %10 : $Builtin.Int32, %12 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 0
  %15 = enum $Optional<Int32>, #Optional.some!enumelt, %6 : $Int32
  %16 = unchecked_enum_data %15 : $Optional<Int32>, #Optional.some!enumelt
  %17 = struct_extract %16 : $Int32, #Int32._value
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%4 : $Builtin.Int32, %17 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  br bb1(%21 : $Builtin.Int32, %14 : $Builtin.Int32)

bb3:
  destroy_value %33 : $ArrayInt
  %23 = struct $Int32 (%4 : $Builtin.Int32)
  return %23 : $Int32
}
// CHECK-LABEL: } // end sil function 'not_dominating'

// CHECK-LABEL: sil [ossa] @dominating :
sil [ossa] @dominating : $@convention(thin) (Int32, @inout ArrayInt, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %24 : $*ArrayInt, %25 : $*ArrayInt):
  %100 = integer_literal $Builtin.Int1, -1
  %101 = struct $Bool(%100 : $Builtin.Int1)
  %1 = struct_extract %0 : $Int32, #Int32._value
  %2 = integer_literal $Builtin.Int32, 0
  // CHECK: [[LD1:%[0-9]+]] = load [copy] {{.*}} : $*ArrayInt
  %3 = load [copy] %24 : $*ArrayInt
  br bb1(%1 : $Builtin.Int32, %2 : $Builtin.Int32)

bb1(%4 : $Builtin.Int32, %5 : $Builtin.Int32):
  %6 = struct $Int32 (%5 : $Builtin.Int32)
  %8 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %8, bb3, bb4
  // CHECK: struct $Int32

bb4:
  %36 = integer_literal $Builtin.Int32, 0
  %37 = struct $Int32(%36 : $Builtin.Int32)
  // CHECK: [[IDX1:%[0-9]+]] = struct $Int32
  // CHECK: [[CHECKBOUNDS3:%[0-9]+]] = function_ref @checkbounds
  %52 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %58 = apply %52(%37, %101, %3) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: apply [[CHECKBOUNDS3]]([[IDX1]], {{.*}}[[LD1]]
  cond_br %8, bb5, bb6

bb5:
  // CHECK: [[CHECKBOUNDS:%[0-9]+]] = function_ref @checkbounds
  %32 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %38 = apply %32(%37, %101, %3) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK-NOT: apply [[CHECKBOUNDS]]([[IDX1]], {{.*}}[[LD1]]
  br bb2

bb6:
  // CHECK: [[CHECKBOUNDS2:%[0-9]+]] = function_ref @checkbounds
  %42 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %48 = apply %42(%37, %101, %3) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK-NOT: apply [[CHECKBOUNDS2]]([[IDX1]], {{.*}}[[LD1]]
 br bb2

bb2:
  %10 = integer_literal $Builtin.Int32, 1
  %12 = integer_literal $Builtin.Int1, -1
  %13 = builtin "sadd_with_overflow_Int32"(%5 : $Builtin.Int32, %10 : $Builtin.Int32, %12 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 0
  %15 = enum $Optional<Int32>, #Optional.some!enumelt, %6 : $Int32
  %16 = unchecked_enum_data %15 : $Optional<Int32>, #Optional.some!enumelt
  %17 = struct_extract %16 : $Int32, #Int32._value
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%4 : $Builtin.Int32, %17 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  br bb1(%21 : $Builtin.Int32, %14 : $Builtin.Int32)

bb3:
  destroy_value %3 : $ArrayInt
  %23 = struct $Int32 (%4 : $Builtin.Int32)
  return %23 : $Int32
}
// CHECK-LABEL: } // end sil function 'dominating'

// CHECK-LABEL: sil [ossa] @dominating_but_append :
sil [ossa] @dominating_but_append : $@convention(thin) (Int32, @inout ArrayInt, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %24 : $*ArrayInt, %25 : $*ArrayInt):
  %100 = integer_literal $Builtin.Int1, -1
  %101 = struct $Bool(%100 : $Builtin.Int1)
  %1 = struct_extract %0 : $Int32, #Int32._value
  %2 = integer_literal $Builtin.Int32, 0
  // CHECK: [[LD1:%[0-9]+]] = load [copy] {{.*}} : $*ArrayInt
  %3 = load [copy] %24 : $*ArrayInt
  br bb1(%1 : $Builtin.Int32, %2 : $Builtin.Int32)

bb1(%4 : $Builtin.Int32, %5 : $Builtin.Int32):
  %6 = struct $Int32 (%5 : $Builtin.Int32)
  %8 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %8, bb3, bb4
  // CHECK: struct $Int32

bb4:
  %36 = integer_literal $Builtin.Int32, 0
  %37 = struct $Int32(%36 : $Builtin.Int32)
  // CHECK: [[IDX1:%[0-9]+]] = struct $Int32
  // CHECK: [[CHECKBOUNDS3:%[0-9]+]] = function_ref @checkbounds
  %52 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %58 = apply %52(%37, %101, %3) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: apply [[CHECKBOUNDS3]]([[IDX1]], {{.*}}[[LD1]]
  cond_br %8, bb5, bb6

bb5:
  // CHECK: [[CHECKBOUNDS:%[0-9]+]] = function_ref @checkbounds
  %32 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %38 = apply %32(%37, %101, %3) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: apply [[CHECKBOUNDS]]([[IDX1]], {{.*}}[[LD1]]
 br bb2

bb6:
  // CHECK: [[CHECKBOUNDS2:%[0-9]+]] = function_ref @checkbounds
  %42 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %48 = apply %42(%37, %101, %3) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  // CHECK: apply [[CHECKBOUNDS2]]([[IDX1]], {{.*}}[[LD1]]
 br bb2

bb2:
  %10 = integer_literal $Builtin.Int32, 1
  %12 = integer_literal $Builtin.Int1, -1
  %13 = builtin "sadd_with_overflow_Int32"(%5 : $Builtin.Int32, %10 : $Builtin.Int32, %12 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 0
  %15 = enum $Optional<Int32>, #Optional.some!enumelt, %6 : $Int32
  %16 = unchecked_enum_data %15 : $Optional<Int32>, #Optional.some!enumelt
  %17 = struct_extract %16 : $Int32, #Int32._value
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%4 : $Builtin.Int32, %17 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  %117 = function_ref @append : $@convention(method) (@in Int32, @inout ArrayInt) -> ()
  %118 = alloc_stack $Int32
  store %0 to [trivial] %118 : $*Int32
  %119 = apply %117(%118, %24) : $@convention(method) (@in Int32, @inout ArrayInt) -> ()
  %120 = apply %52(%37, %101, %3) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  dealloc_stack %118 : $*Int32
  // CHECK: [[APPEND:%[0-9]+]] = function_ref @append
  // CHECK: apply [[APPEND]]
  // CHECK: apply [[CHECKBOUNDS3]]

  br bb1(%21 : $Builtin.Int32, %14 : $Builtin.Int32)

bb3:
  destroy_value %3 : $ArrayInt
  %23 = struct $Int32 (%4 : $Builtin.Int32)
  return %23 : $Int32
}
// CHECK-LABEL: } // end sil function 'dominating_but_append'

// This test will not have the bounds check hoisted, because of the destroy inside the loop
// CHECK-LABEL: sil [ossa] @hoist1 :
// CHECK: bb0
// CHECK: [[END:%[0-9]+]] = struct_extract %0 : $Int32, #Int32._value
// CHECK: [[ZERO:%[0-9]+]] = integer_literal $Builtin.Int32, 0
// CHECK: cond_br

// CHECK: bb3
// CHECK: [[CB1:%[0-9]+]] = function_ref @checkbounds
// CHECK: [[L1:%[0-9]+]] = load [copy] %1 : $*ArrayInt
// CHECK: apply [[CB1]]({{.*}}[[L1]])
// CHECK: cond_br {{.*}}, {{.*}}, bb4
// CHECK: bb4
// CHECK:  br bb3
// CHECK: return
// CHECK-LABEL: } // end sil function 'hoist1'
sil [ossa] @hoist1 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %6, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%10 : $Builtin.Int32):
  %11 = struct $Int32 (%10 : $Builtin.Int32)
  %12 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %13 = load [copy] %1 : $*ArrayInt
  %17 = apply %12(%11, %3, %13) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  destroy_value %13 : $ArrayInt
  %18 = integer_literal $Builtin.Int32, 1
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%10 : $Builtin.Int32, %18 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  %22 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 1
  cond_fail %22 : $Builtin.Int1, ""
  %24 = builtin "cmp_eq_Int32"(%21 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %24, bb5, bb4

bb4:
  br bb3(%21 : $Builtin.Int32)

bb5:
  br bb6(%21 : $Builtin.Int32)

bb6(%28 : $Builtin.Int32):
  %29 = struct $Int32 (%28 : $Builtin.Int32)
  return %29 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoist2 :
// CHECK: bb0
// CHECK: [[END:%[0-9]+]] = struct_extract %0 : $Int32, #Int32._value
// CHECK: [[ZERO:%[0-9]+]] = integer_literal $Builtin.Int32, 0
// CHECK: [[L1:%[0-9]+]] = load [copy] %1
// CHECK: cond_br

// CHECK: bb1
// CHECK overflow.
// CHECK: [[CB1:%[0-9]+]] = function_ref @checkbounds
// CHECK:  [[SGE1:%[0-9]+]] = builtin "cmp_sge_Int32"([[ZERO]] : ${{.*}}, [[END]]
// CHECK:  cond_fail [[SGE1]]

// CHECK start.
// CHECK: [[S1:%[0-9]+]] = struct $Int32 ([[ZERO]] : $Builtin.Int32)
// CHECK: apply [[CB1]]([[S1]], {{.*}}[[L1]])

// CHECK end.
// CHECK: [[ONE:%[0-9]+]] = integer_literal $Builtin.Int32, 1
// CHECK: [[SUB1:%[0-9]+]] = builtin "ssub_with_overflow_Int32"([[END]] : ${{.*}}, [[ONE]]
// CHECK: [[SUB2:%[0-9]+]] = tuple_extract [[SUB1]]
// CHECK: [[SUB3:%[0-9]+]] = struct $Int32 ([[SUB2]]
// CHECK: apply [[CB1]]([[SUB3]], {{.*}}[[L1]])
// CHECK: br bb3

// CHECK: bb3
// CHECK-NOT: cond_fail
// CHECK-NOT: @checkbounds
// CHECK: builtin
// CHECK: builtin
// CHECK-NOT: builtin
// CHECK: cond_br {{.*}}, {{.*}}, bb4
// CHECK: bb4
// CHECK:  br bb3
// CHECK: return
// CHECK-LABEL: } // end sil function 'hoist2'
sil [ossa] @hoist2 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %13 = load [copy] %1 : $*ArrayInt
  cond_br %6, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%10 : $Builtin.Int32):
  %11 = struct $Int32 (%10 : $Builtin.Int32)
  %12 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %17 = apply %12(%11, %3, %13) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %18 = integer_literal $Builtin.Int32, 1
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%10 : $Builtin.Int32, %18 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  %22 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 1
  cond_fail %22 : $Builtin.Int1, ""
  %24 = builtin "cmp_eq_Int32"(%21 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %24, bb5, bb4

bb4:
  br bb3(%21 : $Builtin.Int32)

bb5:
  br bb6(%21 : $Builtin.Int32)

bb6(%28 : $Builtin.Int32):
  destroy_value %13 : $ArrayInt
  %29 = struct $Int32 (%28 : $Builtin.Int32)
  return %29 : $Int32
}

// CHECK-LABEL: sil [ossa] @always_false_hoist :
// CHECK: bb2:
// CHECK: [[ZERO:%.*]] = integer_literal $Builtin.Int1, 0
// CHECK: bb6:
// CHECK:   builtin "sadd_with_overflow_Int32"
// CHECK:   tuple_extract
// CHECK:   cond_fail [[ZERO]] :
// CHECK:   cond_fail [[ZERO]] :
// CHECK:   cond_fail [[ZERO]] :
// CHECK:   cond_fail [[ZERO]] :
// CHECK:   builtin "cmp_eq_Int32"
// CHECK:   cond_br
// CHECK-LABEL: } // end sil function 'always_false_hoist'
sil [ossa] @always_false_hoist : $@convention(thin) (@guaranteed Array<Int>) -> () {
bb0(%0 : @guaranteed $Array<Int>):
  %1 = integer_literal $Builtin.Int32, 0
  %2 = function_ref @getCount2 : $@convention(method) (@guaranteed Array<Int>) -> Int32
  %4 = apply %2(%0) : $@convention(method) (@guaranteed Array<Int>) -> Int32
  %5 = struct_extract %4 : $Int32, #Int32._value
  %6 = builtin "cmp_eq_Int32"(%1 : $Builtin.Int32, %5 : $Builtin.Int32) : $Builtin.Int1
  cond_br %6, bb1, bb2

bb1:
  br bb9

bb2:
  br bb3(%1 : $Builtin.Int32)

bb3(%10 : $Builtin.Int32):
  cond_br undef, bb5, bb4

bb4:
  br bb6

bb5:
  br bb6

bb6:
  %15 = integer_literal $Builtin.Int1, 0
  %16 = integer_literal $Builtin.Int32, 1
  %17 = builtin "sadd_with_overflow_Int32"(%10 : $Builtin.Int32, %16 : $Builtin.Int32, %15 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %18 = tuple_extract %17 : $(Builtin.Int32, Builtin.Int1), 0
  %19 = tuple_extract %17 : $(Builtin.Int32, Builtin.Int1), 1
  cond_fail %19 : $Builtin.Int1, ""
  %21 = builtin "cmp_slt_Int32"(%10 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_fail %21 : $Builtin.Int1, ""
  %23 = builtin "cmp_slt_Int32"(%18 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_fail %23 : $Builtin.Int1, ""
  %25 = builtin "cmp_sle_Int32"(%18 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_fail %25 : $Builtin.Int1, ""
  %27 = builtin "cmp_eq_Int32"(%18 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_fail %27 : $Builtin.Int1, ""
  %29 = builtin "cmp_eq_Int32"(%18 : $Builtin.Int32, %5 : $Builtin.Int32) : $Builtin.Int1
  cond_br %29, bb8, bb7

bb7:
  br bb3(%18 : $Builtin.Int32)

bb8:
  br bb9

bb9:
  %33 = tuple ()
  return %33 : $()
}

// This test will not have the bounds check hoisted, because of the destroy inside the loop
// CHECK-LABEL: sil [ossa] @hoistinvariant1 :
// Preheader.
// CHECK: bb1:
// CHECK: [[SGE1:%[0-9]+]] = builtin "cmp_sge_Int32"
// CHECK: cond_fail [[SGE1]]
// CHECK-NOT:  load [copy] %1 : $*ArrayInt
// CHECK-NOT:  [[CB1:%[0-9]+]] = function_ref @checkbounds
// CHECK-NOT:  apply [[CB1]]
// CHECK:  br bb3

// Loop.
// CHECK:  bb3{{.*}}:
// CHECK:  [[CB2:%[0-9]+]] = function_ref @checkbounds
// CHECK:  load [copy] %1 : $*ArrayInt
// CHECK:  apply [[CB2]]
// CHECK:  cond_br {{.*}}, bb5{{.*}}, bb4{{.*}}
// CHECK: bb4:
// CHECK:   br bb3
// CHECK: bb5:
// CHECK:   br bb6
// CHECK: bb6{{.*}}:
// CHECK:   return
// CHECK-LABEL: } // end sil function 'hoistinvariant1'
sil [ossa] @hoistinvariant1 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = struct $Int32 (%5 : $Builtin.Int32)
  %7 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %7, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%11 : $Builtin.Int32):
  %12 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %13 = load [copy] %1 : $*ArrayInt
  %17 = apply %12(%6, %3, %13) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  destroy_value %13 : $ArrayInt
  %18 = integer_literal $Builtin.Int32, 1
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%11 : $Builtin.Int32, %18 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  %22 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 1
  cond_fail %22 : $Builtin.Int1, ""
  %24 = builtin "cmp_eq_Int32"(%21 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %24, bb5, bb4

bb4:
  br bb3(%21 : $Builtin.Int32)

bb5:
  br bb6(%21 : $Builtin.Int32)

bb6(%28 : $Builtin.Int32):
  %29 = struct $Int32 (%28 : $Builtin.Int32)
  return %29 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoistinvariant2 :
// Preheader.
// CHECK: bb1:
// CHECK: [[SGE1:%[0-9]+]] = builtin "cmp_sge_Int32"
// CHECK: cond_fail [[SGE1]]
// CHECK:  [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:  apply [[CB]]
// CHECK:  br bb3

// Loop.
// CHECK:  bb3{{.*}}:
// CHECK-NOT: cond_fail
// CHECK-NOT: @checkbounds
// CHECK: builtin
// CHECK: builtin
// CHECK-NOT: builtin
// CHECK:  cond_br {{.*}}, bb5{{.*}}, bb4{{.*}}
// CHECK: bb4:
// CHECK:   br bb3
// CHECK: bb5:
// CHECK:   br bb6
// CHECK: bb6{{.*}}:
// CHECK:   return
// CHECK-LABEL: } // end sil function 'hoistinvariant2'
sil [ossa] @hoistinvariant2 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = struct $Int32 (%5 : $Builtin.Int32)
  %7 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %13 = load [copy] %1 : $*ArrayInt
  cond_br %7, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%11 : $Builtin.Int32):
  %12 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %17 = apply %12(%6, %3, %13) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %18 = integer_literal $Builtin.Int32, 1
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%11 : $Builtin.Int32, %18 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  %22 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 1
  cond_fail %22 : $Builtin.Int1, ""
  %24 = builtin "cmp_eq_Int32"(%21 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %24, bb5, bb4

bb4:
  br bb3(%21 : $Builtin.Int32)

bb5:
  br bb6(%21 : $Builtin.Int32)

bb6(%28 : $Builtin.Int32):
  destroy_value %13 : $ArrayInt
  %29 = struct $Int32 (%28 : $Builtin.Int32)
  return %29 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoistinvariant_array_is_not_an_arg :
// CHECK:    bb0{{.*}}:
// CHECK:      [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:      apply [[CB]]
// CHECK:      br bb1
// CHECK:    bb3{{.*}}:
// CHECK-NOT:  apply
// CHECK:    return
// CHECK-LABEL: } // end sil function 'hoistinvariant_array_is_not_an_arg'
sil [ossa] @hoistinvariant_array_is_not_an_arg : $@convention(thin) (Int32) -> Int32 {
bb0(%0 : $Int32):
  %100 = integer_literal $Builtin.Int1, -1
  %101 = struct $Bool(%100 : $Builtin.Int1)
  %1 = struct_extract %0 : $Int32, #Int32._value
  %2 = integer_literal $Builtin.Int32, 0
  %37 = struct $Int32(%2 : $Builtin.Int32)
  %f1 = function_ref @getArray : $@convention(thin) () -> @owned ArrayInt
  %x53 = apply %f1() : $@convention(thin) () -> @owned ArrayInt
  br bb1(%2 : $Builtin.Int32)

bb1(%4 : $Builtin.Int32):
  %52 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %58 = apply %52(%37, %101, %x53) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %10 = integer_literal $Builtin.Int32, 1
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%4 : $Builtin.Int32, %10 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  %22 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 1
  cond_fail %22 : $Builtin.Int1
  %8 = builtin "cmp_eq_Int32"(%4 : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %8, bb2, bb1a

bb1a:
  br bb1(%21 : $Builtin.Int32)

bb2:
  destroy_value %x53 : $ArrayInt
  %23 = struct $Int32 (%4 : $Builtin.Int32)
  return %23 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoist_rangechecked1 :
// CHECK: bb0
// CHECK:  cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK:   [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:    apply [[CB]]
// CHECK:   br bb3{{.*}}
// CHECK: bb3{{.*}}:
// CHECK-NOT: function_ref @checkbounds
// CHECK-NOT:    apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4
// CHECK:   br bb3
// CHECK: bb5
// CHECK:   br bb6
// CHECK: bb6{{.*}}:
// CHECK:  return
// CHECK-LABEL: } // end sil function 'hoist_rangechecked1'
sil [ossa] @hoist_rangechecked1 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = integer_literal $Builtin.Int1, -1
  %7 = builtin "cmp_sle_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %8 = builtin "xor_Int1"(%7 : $Builtin.Int1, %6 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %8 : $Builtin.Int1, ""
  %10 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %17 = load [copy] %1 : $*ArrayInt
  cond_br %10, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%14 : $Builtin.Int32):
  %15 = struct $Int32 (%14 : $Builtin.Int32)
  %16 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %21 = apply %16(%15, %3, %17) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %22 = integer_literal $Builtin.Int32, 1
  %23 = integer_literal $Builtin.Int1, -1
  %24 = builtin "sadd_with_overflow_Int32"(%14 : $Builtin.Int32, %22 : $Builtin.Int32, %23 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %25 = tuple_extract %24 : $(Builtin.Int32, Builtin.Int1), 0
  %26 = function_ref @getElementAddr : $@convention(method) (Int32, @guaranteed ArrayInt) -> UnsafeMutablePointerInt
  %28 = apply %26(%15, %17) : $@convention(method) (Int32, @guaranteed ArrayInt) -> UnsafeMutablePointerInt
  %29 = struct_extract %28 : $UnsafeMutablePointerInt, #UnsafeMutablePointerInt._rawValue
  %30 = pointer_to_address %29 : $Builtin.RawPointer to [strict] $*Int32
  store %0 to [trivial] %30 : $*Int32
  %32 = builtin "cmp_eq_Int32"(%25 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %32, bb5, bb4

bb4:
  br bb3(%25 : $Builtin.Int32)

bb5:
  br bb6(%25 : $Builtin.Int32)

bb6(%36 : $Builtin.Int32):
  destroy_value %17 : $ArrayInt
  %37 = struct $Int32 (%36 : $Builtin.Int32)
  return %37 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoist_rangechecked2 :
// CHECK: bb0
// CHECK:  cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK:   [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:    apply [[CB]]
// CHECK:   br bb3{{.*}}
// CHECK: bb3{{.*}}:
// CHECK-NOT: function_ref @checkbounds
// CHECK-NOT:    apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4
// CHECK:   br bb3
// CHECK: bb5
// CHECK:   br bb6
// CHECK: bb6{{.*}}:
// CHECK:  return
// CHECK-LABEL: } // end sil function 'hoist_rangechecked2'
sil [ossa] @hoist_rangechecked2 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = integer_literal $Builtin.Int1, -1
  %7 = builtin "cmp_slt_Int32"(%4 : $Builtin.Int32, %5 : $Builtin.Int32) : $Builtin.Int1
  cond_fail %7 : $Builtin.Int1, ""
  %10 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %17 = load [copy] %1 : $*ArrayInt
  cond_br %10, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%14 : $Builtin.Int32):
  %15 = struct $Int32 (%14 : $Builtin.Int32)
  %16 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %21 = apply %16(%15, %3, %17) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %22 = integer_literal $Builtin.Int32, 1
  %23 = integer_literal $Builtin.Int1, -1
  %24 = builtin "sadd_with_overflow_Int32"(%14 : $Builtin.Int32, %22 : $Builtin.Int32, %23 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %25 = tuple_extract %24 : $(Builtin.Int32, Builtin.Int1), 0
  %26 = function_ref @getElementAddr : $@convention(method) (Int32, @guaranteed ArrayInt) -> UnsafeMutablePointerInt
  %28 = apply %26(%15, %17) : $@convention(method) (Int32, @guaranteed ArrayInt) -> UnsafeMutablePointerInt
  %29 = struct_extract %28 : $UnsafeMutablePointerInt, #UnsafeMutablePointerInt._rawValue
  %30 = pointer_to_address %29 : $Builtin.RawPointer to [strict] $*Int32
  store %0 to [trivial] %30 : $*Int32
  %32 = builtin "cmp_eq_Int32"(%25 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %32, bb5, bb4

bb4:
  br bb3(%25 : $Builtin.Int32)

bb5:
  br bb6(%25 : $Builtin.Int32)

bb6(%36 : $Builtin.Int32):
  destroy_value %17 : $ArrayInt
  %37 = struct $Int32 (%36 : $Builtin.Int32)
  return %37 : $Int32
}
// CHECK-LABEL: sil [ossa] @hoist_rangechecked_ref_tail_addr :
// CHECK: bb0
// CHECK:  cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK:   [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:    apply [[CB]]
// CHECK:   br bb3{{.*}}
// CHECK: bb3{{.*}}:
// CHECK-NOT: function_ref @checkbounds
// CHECK-NOT:    apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4
// CHECK:   br bb3
// CHECK: bb5
// CHECK:   br bb6
// CHECK: bb6{{.*}}:
// CHECK:  return
// CHECK-LABEL: } // end sil function 'hoist_rangechecked_ref_tail_addr'
sil [ossa] @hoist_rangechecked_ref_tail_addr : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = integer_literal $Builtin.Int1, -1
  %7 = builtin "cmp_sle_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %8 = builtin "xor_Int1"(%7 : $Builtin.Int1, %6 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %8 : $Builtin.Int1, ""
  %10 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %17 = load [copy] %1 : $*ArrayInt
  cond_br %10, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%14 : $Builtin.Int32):
  %15 = struct $Int32 (%14 : $Builtin.Int32)
  %16 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %borrow17 = begin_borrow %17 : $ArrayInt
  %18 = struct_extract %borrow17 : $ArrayInt, #ArrayInt.buffer
  %19 = struct_extract %18 : $ArrayIntBuffer, #ArrayIntBuffer.storage
  %27 = unchecked_ref_cast %19 : $Builtin.NativeObject to $StorageBase
  %28 = ref_tail_addr %27 : $StorageBase, $Int32
  %29 = index_addr %28 : $*Int32, %14 : $Builtin.Int32
  store %0 to [trivial] %29 : $*Int32
  end_borrow %borrow17 : $ArrayInt
  %21 = apply %16(%15, %3, %17) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %22 = integer_literal $Builtin.Int32, 1
  %23 = integer_literal $Builtin.Int1, -1
  %24 = builtin "sadd_with_overflow_Int32"(%14 : $Builtin.Int32, %22 : $Builtin.Int32, %23 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %25 = tuple_extract %24 : $(Builtin.Int32, Builtin.Int1), 0
  %31 = builtin "cmp_eq_Int32"(%25 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %31, bb5, bb4

bb4:
  br bb3(%25 : $Builtin.Int32)

bb5:
  br bb6(%25 : $Builtin.Int32)

bb6(%35 : $Builtin.Int32):
  destroy_value %17 : $ArrayInt
  %36 = struct $Int32 (%35 : $Builtin.Int32)
  return %36 : $Int32
}

// CHECK-LABEL: sil [ossa] @eliminate_zero_to_count :
// CHECK: [[FUNC:.*]] function_ref @checkbounds2
// CHECK-NOT: apply [[FUNC]]
// CHECK:  return
// CHECK-LABEL: } // end sil function 'eliminate_zero_to_count'
sil [ossa] @eliminate_zero_to_count : $@convention(thin) (@guaranteed Array<Int>) -> () {
bb0(%0 : @guaranteed $Array<Int>):
  %100 = integer_literal $Builtin.Int1, -1
  %101 = struct $Bool(%100 : $Builtin.Int1)
  %z0 = integer_literal $Builtin.Int32, 0
  %f1 = function_ref @getCount2 : $@convention(method) (@guaranteed Array<Int>) -> Int32
  %t1 = apply %f1(%0) : $@convention(method) (@guaranteed Array<Int>) -> Int32
  %c1 = struct_extract %t1 : $Int32, #Int32._value
  %t2 = builtin "cmp_eq_Int32"(%z0 : $Builtin.Int32, %c1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %t2, bb0a, bb1

bb0a:
  br bb5

bb1:
  br bb2(%z0 : $Builtin.Int32)

bb2(%i0 : $Builtin.Int32):
  cond_br undef, bb3, bb2a

bb2a:
  br bb4

bb3:
  %f2 = function_ref @checkbounds2 : $@convention(method) (Int32, Bool, @guaranteed Array<Int>) -> _DependenceToken
  %t3 = struct $Int32(%i0 : $Builtin.Int32)

  // This subscript check can be completely eliminated because the loop goes
  // from 0 to array.count.
  // It's even not required that this loop block dominates the exit block.
  %t4 = apply %f2(%t3, %101, %0) : $@convention(method) (Int32, Bool, @guaranteed Array<Int>) -> _DependenceToken
  br bb4

bb4:
  %t5 = integer_literal $Builtin.Int1, 0
  %i2 = integer_literal $Builtin.Int32, 1
  %t6 = builtin "sadd_with_overflow_Int32"(%i0 : $Builtin.Int32, %i2 : $Builtin.Int32, %t5 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %t7 = tuple_extract %t6 : $(Builtin.Int32, Builtin.Int1), 0
  %8 = builtin "cmp_eq_Int32"(%t7 : $Builtin.Int32, %c1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %8, bb4a, bb4b

bb4a:
  br bb5

bb4b:
  br bb2(%t7 : $Builtin.Int32)

bb5:
  %r1 = tuple ()
  return %r1 : $()
}

// CHECK-LABEL: sil [ossa] @dont_eliminate_zero_to_count_for_slices :
// CHECK: {{^}}bb1:
// CHECK:   [[F:%[0-9]+]] = function_ref @checkbounds3
// CHECK:   apply [[F]]
// CHECK:  return
// CHECK-LABEL: } // end sil function 'dont_eliminate_zero_to_count_for_slices'
sil [ossa] @dont_eliminate_zero_to_count_for_slices : $@convention(thin) (@guaranteed ArraySlice<Int>) -> () {
bb0(%0 : @guaranteed $ArraySlice<Int>):
  %100 = integer_literal $Builtin.Int1, -1
  %101 = struct $Bool(%100 : $Builtin.Int1)
  %z0 = integer_literal $Builtin.Int32, 0
  %f1 = function_ref @getCount3 : $@convention(method) (@guaranteed ArraySlice<Int>) -> Int32
  %t1 = apply %f1(%0) : $@convention(method) (@guaranteed ArraySlice<Int>) -> Int32
  %c1 = struct_extract %t1 : $Int32, #Int32._value
  %t2 = builtin "cmp_eq_Int32"(%z0 : $Builtin.Int32, %c1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %t2, bb0a, bb0b

bb0a:
  br bb2

bb0b:
 br bb1(%z0 : $Builtin.Int32)

bb1(%i0 : $Builtin.Int32):
  %f2 = function_ref @checkbounds3 : $@convention(method) (Int32, Bool, @guaranteed ArraySlice<Int>) -> _DependenceToken
  %t3 = struct $Int32(%i0 : $Builtin.Int32)
  // Slices don't necessarily have a zero lower bound. So we can't eliminate the
  // subscript check for 0..<count loops.
  %t4 = apply %f2(%t3, %101, %0) : $@convention(method) (Int32, Bool, @guaranteed ArraySlice<Int>) -> _DependenceToken
  %t5 = integer_literal $Builtin.Int1, 0
  %i2 = integer_literal $Builtin.Int32, 1
  %t6 = builtin "sadd_with_overflow_Int32"(%i0 : $Builtin.Int32, %i2 : $Builtin.Int32, %t5 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %t7 = tuple_extract %t6 : $(Builtin.Int32, Builtin.Int1), 0
  %8 = builtin "cmp_eq_Int32"(%t7 : $Builtin.Int32, %c1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %8, bb1a, bb1b

bb1a:
  br bb2

bb1b:
  br bb1(%t7 : $Builtin.Int32)

bb2:
  %r1 = tuple ()
  return %r1 : $()
}

// CHECK-LABEL: sil [ossa] @hoist_rangechecked_addr_proj_store :
// CHECK: bb0
// CHECK:  cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK:   [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:    apply [[CB]]
// CHECK:   br bb3{{.*}}
// CHECK: bb3{{.*}}:
// CHECK-NOT: function_ref @checkbounds
// CHECK-NOT:    apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4
// CHECK:   br bb3
// CHECK: bb5
// CHECK:   br bb6
// CHECK: bb6{{.*}}:
// CHECK:  return
// CHECK-LABEL: } // end sil function 'hoist_rangechecked_addr_proj_store'
sil [ossa] @hoist_rangechecked_addr_proj_store : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = integer_literal $Builtin.Int1, -1
  %7 = builtin "cmp_sle_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %8 = builtin "xor_Int1"(%7 : $Builtin.Int1, %6 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %8 : $Builtin.Int1, ""
  %10 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %17 = load [copy] %1 : $*ArrayInt
  cond_br %10, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%14 : $Builtin.Int32):
  %15 = struct $Int32 (%14 : $Builtin.Int32)
  %16 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %21 = apply %16(%15, %3, %17) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %22 = integer_literal $Builtin.Int32, 1
  %23 = integer_literal $Builtin.Int1, -1
  %24 = builtin "sadd_with_overflow_Int32"(%14 : $Builtin.Int32, %22 : $Builtin.Int32, %23 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %25 = tuple_extract %24 : $(Builtin.Int32, Builtin.Int1), 0
  %26 = function_ref @getElementAddr : $@convention(method) (Int32, @guaranteed ArrayInt) -> UnsafeMutablePointerInt
  %28 = apply %26(%15, %17) : $@convention(method) (Int32, @guaranteed ArrayInt) -> UnsafeMutablePointerInt
  %29 = struct_extract %28 : $UnsafeMutablePointerInt, #UnsafeMutablePointerInt._rawValue
  %30 = pointer_to_address %29 : $Builtin.RawPointer to [strict] $*IntTupleStruct
  %31 = struct_element_addr %30 : $*IntTupleStruct, #IntTupleStruct.tuple
  %32 = tuple_element_addr %31 : $*(Int32, Int32), 0
  store %0 to [trivial] %32 : $*Int32
  %34 = builtin "cmp_eq_Int32"(%25 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %34, bb5, bb4

bb4:
  br bb3(%25 : $Builtin.Int32)

bb5:
  br bb6(%25 : $Builtin.Int32)

bb6(%38 : $Builtin.Int32):
  destroy_value %17 : $ArrayInt
  %39 = struct $Int32 (%38 : $Builtin.Int32)
  return %39 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoist_inclusive_rangechecked1 :
// CHECK: bb0
// CHECK:  cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK:   [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:    apply [[CB]]
// CHECK:   br bb3{{.*}}
// CHECK: bb3{{.*}}:
// CHECK-NOT: function_ref @checkbounds
// CHECK-NOT:    apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4:
// CHECK:  br bb3
// CHECK: bb5:
// CHECK:  br bb6
// CHECK: bb6{{.*}}:
// CHECK-LABEL: } // end sil function 'hoist_inclusive_rangechecked1'
sil [ossa] @hoist_inclusive_rangechecked1 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = integer_literal $Builtin.Int1, -1
  %7 = builtin "cmp_sle_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %8 = builtin "xor_Int1"(%7 : $Builtin.Int1, %6 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %8 : $Builtin.Int1, ""
  %10 = integer_literal $Builtin.Int32, 1
  %11 = integer_literal $Builtin.Int1, 0
  %12 = builtin "sadd_with_overflow_Int32"(%4 : $Builtin.Int32, %10 : $Builtin.Int32, %11 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %13 = tuple_extract %12 : $(Builtin.Int32, Builtin.Int1), 0
  %14 = builtin "cmp_sgt_Int32"(%13 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %15 = builtin "xor_Int1"(%14 : $Builtin.Int1, %6 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %15 : $Builtin.Int1, ""
  %17 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %13 : $Builtin.Int32) : $Builtin.Int1
  %24 = load [copy] %1 : $*ArrayInt
  cond_br %17, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%21 : $Builtin.Int32):
  %22 = struct $Int32 (%21 : $Builtin.Int32)
  %23 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %28 = apply %23(%22, %3, %24) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %29 = integer_literal $Builtin.Int32, 1
  %30 = integer_literal $Builtin.Int1, -1
  %31 = builtin "sadd_with_overflow_Int32"(%21 : $Builtin.Int32, %29 : $Builtin.Int32, %30 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %32 = tuple_extract %31 : $(Builtin.Int32, Builtin.Int1), 0
  %33 = builtin "cmp_eq_Int32"(%32 : $Builtin.Int32, %13 : $Builtin.Int32) : $Builtin.Int1
  cond_br %33, bb5, bb4

bb4:
  br bb3(%32 : $Builtin.Int32)

bb5:
  br bb6(%32 : $Builtin.Int32)

bb6(%37 : $Builtin.Int32):
  destroy_value %24 : $ArrayInt
  %38 = struct $Int32 (%37 : $Builtin.Int32)
  return %38 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoist_inclusive_rangechecked2 :
// CHECK: bb0
// CHECK:  cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK:   [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:    apply [[CB]]
// CHECK:   br bb3{{.*}}
// CHECK: bb3{{.*}}:
// CHECK-NOT: function_ref @checkbounds
// CHECK-NOT:    apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4:
// CHECK:  br bb3
// CHECK: bb5:
// CHECK:  br bb6
// CHECK: bb6{{.*}}:
// CHECK-LABEL: } // end sil function 'hoist_inclusive_rangechecked2'
sil [ossa] @hoist_inclusive_rangechecked2 : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = integer_literal $Builtin.Int1, -1
  %7 = builtin "cmp_slt_Int32"(%4 : $Builtin.Int32, %5 : $Builtin.Int32) : $Builtin.Int1
  cond_fail %7 : $Builtin.Int1, ""
  %10 = integer_literal $Builtin.Int32, 1
  %11 = integer_literal $Builtin.Int1, 0
  %12 = builtin "sadd_with_overflow_Int32"(%4 : $Builtin.Int32, %10 : $Builtin.Int32, %11 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %13 = tuple_extract %12 : $(Builtin.Int32, Builtin.Int1), 0
  %14 = builtin "cmp_sgt_Int32"(%13 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %15 = builtin "xor_Int1"(%14 : $Builtin.Int1, %6 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %15 : $Builtin.Int1, ""
  %17 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %13 : $Builtin.Int32) : $Builtin.Int1
  %24 = load [copy] %1 : $*ArrayInt
  cond_br %17, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%21 : $Builtin.Int32):
  %22 = struct $Int32 (%21 : $Builtin.Int32)
  %23 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %28 = apply %23(%22, %3, %24) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %29 = integer_literal $Builtin.Int32, 1
  %30 = integer_literal $Builtin.Int1, -1
  %31 = builtin "sadd_with_overflow_Int32"(%21 : $Builtin.Int32, %29 : $Builtin.Int32, %30 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %32 = tuple_extract %31 : $(Builtin.Int32, Builtin.Int1), 0
  %33 = builtin "cmp_eq_Int32"(%32 : $Builtin.Int32, %13 : $Builtin.Int32) : $Builtin.Int1
  cond_br %33, bb5, bb4

bb4:
  br bb3(%32 : $Builtin.Int32)

bb5:
  br bb6(%32 : $Builtin.Int32)

bb6(%37 : $Builtin.Int32):
  destroy_value %24 : $ArrayInt
  %38 = struct $Int32 (%37 : $Builtin.Int32)
  return %38 : $Int32
}
// Don't hoist arrays that are variant.
// CHECK-LABEL: sil [ossa] @dont_hoist_variant_array :
// CHECK: bb0
// CHECK:   cond_br {{.*}}, bb2, bb1
// CHECK: bb1:
// CHECK-NEXT:  br bb3
// CHECK: bb2:
// CHECK-NEXT:  br bb6
// CHECK: bb3{{.*}}:
// CHECK:   [[CB:%[0-9]+]] = function_ref @checkbounds
// CHECK:   apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4:
// CHECK:   br bb3
// CHECK: bb5:
// CHECK:   br bb6
// CHECK: bb6{{.*}}:
// CHECK:   return
// CHECK-LABEL: } // end sil function 'dont_hoist_variant_array'
sil [ossa] @dont_hoist_variant_array : $@convention(thin) (Int32, @inout ArrayInt, @guaranteed ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt, %2 : @guaranteed $ArrayInt):
  %2a = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2a : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = integer_literal $Builtin.Int1, -1
  %7 = builtin "cmp_sle_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %8 = builtin "xor_Int1"(%7 : $Builtin.Int1, %6 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %8 : $Builtin.Int1, ""
  %10 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %10, bb2, bb1

bb1:
  br bb3(%5 : $Builtin.Int32)

bb2:
  br bb6(%5 : $Builtin.Int32)

bb3(%14 : $Builtin.Int32):
  %15 = alloc_stack $ArrayInt
  %copy = copy_value %2 : $ArrayInt
  store %copy to [init] %15 : $*ArrayInt
  %16 = struct $Int32 (%14 : $Builtin.Int32)
  %17 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %18 = load [take] %15 : $*ArrayInt
  %22 = apply %17(%16, %3, %18) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  destroy_value %18 : $ArrayInt
  %23 = integer_literal $Builtin.Int32, 1
  %24 = integer_literal $Builtin.Int1, -1
  %25 = builtin "sadd_with_overflow_Int32"(%14 : $Builtin.Int32, %23 : $Builtin.Int32, %24 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %26 = tuple_extract %25 : $(Builtin.Int32, Builtin.Int1), 0
  dealloc_stack %15 : $*ArrayInt
  %28 = builtin "cmp_eq_Int32"(%26 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %28, bb5, bb4

bb4:
  br bb3(%26 : $Builtin.Int32)

bb5:
  br bb6(%26 : $Builtin.Int32)

bb6(%32 : $Builtin.Int32):
  %33 = struct $Int32 (%32 : $Builtin.Int32)
  return %33 : $Int32
}

// CHECK-LABEL: sil [ossa] @dont_hoist_due_to_unknown_release :
// CHECK: bb3{{.*}}:
// CHECK:   [[CB:%.*]] = function_ref @checkbounds
// CHECK:   apply [[CB]]
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4:
// CHECK:  br bb3
// CHECK-LABEL: } // end sil function 'dont_hoist_due_to_unknown_release'
sil [ossa] @dont_hoist_due_to_unknown_release : $@convention(thin) (Int32, @inout ArrayInt, @guaranteed Builtin.NativeObject) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt, %2 : @guaranteed $Builtin.NativeObject):
  %3 = integer_literal $Builtin.Int1, -1
  %4 = struct $Bool (%3 : $Builtin.Int1)
  %5 = struct_extract %0 : $Int32, #Int32._value
  %6 = integer_literal $Builtin.Int32, 0
  %7 = builtin "cmp_eq_Int32"(%6 : $Builtin.Int32, %5 : $Builtin.Int32) : $Builtin.Int1
  %16 = load [copy] %1 : $*ArrayInt
  cond_br %7, bb2, bb1

bb1:
  %9 = builtin "cmp_sge_Int32"(%6 : $Builtin.Int32, %5 : $Builtin.Int32) : $Builtin.Int1
  cond_fail %9 : $Builtin.Int1, "loop induction variable overflowed"
  br bb3(%6 : $Builtin.Int32)

bb2:
  br bb6(%6 : $Builtin.Int32)

bb3(%13 : $Builtin.Int32):
  %14 = struct $Int32 (%13 : $Builtin.Int32)
  %15 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %20 = apply %15(%14, %4, %16) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %21 = integer_literal $Builtin.Int32, 1
  %22 = integer_literal $Builtin.Int1, -1
  %23 = builtin "sadd_with_overflow_Int32"(%13 : $Builtin.Int32, %21 : $Builtin.Int32, %22 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %24 = tuple_extract %23 : $(Builtin.Int32, Builtin.Int1), 0
  %tmpcopy = copy_value %2 : $Builtin.NativeObject
  // This release could have memory unsafe sideeffects in the deinit function.
  destroy_value %tmpcopy: $Builtin.NativeObject
  %26 = builtin "cmp_eq_Int32"(%24 : $Builtin.Int32, %5 : $Builtin.Int32) : $Builtin.Int1
  cond_br %26, bb5, bb4

bb4:
  br bb3(%24 : $Builtin.Int32)

bb5:
  br bb6(%24 : $Builtin.Int32)

bb6(%30 : $Builtin.Int32):
  destroy_value %16 : $ArrayInt
  %31 = struct $Int32 (%30 : $Builtin.Int32)
  return %31 : $Int32
}

// CHECK-LABEL: sil [ossa] @hoist_but_dont_remove_bc_after_loop :
// CHECK: bb2:
// CHECK:   [[CB:%.*]] = function_ref @checkbounds
// CHECK:   apply [[CB]]
// CHECK:   apply [[CB]]
// CHECK:   br bb3
// CHECK: bb3{{.*}}:
// CHECK:   cond_br {{.*}}, bb5, bb4
// CHECK: bb4:
// CHECK:   br bb3
// CHECK: bb5{{.*}}:
// CHECK:   apply [[CB]]
// CHECK-LABEL: } // end sil function 'hoist_but_dont_remove_bc_after_loop'
sil [ossa] @hoist_but_dont_remove_bc_after_loop : $@convention(thin) (Int32, @inout ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : $*ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = struct_extract %0 : $Int32, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = builtin "cmp_eq_Int32"(%5 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  %13 = load [copy] %1 : $*ArrayInt
  cond_br %6, bb1, bb2

bb1:
  br bb6(%5 : $Builtin.Int32)

bb2:
  br bb3(%5 : $Builtin.Int32)

bb3(%10 : $Builtin.Int32):
  %11 = struct $Int32 (%10 : $Builtin.Int32)
  %12 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %17 = apply %12(%11, %3, %13) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %18 = integer_literal $Builtin.Int32, 1
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Int32"(%10 : $Builtin.Int32, %18 : $Builtin.Int32, %19 : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 0
  %22 = tuple_extract %20 : $(Builtin.Int32, Builtin.Int1), 1
  cond_fail %22 : $Builtin.Int1, ""
  %24 = builtin "cmp_eq_Int32"(%21 : $Builtin.Int32, %4 : $Builtin.Int32) : $Builtin.Int1
  cond_br %24, bb5, bb4

bb4:
  br bb3(%21 : $Builtin.Int32)

bb5:
  %27 = function_ref @take_array : $@convention(thin) (@inout ArrayInt) -> ()
  %28 = apply %27(%1) : $@convention(thin) (@inout ArrayInt) -> ()
  %30 = apply %12(%11, %3, %13) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  br bb6(%21 : $Builtin.Int32)

bb6(%32 : $Builtin.Int32):
  destroy_value %13 : $ArrayInt
  %33 = struct $Int32 (%32 : $Builtin.Int32)
  return %33 : $Int32
}

// CHECK-LABEL: sil [ossa] @non_const_post_increment :
// CHECK-NOT:     apply
// CHECK:       bb1({{.*}}):
// CHECK:         function_ref @nonconst
// CHECK:         apply
// CHECK:         function_ref @checkbounds2
// CHECK:         apply
// CHECK:       bb2:
// CHECK:       } // end sil function 'non_const_post_increment'
sil [ossa] @non_const_post_increment : $@convention(thin) (@guaranteed Array<Int>) -> () {
bb0(%0 : @guaranteed $Array<Int>):
  %t = integer_literal $Builtin.Int1, -1
  %ts = struct $Bool (%t : $Builtin.Int1)
  %zero = integer_literal $Builtin.Int32, 0
  %one = integer_literal $Builtin.Int32, 1
  %ten = integer_literal $Builtin.Int32, 10
  br bb1(%zero : $Builtin.Int32)

bb1(%i : $Builtin.Int32):
  %a1 = builtin "sadd_with_overflow_Int32"(%i : $Builtin.Int32, %one : $Builtin.Int32, %t : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %i1 = tuple_extract %a1 : $(Builtin.Int32, Builtin.Int1), 0
  %nf = function_ref @nonconst : $@convention(thin) () -> Builtin.Int32
  %nc = apply %nf() : $@convention(thin) () -> Builtin.Int32
  %a2 = builtin "sadd_with_overflow_Int32"(%i : $Builtin.Int32, %nc : $Builtin.Int32, %t : $Builtin.Int1) : $(Builtin.Int32, Builtin.Int1)
  %idx = tuple_extract %a2 : $(Builtin.Int32, Builtin.Int1), 0
  %idxs = struct $Int32 (%idx : $Builtin.Int32)
  %f2 = function_ref @checkbounds2 : $@convention(method) (Int32, Bool, @guaranteed Array<Int>) -> _DependenceToken
  apply %f2(%idxs, %ts, %0) : $@convention(method) (Int32, Bool, @guaranteed Array<Int>) -> _DependenceToken
  %c = builtin "cmp_eq_Int32"(%i1 : $Builtin.Int32, %ten : $Builtin.Int32) : $Builtin.Int1
  cond_br %c, bb3, bb2

bb2:
  br bb1(%i1 : $Builtin.Int32)

bb3:
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil [ossa] @isNativeUnavailable1 :
// CHECK: [[ISNATIVE:%.*]] = function_ref @arrayPropertyIsNative :
// CHECK: bb1:
// CHECK: [[CHECKBOUNDS:%.*]] = function_ref @checkbounds :
// CHECK: apply [[ISNATIVE]]
// CHECK: apply [[CHECKBOUNDS]]
// CHECK: bb2
// CHECK-LABEL: } // end sil function 'isNativeUnavailable1'
sil [ossa] @isNativeUnavailable1 : $@convention(thin) (Int32, @owned ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : @owned $ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2)
  %4 = struct_extract %0, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = builtin "cmp_eq_Int32"(%5, %4) : $Builtin.Int1
  %7 = begin_borrow %1
  %8 = copy_value %7
  %9 = function_ref @arrayPropertyIsNative : $@convention(method) (@guaranteed ArrayInt) -> Bool
  %10 = apply %9(%7) : $@convention(method) (@guaranteed ArrayInt) -> Bool
  end_borrow %7
  cond_br %6, bb2, bb1

bb1:
  br bb3(%5)

bb2:
  destroy_value %8
  destroy_value %1
  br bb6(%5)

bb3(%17 : $Builtin.Int32):
  %18 = struct $Int32 (%17)
  %19 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %20 = apply %19(%18, %10, %8) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %21 = integer_literal $Builtin.Int32, 1
  %22 = integer_literal $Builtin.Int1, -1
  %23 = builtin "sadd_with_overflow_Int32"(%17, %21, %22) : $(Builtin.Int32, Builtin.Int1)
  %24 = tuple_extract %23, 0
  %25 = tuple_extract %23, 1
  cond_fail %25, ""
  %27 = builtin "cmp_eq_Int32"(%24, %4) : $Builtin.Int1
  cond_br %27, bb5, bb4

bb4:
  br bb3(%24)

bb5:
  destroy_value %8
  destroy_value %1
  br bb6(%24)

bb6(%33 : $Builtin.Int32):
  %34 = struct $Int32 (%33)
  return %34
}

// CHECK-LABEL: sil [ossa] @isNativeUnavailable2 :
// CHECK: [[ISNATIVE:%.*]] = function_ref @arrayPropertyIsNative :
// CHECK: bb1:
// CHECK: [[CHECKBOUNDS:%.*]] = function_ref @checkbounds :
// CHECK: apply [[ISNATIVE]]
// CHECK: apply [[CHECKBOUNDS]]
// CHECK: bb2
// CHECK-LABEL: } // end sil function 'isNativeUnavailable2'
sil [ossa] @isNativeUnavailable2 : $@convention(thin) (Int32, @owned ArrayInt) -> Int32 {
bb0(%0 : $Int32, %1 : @owned $ArrayInt):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2)
  %4 = struct_extract %0, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = builtin "cmp_eq_Int32"(%5, %4) : $Builtin.Int1
  %7 = copy_value %1
  %8 = copy_value %7
  %9 = function_ref @arrayPropertyIsNative : $@convention(method) (@guaranteed ArrayInt) -> Bool
  %10 = apply %9(%7) : $@convention(method) (@guaranteed ArrayInt) -> Bool
  destroy_value %7
  cond_br %6, bb2, bb1

bb1:
  br bb3(%5)

bb2:
  destroy_value %8
  destroy_value %1
  br bb6(%5)

bb3(%17 : $Builtin.Int32):
  %18 = struct $Int32 (%17)
  %19 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %20 = apply %19(%18, %10, %8) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %21 = integer_literal $Builtin.Int32, 1
  %22 = integer_literal $Builtin.Int1, -1
  %23 = builtin "sadd_with_overflow_Int32"(%17, %21, %22) : $(Builtin.Int32, Builtin.Int1)
  %24 = tuple_extract %23, 0
  %25 = tuple_extract %23, 1
  cond_fail %25, ""
  %27 = builtin "cmp_eq_Int32"(%24, %4) : $Builtin.Int1
  cond_br %27, bb5, bb4

bb4:
  br bb3(%24)

bb5:
  destroy_value %8
  destroy_value %1
  br bb6(%24)

bb6(%33 : $Builtin.Int32):
  %34 = struct $Int32 (%33)
  return %34
}

struct Wrapper {
  let arr: ArrayInt
}

// CHECK-LABEL: sil [ossa] @isNativeUnavailable3 :
// CHECK: [[ISNATIVE:%.*]] = function_ref @arrayPropertyIsNative :
// CHECK: bb1:
// CHECK: [[CHECKBOUNDS:%.*]] = function_ref @checkbounds :
// CHECK: apply [[ISNATIVE]]
// CHECK: apply [[CHECKBOUNDS]]
// CHECK: bb2
// CHECK-LABEL: } // end sil function 'isNativeUnavailable3'
sil [ossa] @isNativeUnavailable3 : $@convention(thin) (Int32, @owned Wrapper) -> Int32 {
bb0(%0 : $Int32, %1 : @owned $Wrapper):
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2)
  %4 = struct_extract %0, #Int32._value
  %5 = integer_literal $Builtin.Int32, 0
  %6 = builtin "cmp_eq_Int32"(%5, %4) : $Builtin.Int1
  %7 = begin_borrow %1
  %7a = struct_extract %7, #Wrapper.arr
  %8 = copy_value %7a
  %9 = function_ref @arrayPropertyIsNative : $@convention(method) (@guaranteed ArrayInt) -> Bool
  %10 = apply %9(%7a) : $@convention(method) (@guaranteed ArrayInt) -> Bool
  end_borrow %7
  cond_br %6, bb2, bb1

bb1:
  br bb3(%5)

bb2:
  destroy_value %8
  destroy_value %1
  br bb6(%5)

bb3(%17 : $Builtin.Int32):
  %18 = struct $Int32 (%17)
  %19 = function_ref @checkbounds : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %20 = apply %19(%18, %10, %8) : $@convention(method) (Int32, Bool, @guaranteed ArrayInt) -> _DependenceToken
  %21 = integer_literal $Builtin.Int32, 1
  %22 = integer_literal $Builtin.Int1, -1
  %23 = builtin "sadd_with_overflow_Int32"(%17, %21, %22) : $(Builtin.Int32, Builtin.Int1)
  %24 = tuple_extract %23, 0
  %25 = tuple_extract %23, 1
  cond_fail %25, ""
  %27 = builtin "cmp_eq_Int32"(%24, %4) : $Builtin.Int1
  cond_br %27, bb5, bb4

bb4:
  br bb3(%24)

bb5:
  destroy_value %8
  destroy_value %1
  br bb6(%24)

bb6(%33 : $Builtin.Int32):
  %34 = struct $Int32 (%33)
  return %34
}
