// RUN: %target-sil-opt -os-log-optimization -enable-sil-verify-all %s 2>&1 | %FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-%target-ptrsize

// SIL tests for the OSLogOptimization pass which performs compile-time analysis
// and optimization of os log APIs. This test checks specific aspects of the
// OSLogOptimization pass on hand-crafted SIL code. The tests here do not depend
// on the os log overlay.

import Swift
import Builtin

/// A type that mimics the OSLogInterpolation struct in the tests in this file.
struct OSLogInterpolationStub {
  var formatString: String
}

/// A type that mimics the OSLogMessage struct in the tests in this file.
struct OSLogMessageStub {
  var interpolation: OSLogInterpolationStub
}

/// A stub for OSLogMessage.init.
sil [Onone] [_semantics "constant_evaluable"] [_semantics "oslog.message.init_stub"] @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub {
bb0(%0 : $String):
  %1 = struct $OSLogInterpolationStub(%0 : $String)
  %2 = struct $OSLogMessageStub (%1 : $OSLogInterpolationStub)
  return %2 : $OSLogMessageStub
}

// String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
sil [serialized] [always_inline] [readonly] [_semantics "string.makeUTF8"] @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String

/// A function that models the use of a string in some arbitrary way.
sil @useFormatString: $@convention(thin) (@guaranteed String) -> ()

// CHECK-LABEL: @testConstantFoldingOfStructExtract
sil [ossa] @testConstantFoldingOfStructExtract : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub

  // Use the formatString property of OSLogMessageStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %8 = begin_borrow %7 : $OSLogMessageStub
  %9 = struct_extract %8 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %10 = struct_extract %9 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  %11 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  %12 = apply %11(%10) : $@convention(thin) (@guaranteed String) -> ()
  end_borrow %8 : $OSLogMessageStub
  destroy_value %7 : $OSLogMessageStub
  %13 = tuple ()
  return %13 : $()
    // CHECK-NOT: {{%.*}} = struct_extract {{%.*}} : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
    // CHECK-DAG: [[STRINGUSE:%[0-9]+]] = function_ref @useFormatString
    // CHECK-DAG: {{%.*}} = apply [[STRINGUSE]]([[BORROW:%[0-9]+]])
    // CHECK-DAG: [[BORROW]] = begin_borrow [[STRINGCONST:%[0-9]+]]
    // CHECK-DAG: [[STRINGCONST]] = apply [[STRINGINIT:%[0-9]+]]([[LIT:%[0-9]+]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK-DAG: [[STRINGINIT]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK-DAG: [[LIT]] = string_literal utf8 "test message: %lld"
    // CHECK-DAG: destroy_value [[STRINGCONST]] : $String
}

// CHECK-LABEL: @testConstantFoldingOfOwnedValue
sil [ossa] @testConstantFoldingOfOwnedValue : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub

  // Extract the formatString property of OSLogMessageStub as a owned value and
  // use it. The uses of this owned value should be constant folded.
  %8 = function_ref @extractFormatStringAsOwned : $@convention(thin) (@guaranteed OSLogMessageStub) -> @owned String
  %9 = apply %8(%7) : $@convention(thin) (@guaranteed OSLogMessageStub) -> @owned String
  %11 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  %12 = apply %11(%9) : $@convention(thin) (@guaranteed String) -> ()
  destroy_value %7 : $OSLogMessageStub
  destroy_value %9 : $String
  %13 = tuple ()
  return %13 : $()
    // CHECK-DAG: [[STRINGUSE:%[0-9]+]] = function_ref @useFormatString
    // CHECK-DAG: {{%.*}} = apply [[STRINGUSE]]([[STRINGCONST:%[0-9]+]])
    // CHECK-DAG: [[STRINGCONST]] = apply [[STRINGINIT:%[0-9]+]]([[LIT:%[0-9]+]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK-DAG: [[STRINGINIT]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK-DAG: [[LIT]] = string_literal utf8 "test message: %lld"
    // FIXME: function_ref @extractFormatStringAsOwned will not be removed as of
    // now by OSLogOptimization pass even though it is folded as function calls
    // are not dead-code eliminated.
}

sil [ossa] [_semantics "constant_evaluable"] @extractFormatStringAsOwned : $@convention(thin) (@guaranteed OSLogMessageStub) -> @owned String {
bb0(%0 : @guaranteed $OSLogMessageStub):
  %1 = struct_extract %0 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %2 = struct_extract %1 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  %3 = copy_value %2 : $String
  return %3 : $String
}

// CHECK-LABEL: @testConstantFoldingOfDestructureStruct
sil [ossa] @testConstantFoldingOfDestructureStruct : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub

  // Destructure the OSLogMessage instance and use the formatString property
  // which should be constant folded by the OSLogOptimization pass.
  (%8) = destructure_struct %7 : $OSLogMessageStub
  (%9) = destructure_struct %8 : $OSLogInterpolationStub
  %10 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  %11 = apply %10(%9) : $@convention(thin) (@guaranteed String) -> ()
  destroy_value %9 : $String
  %12 = tuple ()
  return %12 : $()
    // CHECK-NOT: ({{%.*}}) = destructure_struct {{%.*}} : $OSLogInterpolationStub
    // CHECK-DAG: [[STRINGUSE:%[0-9]+]] = function_ref @useFormatString
    // CHECK-DAG: {{%.*}} = apply [[STRINGUSE]]([[STRINGCONST:%[0-9]+]])
    // CHECK-DAG: [[STRINGCONST]] = apply [[STRINGINIT:%[0-9]+]]([[LIT:%[0-9]+]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK-DAG: [[STRINGINIT]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK-DAG: [[LIT]] = string_literal utf8 "test message: %lld"
    // CHECK-DAG: destroy_value [[STRINGCONST]] : $String
}

// Test that the OSLogOptimization pass does not fold instructions that define
// ownership scopes like `begin_borrow`, and `copy_value`.
// CHECK-LABEL: @testNonFoldingOfOwnershipScopes
sil [ossa] @testNonFoldingOfOwnershipScopes : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub

  // Use the formatString property of OSLogMessageStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %8 = begin_borrow %7 : $OSLogMessageStub
  %9 = struct_extract %8 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %10 = struct_extract %9 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  %11 = copy_value %10 : $String
  %12 = begin_borrow %11 : $String
  %13 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  %14 = apply %13(%12) : $@convention(thin) (@guaranteed String) -> ()
  end_borrow %12 : $String
  destroy_value %11 : $String
  end_borrow %8 : $OSLogMessageStub
  destroy_value %7 : $OSLogMessageStub
  %15 = tuple ()
  return %15 : $()
    // CHECK-NOT: {{%.*}} = struct_extract {{%.*}} : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
    // CHECK-DAG: [[STRINGUSE:%[0-9]+]] = function_ref @useFormatString
    // CHECK-DAG: {{%.*}} = apply [[STRINGUSE]]([[BORROW:%[0-9]+]])
    // CHECK-DAG: [[BORROW]] = begin_borrow [[COPYVAL:%[0-9]+]]
    // CHECK-DAG: [[COPYVAL]] = copy_value [[BORROW2:%[0-9]+]]
    // CHECK-DAG: [[BORROW2]] = begin_borrow [[STRINGCONST:%[0-9]+]]
    // CHECK-DAG: [[STRINGCONST]] = apply [[STRINGINIT:%[0-9]+]]([[LIT:%[0-9]+]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK-DAG: [[STRINGINIT]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK-DAG: [[LIT]] = string_literal utf8 "test message: %lld"
    // CHECK-DAG: destroy_value [[STRINGCONST]] : $String
}

// CHECK-LABEL: @testConstantFoldingOfStructExtractNonOSSA
sil @testConstantFoldingOfStructExtractNonOSSA : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub

  // Use the formatString property of OSLogMessageStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %9 = struct_extract %7 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %10 = struct_extract %9 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  %11 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  %12 = apply %11(%10) : $@convention(thin) (@guaranteed String) -> ()
  release_value %7 : $OSLogMessageStub
  %13 = tuple ()
  return %13 : $()
    // CHECK-NOT: {{%.*}} = struct_extract {{%.*}} : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
    // CHECK-DAG: [[STRINGUSE:%[0-9]+]] = function_ref @useFormatString
    // CHECK-DAG: {{%.*}} = apply [[STRINGUSE]]([[STRINGCONST:%[0-9]+]])
    // CHECK-DAG: [[STRINGCONST]] = apply [[STRINGINIT:%[0-9]+]]([[LIT:%[0-9]+]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK-DAG: [[STRINGINIT]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK-DAG: [[LIT]] = string_literal utf8 "test message: %lld"
    // CHECK-DAG: release_value [[STRINGCONST]] : $String
}

// CHECK-LABEL: @testFoldingWithManyReleaseRetains
sil @testFoldingWithManyReleaseRetains : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub

  // Use the formatString property of OSLogMessageStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %9 = struct_extract %7 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %10 = struct_extract %9 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  retain_value %10 : $String
  %11 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  %12 = apply %11(%10) : $@convention(thin) (@guaranteed String) -> ()
  release_value %10 : $String
  release_value %7 : $OSLogMessageStub
  %13 = tuple ()
  return %13 : $()
    // CHECK-DAG: [[STRINGUSE:%[0-9]+]] = function_ref @useFormatString
    // CHECK-DAG: {{%.*}} = apply [[STRINGUSE]]([[STRINGCONST:%[0-9]+]])
    // CHECK-DAG: [[STRINGCONST]] = apply [[STRINGINIT:%[0-9]+]]([[LIT:%[0-9]+]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK-DAG: [[STRINGINIT]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK-DAG: [[LIT]] = string_literal utf8 "test message: %lld"
    // CHECK-DAG: release_value [[STRINGCONST]] : $String
    // FIXME: Here struct_extract is not dead code eliminated by the
    // optimization pass.
}

// CHECK-LABEL: @testPostdominatorComputation
sil [ossa] @testPostdominatorComputation : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %8 = begin_borrow %7 : $OSLogMessageStub
  %14 = struct_extract %8 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %15 = struct_extract %14 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  %9 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  cond_br %2, bb1, bb4

  // Use the OSLogMessage instance along different branches. The following code
  // deliberately uses a borrowed operation like struct_extract so that when it
  // is replaced with a folded value, it needs to be destroyed at the post-
  // dominating points of its uses.
bb1:
  %10 = struct_extract %8 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %11 = struct_extract %10 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  cond_br %2, bb2, bb3
    // Check release of the folded value of %15.
    // CHECK-LABEL: bb1:
    // CHECK: destroy_value [[STRINGCONST1:%[0-9]+]] : $String

bb2:
  %12 = apply %9(%11) : $@convention(thin) (@guaranteed String) -> ()
  br exit
    // Check release of the folded value of %11.
    // CHECK-LABEL: bb2:
    // CHECK: destroy_value [[STRINGCONST2:%[0-9]+]] : $String

bb3:
  %13 = apply %9(%11) : $@convention(thin) (@guaranteed String) -> ()
  br exit
    // Check release of the folded value of %11.
    // CHECK-LABEL: bb3:
    // CHECK: destroy_value [[STRINGCONST2]] : $String

bb4:
  %16 = apply %9(%15) : $@convention(thin) (@guaranteed String) -> ()
  br exit
    // Check release of the folded value of %15.
    // CHECK-LABEL: bb4:
    // CHECK: destroy_value [[STRINGCONST1]] : $String

exit:
  end_borrow %8 : $OSLogMessageStub
  destroy_value %7 : $OSLogMessageStub
  %17 = tuple ()
  return %17 : $()
}

// CHECK-LABEL: @testPostdominatorComputationNonOSSA
sil @testPostdominatorComputationNonOSSA : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %14 = struct_extract %7 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %15 = struct_extract %14 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  %9 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  cond_br %2, bb1, bb4

  // Use the OSLogMessage instance along different branches. The following code
  // deliberately uses a borrowed operation like struct_extract so that when it
  // is replaced with a folded value, it needs to be destroyed at the post-
  // dominating points of its uses.
bb1:
  %10 = struct_extract %7 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %11 = struct_extract %10 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  cond_br %2, bb2, bb3
    // Check release of the folded value of %15.
    // CHECK-LABEL: bb1:
    // CHECK-NEXT: release_value [[STRINGCONST1:%[0-9]+]] : $String

bb2:
  %12 = apply %9(%11) : $@convention(thin) (@guaranteed String) -> ()
  br exit
    // Check release of the folded value of %11.
    // CHECK-LABEL: bb2:
    // CHECK: release_value [[STRINGCONST2:%[0-9]+]] : $String

bb3:
  %13 = apply %9(%11) : $@convention(thin) (@guaranteed String) -> ()
  br exit
    // Check release of the folded value of %11.
    // CHECK-LABEL: bb3:
    // CHECK: release_value [[STRINGCONST2]] : $String

bb4:
  %16 = apply %9(%15) : $@convention(thin) (@guaranteed String) -> ()
  br exit
    // Check release of the folded value of %15.
    // CHECK-LABEL: bb4:
    // CHECK: release_value [[STRINGCONST1]] : $String

exit:
  release_value %7 : $OSLogMessageStub
  %17 = tuple ()
  return %17 : $()
}

// This test checks whether values that are transitively data dependent on
// an OSLogMessage instance are folded. These can be alive even beyond the
// lifetime of OSLogMessage.
// CHECK-LABEL: @testFoldingOfTransitiveDataDependencies
sil [ossa] @testFoldingOfTransitiveDataDependencies : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStub instance.
  %0 = string_literal utf8 "test message: %lld"
  %1 = integer_literal $Builtin.Word, 18
  %2 = integer_literal $Builtin.Int1, -1
  %3 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %6 = function_ref @oslogMessageInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %7 = apply %6(%5) : $@convention(thin) (@owned String) -> @owned OSLogMessageStub
  %8 = copy_value %7 : $OSLogMessageStub
  destroy_value %7 : $OSLogMessageStub
  %10 = begin_borrow %8 : $OSLogMessageStub
  %14 = struct_extract %10 : $OSLogMessageStub, #OSLogMessageStub.interpolation
  %15 = struct_extract %14 : $OSLogInterpolationStub, #OSLogInterpolationStub.formatString
  %12 = copy_value %15 : $String
  end_borrow %10 : $OSLogMessageStub
  destroy_value %8 : $OSLogMessageStub
  %9 = function_ref @useFormatString : $@convention(thin) (@guaranteed String) -> ()
  %16 = apply %9(%12) : $@convention(thin) (@guaranteed String) -> ()
  destroy_value %12 : $String
  %17 = tuple ()
  return %17 : $()
    // CHECK-DAG: [[STRINGUSE:%[0-9]+]] = function_ref @useFormatString
    // CHECK-DAG: {{%.*}} = apply [[STRINGUSE]]([[CONSTCOPY:%[0-9]+]])
    // CHECK-DAG: [[CONSTCOPY]] = copy_value [[BORROW:%[0-9]+]]
    // CHECK-DAG: [[BORROW]] = begin_borrow [[STRINGCONST:%[0-9]+]]
    // CHECK-DAG: [[STRINGCONST]] = apply [[STRINGINIT:%[0-9]+]]([[LIT:%[0-9]+]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK-DAG: [[STRINGINIT]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK-DAG: [[LIT]] = string_literal utf8 "test message: %lld"
    // CHECK-DAG: destroy_value [[STRINGCONST]] : $String
}

// Check folding of arrays by the OSLogOptimization pass.

/// A simplified stub for OSLogInterpolation type for testing array folding.
struct OSLogInterpolationArrayStub {
  var arguments: [Int64]
}

/// A simplified stub for OSLogMessage for testing array folding.
struct OSLogMessageArrayStub {
  var interpolation: OSLogInterpolationArrayStub
}

/// A stub for OSLogMessage.init. The optimization is driven by this function.
/// This function must take at least one argument which is required by the pass.
sil [Onone] [_semantics "constant_evaluable"] [_semantics "oslog.message.init_stub"] @oslogMessageArrayStubInit : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub {
bb0(%0 : $Builtin.Int1):
  // Create an array with elements 99, 98 and 90
  %1 = integer_literal $Builtin.Word, 3
  // function_ref _allocateUninitializedArray<A>(_:)
  %2 = function_ref @$ss27_allocateUninitializedArrayySayxG_BptBwlF : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer)
  %3 = apply %2<Int64>(%1) : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer)
  %4 = tuple_extract %3 : $(Array<Int64>, Builtin.RawPointer), 0
  %5 = tuple_extract %3 : $(Array<Int64>, Builtin.RawPointer), 1
  %6 = pointer_to_address %5 : $Builtin.RawPointer to [strict] $*Int64
  %7 = integer_literal $Builtin.Int64, 99
  %8 = struct $Int64 (%7 : $Builtin.Int64)
  store %8 to %6 : $*Int64
  %10 = integer_literal $Builtin.Word, 1
  %11 = index_addr %6 : $*Int64, %10 : $Builtin.Word
  %12 = integer_literal $Builtin.Int64, 98
  %13 = struct $Int64 (%12 : $Builtin.Int64)
  store %13 to %11 : $*Int64
  %15 = integer_literal $Builtin.Word, 2
  %16 = index_addr %6 : $*Int64, %15 : $Builtin.Word
  %17 = integer_literal $Builtin.Int64, 90
  %18 = struct $Int64 (%17 : $Builtin.Int64)
  store %18 to %16 : $*Int64

  // Create an instance of OSLogMessageArrayStub using the above array.
  %20 = struct $OSLogInterpolationArrayStub(%4 : $Array<Int64>)
  %21 = struct $OSLogMessageArrayStub(%20 : $OSLogInterpolationArrayStub)
  return %21 : $OSLogMessageArrayStub
}

// _allocateUninitializedArray<A>(_:)
sil [serialized] [always_inline] [_semantics "array.uninitialized_intrinsic"] @$ss27_allocateUninitializedArrayySayxG_BptBwlF : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer)

/// A function that models the use of an array.
sil @useArray: $@convention(thin) (@guaranteed Array<Int64>) -> ()

// CHECK-LABEL: @testConstantFoldingOfArray
sil [ossa] @testConstantFoldingOfArray : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageArrayStub instance.
  %0 = integer_literal $Builtin.Int1, 1
  %1 = function_ref @oslogMessageArrayStubInit : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub
  %2 = apply %1(%0) : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub

  // Use the arguments property of OSLogMessageArrayStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %3 = begin_borrow %2 : $OSLogMessageArrayStub
  %4 = struct_extract %3 : $OSLogMessageArrayStub, #OSLogMessageArrayStub.interpolation
  %5 = struct_extract %4 : $OSLogInterpolationArrayStub, #OSLogInterpolationArrayStub.arguments
  %6 = function_ref @useArray : $@convention(thin) (@guaranteed Array<Int64>) -> ()
  %7 = apply %6(%5) : $@convention(thin) (@guaranteed Array<Int64>) -> ()
  end_borrow %3 : $OSLogMessageArrayStub
  destroy_value %2 : $OSLogMessageArrayStub
  %8 = tuple ()
  return %8 : $()
    // CHECK: [[ELEM1:%[0-9]+]] = integer_literal $Builtin.Int64, 99
    // CHECK: [[ELEM1INT:%[0-9]+]] = struct $Int64 ([[ELEM1]] : $Builtin.Int64)
    // CHECK: [[ELEM2:%[0-9]+]] = integer_literal $Builtin.Int64, 98
    // CHECK: [[ELEM2INT:%[0-9]+]] = struct $Int64 ([[ELEM2]] : $Builtin.Int64)
    // CHECK: [[ELEM3:%[0-9]+]] = integer_literal $Builtin.Int64, 90
    // CHECK: [[ELEM3INT:%[0-9]+]] = struct $Int64 ([[ELEM3]] : $Builtin.Int64)
    // CHECK: [[NUMELEMS:%[0-9]+]] = integer_literal $Builtin.Word, 3
    // CHECK: [[ALLOCATORREF:%[0-9]+]] = function_ref @$ss27_allocateUninitializedArrayySayxG_BptBwlF
    // CHECK: [[TUPLE:%[0-9]+]] = apply [[ALLOCATORREF]]<Int64>([[NUMELEMS]])
    // CHECK: ([[ARRAY:%[0-9]+]], [[STORAGEPTR:%[0-9]+]]) = destructure_tuple [[TUPLE]]
    // CHECK: [[BORROW:%[0-9]+]] = begin_borrow [[ARRAY]]
    // CHECK: [[STORAGEADDR:%[0-9]+]] = pointer_to_address [[STORAGEPTR]] : $Builtin.RawPointer to [strict] $*Int64
    // CHECK: store [[ELEM1INT]] to [trivial] [[STORAGEADDR]] : $*Int64
    // CHECK: [[INDEX1:%[0-9]+]] = integer_literal $Builtin.Word, 1
    // CHECK: [[INDEXADDR1:%[0-9]+]] = index_addr [[STORAGEADDR]] : $*Int64, [[INDEX1]] : $Builtin.Word
    // CHECK: store [[ELEM2INT]] to [trivial] [[INDEXADDR1]] : $*Int64
    // CHECK: [[INDEX2:%[0-9]+]] = integer_literal $Builtin.Word, 2
    // CHECK: [[INDEXADDR2:%[0-9]+]] = index_addr [[STORAGEADDR]] : $*Int64, [[INDEX2]] : $Builtin.Word
    // CHECK: store [[ELEM3INT]] to [trivial] [[INDEXADDR2]] : $*Int64
    // CHECK: [[USEREF:%[0-9]+]] = function_ref @useArray
    // CHECK: apply [[USEREF]]([[BORROW]])
    // CHECK: end_borrow [[BORROW]]
    // CHECK: destroy_value [[ARRAY]] : $Array<Int64>
}

// CHECK-LABEL: @testConstantFoldingOfArrayNonOSSA
sil @testConstantFoldingOfArrayNonOSSA : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageArrayStub instance.
  %0 = integer_literal $Builtin.Int1, 1
  %1 = function_ref @oslogMessageArrayStubInit : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub
  %2 = apply %1(%0) : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub

  // Use the arguments property of OSLogMessageArrayStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %4 = struct_extract %2 : $OSLogMessageArrayStub, #OSLogMessageArrayStub.interpolation
  %5 = struct_extract %4 : $OSLogInterpolationArrayStub, #OSLogInterpolationArrayStub.arguments
  %6 = function_ref @useArray : $@convention(thin) (@guaranteed Array<Int64>) -> ()
  %7 = apply %6(%5) : $@convention(thin) (@guaranteed Array<Int64>) -> ()
  release_value %2 : $OSLogMessageArrayStub
  %8 = tuple ()
  return %8 : $()
    // CHECK: [[ELEM1:%[0-9]+]] = integer_literal $Builtin.Int64, 99
    // CHECK: [[ELEM1INT:%[0-9]+]] = struct $Int64 ([[ELEM1]] : $Builtin.Int64)
    // CHECK: [[ELEM2:%[0-9]+]] = integer_literal $Builtin.Int64, 98
    // CHECK: [[ELEM2INT:%[0-9]+]] = struct $Int64 ([[ELEM2]] : $Builtin.Int64)
    // CHECK: [[ELEM3:%[0-9]+]] = integer_literal $Builtin.Int64, 90
    // CHECK: [[ELEM3INT:%[0-9]+]] = struct $Int64 ([[ELEM3]] : $Builtin.Int64)
    // CHECK: [[NUMELEMS:%[0-9]+]] = integer_literal $Builtin.Word, 3
    // CHECK: [[ALLOCATORREF:%[0-9]+]] = function_ref @$ss27_allocateUninitializedArrayySayxG_BptBwlF
    // CHECK: [[TUPLE:%[0-9]+]] = apply [[ALLOCATORREF]]<Int64>([[NUMELEMS]])
    // CHECK: [[ARRAY:%[0-9]+]] = tuple_extract [[TUPLE]] : $(Array<Int64>, Builtin.RawPointer), 0
    // CHECK: [[STORAGEPTR:%[0-9]+]] = tuple_extract [[TUPLE]] : $(Array<Int64>, Builtin.RawPointer), 1
    // CHECK: [[STORAGEADDR:%[0-9]+]] = pointer_to_address [[STORAGEPTR]] : $Builtin.RawPointer to [strict] $*Int64
    // CHECK: store [[ELEM1INT]] to [[STORAGEADDR]] : $*Int64
    // CHECK: [[INDEX1:%[0-9]+]] = integer_literal $Builtin.Word, 1
    // CHECK: [[INDEXADDR1:%[0-9]+]] = index_addr [[STORAGEADDR]] : $*Int64, [[INDEX1]] : $Builtin.Word
    // CHECK: store [[ELEM2INT]] to [[INDEXADDR1]] : $*Int64
    // CHECK: [[INDEX2:%[0-9]+]] = integer_literal $Builtin.Word, 2
    // CHECK: [[INDEXADDR2:%[0-9]+]] = index_addr [[STORAGEADDR]] : $*Int64, [[INDEX2]] : $Builtin.Word
    // CHECK: store [[ELEM3INT]] to [[INDEXADDR2]] : $*Int64
    // CHECK: [[USEREF:%[0-9]+]] = function_ref @useArray
    // CHECK: apply [[USEREF]]([[ARRAY]])
    // CHECK: release_value [[ARRAY]] : $Array<Int64>
}

/// A stub for OSLogMessage.init. The optimization is driven by this function.
/// This function must take at least one argument which is required by the pass.
sil [Onone] [_semantics "constant_evaluable"] [_semantics "oslog.message.init_stub"] @oslogMessageStubEmptyArrayInit : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub {
bb0(%0 : $Builtin.Int1):
  // Create an empty array
  %1 = integer_literal $Builtin.Word, 0
  // function_ref _allocateUninitializedArray<A>(_:)
  %2 = function_ref @$ss27_allocateUninitializedArrayySayxG_BptBwlF : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer)
  %3 = apply %2<Int64>(%1) : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer)
  %4 = tuple_extract %3 : $(Array<Int64>, Builtin.RawPointer), 0

  // Create an instance of OSLogMessageArrayStub using the above array.
  %20 = struct $OSLogInterpolationArrayStub(%4 : $Array<Int64>)
  %21 = struct $OSLogMessageArrayStub(%20 : $OSLogInterpolationArrayStub)
  return %21 : $OSLogMessageArrayStub
}

// CHECK-LABEL: @testConstantFoldingOfEmptyArray
sil [ossa] @testConstantFoldingOfEmptyArray : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageArrayStub instance.
  %0 = integer_literal $Builtin.Int1, 1
  %1 = function_ref @oslogMessageStubEmptyArrayInit : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub
  %2 = apply %1(%0) : $@convention(thin) (Builtin.Int1) -> @owned OSLogMessageArrayStub

  // Use the arguments property of OSLogMessageArrayStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %3 = begin_borrow %2 : $OSLogMessageArrayStub
  %4 = struct_extract %3 : $OSLogMessageArrayStub, #OSLogMessageArrayStub.interpolation
  %5 = struct_extract %4 : $OSLogInterpolationArrayStub, #OSLogInterpolationArrayStub.arguments
  %6 = function_ref @useArray : $@convention(thin) (@guaranteed Array<Int64>) -> ()
  %7 = apply %6(%5) : $@convention(thin) (@guaranteed Array<Int64>) -> ()
  end_borrow %3 : $OSLogMessageArrayStub
  destroy_value %2 : $OSLogMessageArrayStub
  %8 = tuple ()
  return %8 : $()
    // CHECK: [[NUMELEMS:%[0-9]+]] = integer_literal $Builtin.Word, 0
    // CHECK: [[ALLOCATORREF:%[0-9]+]] = function_ref @$ss27_allocateUninitializedArrayySayxG_BptBwlF
    // CHECK: [[TUPLE:%[0-9]+]] = apply [[ALLOCATORREF]]<Int64>([[NUMELEMS]])
    // CHECK: ([[ARRAY:%[0-9]+]], [[STORAGEPTR:%[0-9]+]]) = destructure_tuple [[TUPLE]]
    // CHECK: [[BORROW:%[0-9]+]] = begin_borrow [[ARRAY]]
    // CHECK: [[USEREF:%[0-9]+]] = function_ref @useArray
    // CHECK: apply [[USEREF]]([[BORROW]])
    // CHECK: end_borrow [[BORROW]]
    // CHECK: destroy_value [[ARRAY]] : $Array<Int64>
}

/// A simplified stub for OSLogInterpolation type for testing folding of array
/// of strings.
struct OSLogInterpolationStringArrayStub {
  var arguments: [String]
}

/// A simplified stub for OSLogMessage for testing folding of array of strings.
struct OSLogMessageStringArrayStub {
  var interpolation: OSLogInterpolationStringArrayStub
}

/// A stub for OSLogMessage.init. The os_log optimization is driven by this
/// function. This function must take at least one argument which is required
/// by the pass.
sil [Onone] [_semantics "constant_evaluable"] [_semantics "oslog.message.init_stub"] @oslogMessageStringArrayStubInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStringArrayStub {
bb0(%0 : $String):
  // Create an array with one element "a"
  %1 = integer_literal $Builtin.Word, 1
  // function_ref _allocateUninitializedArray<A>(_:)
  %2 = function_ref @$ss27_allocateUninitializedArrayySayxG_BptBwlF : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer)
  %3 = apply %2<String>(%1) : $@convention(thin) <τ_0_0> (Builtin.Word) -> (@owned Array<τ_0_0>, Builtin.RawPointer)
  %4 = tuple_extract %3 : $(Array<String>, Builtin.RawPointer), 0
  %5 = tuple_extract %3 : $(Array<String>, Builtin.RawPointer), 1
  %6 = pointer_to_address %5 : $Builtin.RawPointer to [strict] $*String
  store %0 to %6 : $*String

  // Create an instance of OSLogMessageArrayStub using the above array.
  %20 = struct $OSLogInterpolationStringArrayStub(%4 : $Array<String>)
  %21 = struct $OSLogMessageStringArrayStub(%20 : $OSLogInterpolationStringArrayStub)
  return %21 : $OSLogMessageStringArrayStub
}

/// A function that models the use of an array.
sil @useArrayString: $@convention(thin) (@guaranteed Array<String>) -> ()

// CHECK-LABEL: @testConstantFoldingOfStringArray
sil [ossa] @testConstantFoldingOfStringArray : $@convention(thin) () -> () {
bb0:
  // Construct an OSLogMessageStringArrayStub instance.
  %10 = string_literal utf8 "ab"
  %11 = integer_literal $Builtin.Word, 2
  %12 = integer_literal $Builtin.Int1, -1
  %13 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %14 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %15 = apply %14(%10, %11, %12, %13) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type)   -> @owned String
  %1 = function_ref @oslogMessageStringArrayStubInit : $@convention(thin) (@owned String) -> @owned OSLogMessageStringArrayStub
  %2 = apply %1(%15) : $@convention(thin) (@owned String) -> @owned OSLogMessageStringArrayStub

  // Use the arguments property of OSLogMessageStringArrayStub which will be constant
  // folded by the OSLogOptimization pass, as checked below.
  %3 = begin_borrow %2 : $OSLogMessageStringArrayStub
  %4 = struct_extract %3 : $OSLogMessageStringArrayStub, #OSLogMessageStringArrayStub.interpolation
  %5 = struct_extract %4 : $OSLogInterpolationStringArrayStub, #OSLogInterpolationStringArrayStub.arguments
  %6 = function_ref @useArrayString : $@convention(thin) (@guaranteed Array<String>) -> ()
  %7 = apply %6(%5) : $@convention(thin) (@guaranteed Array<String>) -> ()
  end_borrow %3 : $OSLogMessageStringArrayStub
  destroy_value %2 : $OSLogMessageStringArrayStub
  %8 = tuple ()
  return %8 : $()
    // Skip the first instance of "ab".
    // CHECK: [[LIT:%[0-9]+]] = string_literal utf8 "ab"
    // CHECK: [[LIT:%[0-9]+]] = string_literal utf8 "ab"
    // CHECK: [[STRINGINIT:%[0-9]+]] = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC
    // CHECK: [[STRINGCONST:%[0-9]+]] = apply [[STRINGINIT]]([[LIT]], {{%.*}}, {{%.*}}, {{%.*}})
    // CHECK: [[NUMELEMS:%[0-9]+]] = integer_literal $Builtin.Word, 1
    // CHECK: [[ALLOCATORREF:%[0-9]+]] = function_ref @$ss27_allocateUninitializedArrayySayxG_BptBwlF
    // CHECK: [[TUPLE:%[0-9]+]] = apply [[ALLOCATORREF]]<String>([[NUMELEMS]])
    // CHECK: ([[ARRAY:%[0-9]+]], [[STORAGEPTR:%[0-9]+]]) = destructure_tuple [[TUPLE]]
    // CHECK: [[BORROW:%[0-9]+]] = begin_borrow [[ARRAY]]
    // CHECK: [[STORAGEADDR:%[0-9]+]] = pointer_to_address [[STORAGEPTR]] : $Builtin.RawPointer to [strict] $*String
    // CHECK: store [[STRINGCONST]] to [init] [[STORAGEADDR]] : $*String
    // CHECK: [[USEREF:%[0-9]+]] = function_ref @useArrayString
    // CHECK: apply [[USEREF]]([[BORROW]])
    // CHECK: end_borrow [[BORROW]]
    // CHECK: destroy_value [[ARRAY]] : $Array<String>
}
