// RUN: %target-sil-opt -sil-print-types --onone-simplification %s | %FileCheck %s

// REQUIRES: swift_in_compiler

import Builtin
import Swift

class Klass {}

enum EnumTy: ~Copyable {
    case klass(Klass)
    case int(Builtin.Word)
}

// CHECK-LABEL: sil [ossa] @test_switch_trivial_arm
sil [ossa] @test_switch_trivial_arm : $@convention(thin) (@guaranteed EnumTy) -> () {
entry(%a : @guaranteed $EnumTy):
  %b = explicit_copy_value %a : $EnumTy
  // CHECK: [[MOVE:%.*]] = move_value
  %c = move_value %b : $EnumTy
  // CHECK: [[BORROW:%.*]] = begin_borrow [[MOVE]]
  %d = begin_borrow %c : $EnumTy
  // CHECK: switch_enum [[BORROW]] : {{.*}}, case #EnumTy.int!enumelt: [[INTBB:bb[0-9]+]]
  switch_enum %d : $EnumTy, case #EnumTy.klass!enumelt: klass, case #EnumTy.int!enumelt: int

klass(%e : @guaranteed $Klass):
  end_borrow %d : $EnumTy
  %f = unchecked_enum_data %c : $EnumTy, #EnumTy.klass!enumelt
  destroy_value %f : $Klass
  br end

// We shouldn't remove the `unchecked_enum_data` here because it consumes the
// original enum, even though it otherwise appears dead.
// CHECK: [[INTBB]]({{.*}}):
int(%p : $Builtin.Word):
  // CHECK: end_borrow [[BORROW]]
  end_borrow %d : $EnumTy
  // CHECK: unchecked_enum_data [[MOVE]]
  %q = unchecked_enum_data %c : $EnumTy, #EnumTy.int!enumelt
  br end

end:
  return undef : $()
}

sil @use_span : $@convention(thin) (@guaranteed Span<Int>) -> ()

// CHECK-LABEL: span_count_cond_fail :
// CHECK: mark_dependence [nonescaping]
// CHECK-NOT: cond_fail
// CHECK-LABEL: }
sil [ossa] @span_count_cond_fail : $@convention(thin) (Optional<UnsafeRawPointer>, @guaranteed Array<Int>) -> () {
bb0(%0 : $Optional<UnsafeRawPointer>, %1 : @guaranteed $Array<Int>):
  %2 = integer_literal $Builtin.Int64, 1
  %3 = integer_literal $Builtin.Int64, 0
  %4 = struct $Int (%2)
  %5 = struct $Span<Int> (%0, %4)
  %6 = mark_dependence [nonescaping] %5 on %1
  %7 = struct_extract %6, #Span._count
  %8 = struct_extract %7, #Int._value
  %9 = builtin "assumeNonNegative_Int64"(%8) : $Builtin.Int64
  %10 = builtin "cmp_sge_Int64"(%3, %9) : $Builtin.Int1
  cond_fail %10, "Index out of bounds"
  %12 = function_ref @use_span : $@convention(thin) (@guaranteed Span<Int>) -> ()
  apply %12(%6) : $@convention(thin) (@guaranteed Span<Int>) -> ()
  %t = tuple ()
  return %t
}

