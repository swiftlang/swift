# swift/test/lit.cfg - Configuration for the 'lit' test runner -*- python -*-
#
# This source file is part of the Swift.org open source project
#
# Copyright (c) 2014 - 2021 Apple Inc. and the Swift project authors
# Licensed under Apache License v2.0 with Runtime Library Exception
#
# See https://swift.org/LICENSE.txt for license information
# See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
# -----------------------------------------------------------------------------
#
# This is a configuration file for the 'lit' test runner.
#
# Refer to docs/Testing.md for documentation.
#
# Update docs/Testing.md when changing this file.
#
# -----------------------------------------------------------------------------

import glob
import json
import os
import platform
import re
import shlex
import shutil
import socket
import subprocess
import sys

import lit
import lit.formats
import lit.util

import site
site.addsitedir(os.path.dirname(__file__))
import swift_test

def make_path(*args):
    return os.path.normpath(os.path.join(*args))

#
# Helper functions.
#

def darwin_get_sdk_version(sdk_path):
    system_version_plist_path = make_path(sdk_path, "System", "Library",
                                          "CoreServices", "SystemVersion.plist")
    name = subprocess.check_output(
        ["defaults", "read", system_version_plist_path,
         "ProductName"]).rstrip()
    vers = subprocess.check_output(
        ["defaults", "read", system_version_plist_path,
         "ProductVersion"]).rstrip()
    build = subprocess.check_output(
        ["defaults", "read", system_version_plist_path,
         "ProductBuildVersion"]).rstrip()
    return (name, vers, build)

# Run sw_vers on the target to be tested and return the results.
def darwin_get_sw_vers(commandPrefix=[]):
    name = lit.util.executeCommand(
        commandPrefix + ['/usr/bin/sw_vers', '-productName'])[0].rstrip()
    vers = lit.util.executeCommand(
        commandPrefix + ['/usr/bin/sw_vers', '-productVersion'])[0].rstrip()
    build = lit.util.executeCommand(
        commandPrefix + ['/usr/bin/sw_vers', '-buildVersion'])[0].rstrip()
    return (name, vers, build)

def darwin_get_ios_sim_vers():
    sim_output = subprocess.check_output(['xcrun', 'simctl', 'list', 'runtimes'])
    ios_version_str = re.findall(r'iOS \d+\.*\d*', sim_output.decode('utf-8'))
    return [float(v.strip('iOS')) for v in ios_version_str]

def darwin_get_watchos_sim_vers():
    sim_output = subprocess.check_output(['xcrun', 'simctl', 'list', 'runtimes'])
    watchos_version_str = re.findall(r'watchOS \d+\.*\d*', sim_output.decode('utf-8'))
    return [float(v.strip('watchOS')) for v in watchos_version_str]

# Returns the "prefix" command that should be prepended to the command line to
# run an executable compiled for an iOS, tvOS, or watchOS simulator.
def get_simulator_command(run_os, run_cpu):
    mac_ver_tuple = tuple(int(v) for v in
        platform.mac_ver()[0].replace('.', ' ').split())
    if run_os == 'ios':
        if run_cpu == "i386":
            if mac_ver_tuple >= (11,):
                print("ERROR: The 32-bit iOS simulator is unavailable on macOS 11.0+")
                sys.exit(1)
            elif min(darwin_get_ios_sim_vers()) > 10.3:
                print("ERROR: Your system does not have a 32-bit iOS simulator installed.")
                print("INFO: 1. Install iOS 10.3 or older simulator (Xcode -> Preferences -> Components -> Simulators).")
                print("INFO: 2. Create a 32-bit iPhone 5 device. Run:")
                print("INFO:    $ xcrun simctl create 'iPhone 5' com.apple.CoreSimulator.SimDeviceType.iPhone-5 com.apple.CoreSimulator.SimRuntime.iOS-10-3")
                sys.exit(1)
            else:
                return "simctl spawn --standalone 'iPhone 5'"
        else:
            return "simctl spawn --standalone 'iPhone 15'"
    elif run_os == 'tvos':
        return "simctl spawn --standalone 'Apple TV'"
    elif run_os == 'watchos':
        if run_cpu == "i386":
           if min(darwin_get_watchos_sim_vers()) > 6.2:
              print("ERROR: Your system does not have a 32-bit watchOS simulator installed.")
              print("INFO: 1. Install watchOS 6.2.1 simulator (Xcode -> Preferences -> Components -> Simulators).")
              print("INFO: 2. Create a 32-bit watchOS device. Run:")
              print("INFO:    $ xcrun simctl create 'Apple Watch Series 2 - 42mm' com.apple.CoreSimulator.SimDeviceType.Apple-Watch-Series-2-42mm com.apple.CoreSimulator.SimRuntime.watchOS-6-2")
              sys.exit(1)
           else:
              return "simctl spawn --standalone 'Apple Watch Series 2 - 42mm'"
        else:
           return "simctl spawn --standalone 'Apple Watch Series 9 (45mm)'"
    elif run_os == 'xros':
        lit_config.note("xrOS Simulator Is Not Supported Yet - Tests Will Fail")
        return "simctl spawn --standalone 'Apple Vision Pro'"
    else:
        lit_config.fatal("Unknown simulator OS %r" % run_os)

def get_lldb_python_path(lldb_build_root):
    lldb_path = os.path.join(lldb_build_root, 'bin', 'lldb')
    if not os.access(lldb_path, os.F_OK):
        return None
    return subprocess.check_output([lldb_path, "-P"]).rstrip().decode('utf-8')

def get_lldb_python_interpreter(lldb_build_root):
    python_path = os.path.join(lldb_build_root, 'bin', 'lldb-python')
    if not os.access(python_path, os.F_OK):
        return None
    return python_path

if not platform.system() == 'Windows':
    shell_quote = shlex.quote
else:
    # In Windows neither pipe.quote nor shlex.quote works.
    def shell_quote(s):
        # Quote the argument if it is empty, or contains a quote or a space.
        if len(s) == 0 or re.search(r'["\s]', s):
            s = '"' + s.replace('"', r'\"') + '"'
        return s

def escape_for_substitute_captures(s):
    # SubstituteCaptures strings are used as replacement patterns for regular
    # expressions. In them escapes like \1, \2 are used as references, but that
    # means that simple \ will try to be interpreted, so we need to escape them
    # with \\.
    return s.replace("\\", "\\\\")

###

# Check that the object root is known.
if config.test_exec_root is None:
    # Otherwise, we haven't loaded the site specific configuration (the user is
    # probably trying to run on a test file directly, and either the site
    # configuration hasn't been created by the build system, or we are in an
    # out-of-tree build situation).

    # Check for 'swift_site_config' user parameter, and use that if available.
    site_cfg = lit_config.params.get('swift_site_config', None)
    if site_cfg and os.path.exists(site_cfg):
        lit_config.load_config(config, site_cfg)
        raise SystemExit

    lit_config.fatal("lit must be pointed at a build folder")

###

# name: The name of this test suite.
config.name = 'Swift(%s)' % config.variant_suffix[1:]

# Respect the TOOLCHAINS environment variable when deciding the xcrun
# toolchain for Darwin platforms.
if platform.system() == 'Darwin':
    config.environment['TOOLCHAINS'] = \
        os.environ.get('TOOLCHAINS', config.darwin_xcrun_toolchain)

# NOTE: this mirrors the kIsWindows from lit.lit.TestRunner in LLVM
kIsWindows = platform.system() == 'Windows'

# The global environment in Android sets ANDROID_DATA, so if that variable is
# set, we are probably running in Android.
kIsAndroid = 'ANDROID_DATA' in os.environ

# testFormat: The test format to use to interpret tests.

# Choose between lit's internal shell pipeline runner and a real shell.  If
# LIT_USE_INTERNAL_SHELL is in the environment, we use that as an override.
use_lit_shell = os.environ.get('LIT_USE_INTERNAL_SHELL', kIsWindows)
if not use_lit_shell:
    config.available_features.add('shell')

config.test_format = swift_test.SwiftTest(coverage_mode=config.coverage_mode,
                                          execute_external=not use_lit_shell)

# suffixes: A list of file extensions to treat as test files.
config.suffixes = ['.swift', '.ll', '.sil', '.gyb', '.m', '.c',
                   '.swiftinterface', '.test-sh', '.test', '.cpp']

# excludes: A list of directories to exclude from the testsuite. The 'Inputs'
# subdirectories contain auxiliary inputs for various tests in their parent
# directories.
config.excludes = ['Inputs']

if lit_config.params.get('disable_unittests', None) is not None:
    config.excludes += ['Unit']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

# swift_obj_root: The path to the swift build root.
swift_obj_root = getattr(config, 'swift_obj_root', None)

# cmake. The path to the cmake executable we used to configure swift.
assert(config.cmake)
config.substitutions.append( ('%cmake',  config.cmake) )
lit_config.note('Using cmake: ' + config.cmake)

# Set llvm_{src,obj}_root for use by others.
config.llvm_src_root = getattr(config, 'llvm_src_root', None)
config.llvm_obj_root = getattr(config, 'llvm_obj_root', None)

lto_flags = ""
use_just_built_liblto = ""
llvm_libs_dir = getattr(config, 'llvm_libs_dir', None)
llvm_plugin_ext = getattr(config, 'llvm_plugin_ext', None)

if platform.system() == 'OpenBSD':
    if not llvm_libs_dir:
        lit_config.fatal('No LLVM libs dir set.')
    config.environment['LD_LIBRARY_PATH'] = llvm_libs_dir

elif platform.system() == 'Darwin':
    if not llvm_libs_dir:
        lit_config.fatal('No LLVM libs dir set.')
    lto_flags = "-Xlinker -lto_library -Xlinker %s/libLTO.dylib" % llvm_libs_dir
    use_just_built_liblto = "LIBLTO_PATH=%s/libLTO.dylib" % llvm_libs_dir

config.substitutions.append( ('%lto_flags', lto_flags) )
config.substitutions.append( ('%use_just_built_liblto', use_just_built_liblto) )
config.substitutions.append( ('%llvm_libs_dir', llvm_libs_dir) )

if llvm_plugin_ext is not None:
    config.substitutions.append( ('%llvm_plugin_ext', llvm_plugin_ext) )

# Allow tests to restore the original environment if they need to.
config.substitutions.append( ('%original_path_env', config.environment['PATH']) )

def append_to_env_path(directory):
    config.environment['PATH'] = \
        os.path.pathsep.join((directory, config.environment['PATH']))

if sys.version_info[0] >= 3:
    config.environment['PYTHONIOENCODING'] = 'UTF8'

# Tweak the PATH to include the tools dir and the scripts dir.
if swift_obj_root is not None:
    llvm_tools_dir = getattr(config, 'llvm_tools_dir', None)
    if not llvm_tools_dir:
        lit_config.fatal('No LLVM tools dir set!')
    append_to_env_path(llvm_tools_dir)

    build_mode = lit_config.params.get('build_mode', '')
    append_to_env_path(make_path(swift_obj_root, build_mode, 'bin'))

native_llvm_tools_path = lit_config.params.get('native_llvm_tools_path')
if native_llvm_tools_path is not None:
    append_to_env_path(native_llvm_tools_path)

native_clang_tools_path = lit_config.params.get('native_clang_tools_path')
if native_clang_tools_path is not None:
    append_to_env_path(native_clang_tools_path)

native_swift_tools_path = lit_config.params.get('native_swift_tools_path')
if native_swift_tools_path is not None:
    append_to_env_path(native_swift_tools_path)

array_cow_checks = lit_config.params.get('array_cow_checks')
if array_cow_checks is not None:
    config.available_features.add('array_cow_checks')

###

# Discover the Swift binaries to use.
def inferSwiftBinary(binaryName):
    # Determine which executable to use.
    envVarName = binaryName.upper().replace("-", "_")
    execPath = os.getenv(envVarName)

    # If the user set the variable in the environment, definitely use that and
    # don't try to validate.
    if execPath:
        return execPath

    # Otherwise look in the path.
    PATH = config.environment['PATH']
    execPath = lit.util.which(binaryName, PATH)

    if execPath:
        if not lit_config.quiet:
            lit_config.note('using %s: %s' % (binaryName, execPath))
    else:
        msg = "couldn't find '%s' program, try setting %s in your environment"
        lit_config.warning(msg % (binaryName, envVarName))

        # Just substitute the plain executable name, so the run line remains
        # reasonable.
        execPath = binaryName

    return execPath

if 'gmalloc' in lit_config.params:
    config.environment['DYLD_INSERT_LIBRARIES'] = '/usr/lib/libgmalloc.dylib'
    config.environment['MALLOC_LOG_FILE'] = '/dev/null'
    config.available_features.add('gmalloc')

config.python_unquoted = sys.executable
config.python = shell_quote(config.python_unquoted)
config.swift_frontend = inferSwiftBinary('swift-frontend')
config.swift = inferSwiftBinary('swift')
config.swiftc = inferSwiftBinary('swiftc')
config.sil_opt = inferSwiftBinary('sil-opt')
config.sil_func_extractor = inferSwiftBinary('sil-func-extractor')
config.sil_llvm_gen = inferSwiftBinary('sil-llvm-gen')
config.sil_nm = inferSwiftBinary('sil-nm')
config.sil_passpipeline_dumper = inferSwiftBinary('sil-passpipeline-dumper')
config.lldb_moduleimport_test = inferSwiftBinary('lldb-moduleimport-test')
config.swift_ide_test = inferSwiftBinary('swift-ide-test')
config.swift_dependency_tool = inferSwiftBinary('swift-dependency-tool')
config.swift_reflection_dump = inferSwiftBinary('swift-reflection-dump')
config.swift_remoteast_test = inferSwiftBinary('swift-remoteast-test')
config.swift_symbolgraph_extract = inferSwiftBinary('swift-symbolgraph-extract')
config.swift_synthesize_interface = inferSwiftBinary('swift-synthesize-interface')
config.clang = inferSwiftBinary('clang')
config.clangxx = inferSwiftBinary('clang++')
config.llvm_link = inferSwiftBinary('llvm-link')
config.swift_llvm_opt = inferSwiftBinary('swift-llvm-opt')
config.llvm_profdata = inferSwiftBinary('llvm-profdata')
config.llvm_cov = inferSwiftBinary('llvm-cov')
config.llvm_strings = inferSwiftBinary('llvm-strings')
config.filecheck = inferSwiftBinary('FileCheck')
config.llvm_dwarfdump = inferSwiftBinary('llvm-dwarfdump')
config.llvm_readelf = inferSwiftBinary('llvm-readelf')
config.llvm_dis = inferSwiftBinary('llvm-dis')
config.llvm_nm = inferSwiftBinary('llvm-nm')
config.llvm_readtapi = inferSwiftBinary('llvm-readtapi')
config.llvm_size = inferSwiftBinary('llvm-size')
config.sourcekitd_test = inferSwiftBinary('sourcekitd-test')
config.complete_test = inferSwiftBinary('complete-test')
config.swift_api_digester = inferSwiftBinary('swift-api-digester')
config.swift_cache_tool = inferSwiftBinary('swift-cache-tool')
config.swift_refactor = inferSwiftBinary('swift-refactor')
config.swift_demangle_yamldump = inferSwiftBinary('swift-demangle-yamldump')
config.swift_demangle = inferSwiftBinary('swift-demangle')
config.benchmark_o = inferSwiftBinary('Benchmark_O')
config.benchmark_driver = inferSwiftBinary('Benchmark_Driver')
config.lld = inferSwiftBinary('lld')
config.wasm_ld = inferSwiftBinary('wasm-ld')
config.swift_plugin_server = inferSwiftBinary('swift-plugin-server')
config.swift_parse_test = inferSwiftBinary('swift-parse-test')
config.swift_scan_test = inferSwiftBinary('swift-scan-test')

config.swift_utils = make_path(config.swift_src_root, 'utils')
config.line_directive = make_path(config.swift_utils, 'line-directive')
config.gyb = make_path(config.swift_utils, 'gyb.py')
config.rth = make_path(config.swift_utils, 'rth') # Resilience test helper
config.scale_test = make_path(config.swift_utils, 'scale-test')
config.PathSanitizingFileCheck = make_path(config.swift_utils, 'PathSanitizingFileCheck')
config.swift_bin_dir = make_path(config.swift, '..', '..', 'bin')
config.swift_lib_dir = make_path(config.swift, '..', '..', 'lib')
config.swift_libexec_dir = make_path(config.swift, '..', '..', 'libexec')
config.swift_share_dir = make_path(config.swift, '..', '..', 'share')
config.round_trip_syntax_test = make_path(config.swift_utils, 'round-trip-syntax-test')
config.refactor_check_compiles = make_path(config.swift_utils, 'refactor-check-compiles.py')
config.abi_symbol_checker = make_path(config.swift_utils, 'swift-abi-symbol-checker.py')

config.link = lit.util.which('link', config.environment.get('PATH', '')) or      \
              lit.util.which('lld-link', config.environment.get('PATH', ''))

config.color_output = lit_config.params.get('color_output', None) is not None

# Tell the (new) driver to invoke the Clang we've inferred. The
# legacy driver uses ld by default.
config.environment['SWIFT_DRIVER_CLANG_EXEC'] = config.clang
config.environment['SWIFT_DRIVER_CLANGXX_EXEC'] = config.clangxx

# Find the resource directory.  Assume it's near the swift compiler if not set.
test_resource_dir = lit_config.params.get('test_resource_dir')
config.resource_dir_opt = ""
if test_resource_dir:
   config.resource_dir_opt = ("-resource-dir %s" % test_resource_dir)
else:
    test_resource_dir = make_path(config.swift_lib_dir, 'swift')

lit_config.note('Using resource dir: ' + test_resource_dir)

test_clang_resource_dir = lit.util.executeCommand([config.clang, '-print-resource-dir'])[0].rstrip()
lit_config.note('Using Clang resource dir: ' + test_clang_resource_dir)

# Parse the variant triple.
# FIXME: We ought to parse 'run_environment' separately from 'run_os'.
(run_cpu, run_vendor, run_os, run_vers) = re.match('([^-]+)-([^-]+)-([^0-9]+)(.*)', config.variant_triple).groups()
if run_os == 'ios' and run_vers.endswith('-macabi'):
    run_vers = run_vers[0:-len('-macabi')]
    run_os = 'maccatalyst'
if run_vers.endswith('-simulator'):
    run_vers = run_vers[0:-len('-simulator')]
    run_environment='-simulator'
else:
    run_environment=''

# Allow using using same condition in WASI test suites.
kIsWASI = run_os.startswith('wasi')
if kIsWASI:
  run_os = f"{run_os}{run_vers}"

# Parse the host triple
(host_cpu, host_vendor, host_os, host_vers) = re.match('([^-]+)-([^-]+)-([^0-9-]+)(.*)', config.host_triple).groups()

# Manually set the host OS on Android, because the host OS from the triple says
# `linux`.
if kIsAndroid:
    host_os = 'android'

if f"{host_cpu}-{host_vendor}-{host_os}" == f"{run_cpu}-{run_vendor}-{run_os}":
    # Ignore the version on purpose, to account for scenario
    # in which the compiler has a different deployment target
    # than the standard library
    config.available_features.add('target-same-as-host')

target_arch = run_cpu
if run_os == 'openbsd' and run_cpu == 'amd64':
   target_arch = run_cpu
   run_cpu = 'x86_64'

run_ptrsize = '64' if ('64' in run_cpu or run_cpu == "s390x") else '32'
if run_cpu == 'arm64_32':
  run_ptrsize = '32'
if run_cpu == 'avr':
  run_ptrsize = '16'

run_ptrauth = 'ptrauth' if run_cpu == 'arm64e' else 'noptrauth'
run_endian = 'little' if run_cpu != 's390x' else 'big'
run_objc_interop = 'nonobjc'      # overwritten later

sdk_overlay_link_path = ""
sdk_overlay_linker_opt = ""
sdk_overlay_dir_opt = ""
test_sdk_overlay_dir = lit_config.params.get('test_sdk_overlay_dir', None)
if test_sdk_overlay_dir is not None:
    config.available_features.add('sdk_overlay')

    sdk_overlay_dir_opt = ("-I %s" % make_path(test_sdk_overlay_dir, run_cpu))
    sdk_overlay_link_path_dir = make_path(test_sdk_overlay_dir, run_cpu)
    sdk_overlay_link_path = ("-L %s" % sdk_overlay_link_path_dir)
    sdk_overlay_linker_opt = (
        "-L %s -Xlinker -rpath -Xlinker %s" %
        (sdk_overlay_link_path_dir, sdk_overlay_link_path_dir))
    lit_config.note('Using SDK overlay dir: ' + test_sdk_overlay_dir)
    config.resource_dir_opt += (" %s" % sdk_overlay_dir_opt)

config.swift_system_overlay_opt = ""
config.clang_system_overlay_opt = ""
config.windows_vfs_overlay_opt = ""
if kIsWindows and run_os in ['windows-msvc']:
    # ucrt.modulemap currently requires -fbuiltin-headers-in-system-modules. -strict-implicit-module-context
    # is necessary for -Xcc arguments to be passed through ModuleInterfaceLoader.
    config.swift_system_overlay_opt = "-vfsoverlay {} -strict-implicit-module-context -Xcc -Xclang -Xcc -fbuiltin-headers-in-system-modules".format(
        os.path.join(config.swift_obj_root, "stdlib", "windows-vfs-overlay.yaml")
    )
    # this variant is for extract-symbolgraph which doesn't accept all the same arugments as swiftc
    # so the extra ceremony lets us pass in the relevant pieces needed for Windows SDK access.
    config.windows_vfs_overlay_opt = "-Xcc -vfsoverlay -Xcc {} -Xcc -strict-implicit-module-context -Xcc -Xclang -Xcc -fbuiltin-headers-in-system-modules".format(
        os.path.join(config.swift_obj_root, "stdlib", "windows-vfs-overlay.yaml")
    )
    config.clang_system_overlay_opt = "-Xcc -ivfsoverlay -Xcc {} -Xcc -Xclang -Xcc -fbuiltin-headers-in-system-modules".format(
        os.path.join(config.swift_obj_root, "stdlib", "windows-vfs-overlay.yaml")
    )
config.substitutions.append( ('%windows_vfs_overlay_opt', config.windows_vfs_overlay_opt) )
stdlib_resource_dir_opt = config.resource_dir_opt
sourcekitd_framework_dir = config.swift_lib_dir
config.substitutions.append( ('%test-resource-dir', test_resource_dir) )

# Default to Swift 4 for now.
# Note that this accepts both `--param swift-version` (like the compiler flag)
# and `--param swift_version` (like a lit configuration parameter).
swift_version = lit_config.params.get('swift-version',
    lit_config.params.get('swift_version', '4'))
lit_config.note('Compiling with -swift-version ' + swift_version)
config.swift_test_options = '-swift-version ' + swift_version

# Loads availability macros for known stdlib releases.
def load_availability_macros():
    path = os.path.join(os.path.dirname(__file__), "../utils/availability-macros.def")
    lines = open(path, 'r').read().splitlines()
    pattern = re.compile(r"\s*(#.*)?")
    return filter(lambda l: pattern.fullmatch(l) is None, lines)

# Returns a tuple with the Swift ABI version (e.g. '5.0') and the corresponding
# target triple (e.g. 'arm64-apple-ios12.2')
def availability_macro_to_swift_abi_target_triple(macro):
    # Use a regex and split to pull out the components of an availability macro
    # that is formatted like this:
    #    SwiftStdlib 5.0:macOS 10.14.4, iOS 12.2, watchOS 5.2, tvOS 12.2
    matches = re.search(r'^[\s]*Swift(?:Stdlib|CompatibilitySpan)[\s]+([0-9\.]+)[\s]*:[\s]*(.+)', macro)
    stdlib_vers = matches.group(1)
    vers_by_platform = {}
    for platform_vers in matches.group(2).split(', '):
        components = platform_vers.split(' ')
        vers_by_platform[components[0]] = components[1]

    platform = {
        'macosx': 'macOS',
        'ios': 'iOS',
        'maccatalyst': 'iOS',
        'tvos': 'tvOS',
        'watchos': 'watchOS'
    }.get(run_os)

    if platform is None:
        return stdlib_vers, config.variant_triple

    os_vers = vers_by_platform.get(platform)
    if os_vers is None:
        return stdlib_vers, config.variant_triple

    if run_os == 'maccatalyst':
        return stdlib_vers, '%s-%s-ios%s-macabi' % (run_cpu, run_vendor, os_vers)

    return stdlib_vers, '%s-%s-%s%s%s' % (run_cpu, run_vendor, run_os,
                                          os_vers, run_environment)

# Compare two version numbers
def version_gt(a, b):
  a_int = list(map(int, a.split(".")))
  b_int = list(map(int, b.split(".")))
  vlen = max(len(a_int), len(b_int))
  if len(a_int) < vlen:
    a_int += [0] * (vlen - len(a_int))
  if len(b_int) < vlen:
    b_int += [0] * (vlen - len(b_int))
  return a_int > b_int

# Returns a StdlibDeploymentTarget macro given a SwiftStdlib macro
def availability_macro_to_current(macro):
    matches = re.search(r'^\s*SwiftStdlib\s+([0-9\.]*)\s*:\s*(.*)', macro)
    if not matches:
        return None

    stdlib_vers = matches.group(1)
    orig_spec = matches.group(2)

    vers_by_platform = {}
    for platform_vers in orig_spec.split(', '):
        components = platform_vers.split(' ')
        vers_by_platform[components[0]] = components[1]

    platform_name = {
        'macosx': 'macOS',
        'ios': 'iOS',
        'maccatalyst': 'iOS',
        'tvos': 'tvOS',
        'watchos': 'watchOS'
    }.get(run_os)

    orig_vers = vers_by_platform.get(platform_name)
    if orig_vers is not None and orig_vers != "9999":
      ver = platform.mac_ver()[0]

      if version_gt(orig_vers, ver):
        return f"StdlibDeploymentTarget {stdlib_vers}:{platform_name} {ver}"

    return f"StdlibDeploymentTarget {stdlib_vers}:{orig_spec}"

# Add availability macros to the default frontend/driver flags and create target
# triple substitutions for each stdlib version.
for macro in load_availability_macros():
    config.swift_frontend_test_options += " -define-availability '{0}'".format(macro)
    config.swift_driver_test_options += " -Xfrontend -define-availability -Xfrontend '{0}'".format(macro)

    current_macro = availability_macro_to_current(macro)
    if current_macro:
      config.swift_frontend_test_options += " -define-availability '{0}'".format(current_macro)
      config.swift_driver_test_options += " -Xfrontend -define-availability -Xfrontend '{0}'".format(current_macro)

    (stdlib_vers, triple) = availability_macro_to_swift_abi_target_triple(macro)
    config.substitutions.append(('%target-swift-{}-abi-triple'.format(stdlib_vers), triple))


differentiable_programming = lit_config.params.get('differentiable_programming', None)
if differentiable_programming is not None:
    config.available_features.add('differentiable_programming')

string_processing = lit_config.params.get('string_processing', None)
if string_processing is not None:
    config.available_features.add('string_processing')

backtracing = lit_config.params.get('backtracing', None)
if backtracing is not None:
    config.available_features.add('backtracing')

backtrace_on_crash = lit_config.params.get('backtrace_on_crash', None)
if backtrace_on_crash is not None:
    config.environment['SWIFT_BACKTRACE'] = 'enable=on,warnings=suppressed'

# Make an explicit setting in the environment override whatever we did above
swift_backtrace = os.environ.get('SWIFT_BACKTRACE')
if swift_backtrace:
    config.environment['SWIFT_BACKTRACE'] = swift_backtrace

threading = lit_config.params.get('threading', 'none')
config.available_features.add('threading_{}'.format(threading))
if threading != "none":
    config.available_features.add('thread_safe_runtime')

config.substitutions.append(('%target-threading-opt',
                             '-DSWIFT_THREADING_{0}=1'.format(threading.upper())))

synchronization = lit_config.params.get('synchronization', None)
if synchronization is not None:
    config.available_features.add('synchronization')

remote_mirror = lit_config.params.get('remote_mirror', None)
if remote_mirror is not None:
    config.available_features.add('remote_mirror')

test_options = os.environ.get('SWIFT_TEST_OPTIONS')
if test_options:
    config.swift_test_options += ' '
    config.swift_test_options += test_options

config.swift_frontend_test_options += os.environ.get('SWIFT_FRONTEND_TEST_OPTIONS', '')
config.swift_driver_test_options += os.environ.get('SWIFT_DRIVER_TEST_OPTIONS', '')
config.swift_ide_test_test_options += os.environ.get('SWIFT_IDE_TEST_TEST_OPTIONS', '')
config.sil_test_options = os.environ.get('SIL_TEST_OPTIONS', '')

# Check if we overrode the linker; if we do, set a feature to say that, which
# lets us disable tests that rely on the driver choosing the linker.
if re.search(r'(?:^|[ \t])-use-ld=[^ \t]*', config.swift_driver_test_options):
    config.available_features.add('linker_overridden')

config.clang_module_cache_path = make_path(config.swift_test_results_dir, "clang-module-cache")
shutil.rmtree(config.clang_module_cache_path, ignore_errors=True)
mcp_opt = "-module-cache-path %s" % shell_quote(config.clang_module_cache_path)
platform_remap_mock_sdk_config = "%s" % make_path(config.test_source_root, 'Inputs', 'MockPlatformRemapSDKConfig/')
clang_mcp_opt = "-fmodules-cache-path=%r" % config.clang_module_cache_path
lit_config.note("Using Clang module cache: " + config.clang_module_cache_path)
lit_config.note("Using test results dir: " + config.swift_test_results_dir)

completion_cache_path = make_path(config.swift_test_results_dir, "completion-cache")
shutil.rmtree(completion_cache_path, ignore_errors=True)
ccp_opt = "-completion-cache-path %r" % completion_cache_path
lit_config.note("Using code completion cache: " + completion_cache_path)

if kIsWindows:
    config.swift_plugin_dir = config.swift_bin_dir
    # FIXME: this is a workaround for the collsion between the build toolchain
    # and the current build, this should be `make_path(config.swift_lib_dir, 'swift')`
    config.swift_build_lib_dir = make_path(config.swift_lib_dir, 'swift', 'host')
else:
    config.swift_plugin_dir = make_path(config.swift_lib_dir, 'swift', 'host', 'plugins')
    config.swift_build_lib_dir = make_path(config.swift_lib_dir, 'swift', 'host')

if platform.system() == 'Darwin':
    config.swift_driver = (
        "env SDKROOT=%s %r %s %s %s"
        % (shell_quote(config.host_sdkroot), config.swift, mcp_opt, config.swift_test_options, config.swift_driver_test_options))
    config.swiftc_driver = (
        "env SDKROOT=%s %r -toolchain-stdlib-rpath -Xlinker -rpath -Xlinker /usr/lib/swift %s %s %s"
        % (shell_quote(config.host_sdkroot), config.swiftc, mcp_opt, config.swift_test_options, config.swift_driver_test_options))
    config.host_build_swift = (
        "%s -sdk %s -target %s -no-toolchain-stdlib-rpath -I %s -L %s" % (
            config.swiftc_driver,
            config.host_sdkroot,
            config.host_triple,
            config.swift_build_lib_dir,
            config.swift_build_lib_dir
        )
    )
else:
    config.swift_driver = (
        "%r %s %s %s"
        % (config.swift, mcp_opt, config.swift_test_options, config.swift_driver_test_options))
    if kIsWindows:
        config.swift_driver += " -libc " + config.swift_stdlib_msvc_runtime
    config.swiftc_driver = (
        "%r %s %s %s %s" % (
            config.swiftc,
            '' if kIsWindows else '-toolchain-stdlib-rpath',
            mcp_opt,
            config.swift_test_options,
            config.swift_driver_test_options,
        )
    )
    toolchain_lib_dir = make_path(config.swift_lib_dir, 'swift', host_os)
    config.host_build_swift = (
        "%s -target %s -g %s -I %s -L %s %s" % (
            config.swiftc_driver,
            config.host_triple,
            '' if kIsWindows else '-no-toolchain-stdlib-rpath',
            config.swift_build_lib_dir,
            config.swift_build_lib_dir,
            '' if kIsWindows else '-Xlinker -rpath -Xlinker {}'.format(toolchain_lib_dir)
        )
    )

config.substitutions.append( ('%llvm_obj_root', config.llvm_obj_root) )
config.substitutions.append( ('%swift-bin-dir', config.swift_bin_dir) )
config.substitutions.append( ('%swift-lib-dir', config.swift_lib_dir) )
config.substitutions.append( ('%swift-libexec-dir', config.swift_lib_dir) )
config.substitutions.append( ('%swift-share-dir', config.swift_share_dir) )
config.substitutions.append( ('%swift-plugin-dir', config.swift_plugin_dir) )
config.substitutions.append( ('%llvm_src_root', config.llvm_src_root) )
config.substitutions.append( ('%swift_obj_root', config.swift_obj_root) )
config.substitutions.append( ('%swift_src_root', config.swift_src_root) )
config.substitutions.append( ('%{python}', config.python) )
config.substitutions.append( ('%{python.unquoted}', config.python_unquoted) )
config.substitutions.append( ('%mcp_opt', mcp_opt) )
config.substitutions.append( ('%swift_driver_plain', "%r" % config.swift) )
config.substitutions.append( ('%swiftc_driver_plain', "%r" % config.swiftc) )
config.substitutions.append( ('%swift_frontend_plain', "%r" % config.swift_frontend))
config.substitutions.append( ('%swift_driver', config.swift_driver) )
config.substitutions.append( ('%swiftc_driver', config.swiftc_driver) )
config.substitutions.append( ('%host-build-swift', config.host_build_swift) )
config.substitutions.append( ('%host_sdk', config.host_sdkroot) )
config.substitutions.append( ('%host_triple', config.host_triple) )

config.substitutions.append( ('%sil-opt', "%r %s %s" % (config.sil_opt, mcp_opt, config.sil_test_options)) )
config.substitutions.append( ('%sil-func-extractor', "%r %s" % (config.sil_func_extractor, mcp_opt)) )
config.substitutions.append( ('%sil-llvm-gen', "%r %s" % (config.sil_llvm_gen, mcp_opt)) )
config.substitutions.append( ('%sil-nm', "%r %s" % (config.sil_nm, mcp_opt)) )
config.substitutions.append( ('%sil-passpipeline-dumper', "%r" % (config.sil_passpipeline_dumper)) )
config.substitutions.append( ('%lldb-moduleimport-test', "%r %s" % (config.lldb_moduleimport_test, mcp_opt)) )
config.substitutions.append( ('%lldb-moduleimport-test-with-sdk',
                             '%s -sdk %r' % (config.lldb_moduleimport_test, config.variant_sdk)) )
config.substitutions.append( ('%swift-dump-pcm', "%r -dump-pcm" % config.swiftc) )
config.substitutions.append( ('%swift-ide-test_plain', config.swift_ide_test) )
config.substitutions.append( ('%swift-ide-test', "%r %s %s -swift-version %s %s" % (config.swift_ide_test, mcp_opt, ccp_opt, swift_version, config.resource_dir_opt)) )
config.substitutions.append( ('%swift-dependency-tool', config.swift_dependency_tool) )
config.substitutions.append( ('%llvm-link', config.llvm_link) )
config.substitutions.append( ('%swift-llvm-opt', config.swift_llvm_opt) )
config.substitutions.append( ('%llvm-dwarfdump', config.llvm_dwarfdump) )
config.substitutions.append( ('%llvm-readelf', config.llvm_readelf) )
config.substitutions.append( ('%llvm-dis', config.llvm_dis) )
config.substitutions.append( ('%llvm-nm', config.llvm_nm) )
config.substitutions.append( ('%llvm-readtapi', config.llvm_readtapi) )
config.substitutions.append( ('%llvm-size', config.llvm_size) )
config.substitutions.append( ('%swift-demangle-yamldump', config.swift_demangle_yamldump) )
config.substitutions.append( ('%swift-demangle', config.swift_demangle) )
config.substitutions.append( ('%Benchmark_O', config.benchmark_o) )
config.substitutions.append( ('%Benchmark_Driver', config.benchmark_driver) )
config.substitutions.append( ('%llvm-strings', config.llvm_strings) )
config.substitutions.append( ('%target-ptrauth', run_ptrauth ) )
config.substitutions.append( ('%swift-path', config.swift) )
config.substitutions.append( ('%swift-plugin-server', config.swift_plugin_server) )
config.substitutions.append( ('%swift-parse-test', config.swift_parse_test) )
config.substitutions.append( ('%swift-scan-test', config.swift_scan_test) )
config.substitutions.append( ('%validate-json', f"{config.python} -m json.tool") )

config.clang_include_dir = make_path(config.llvm_obj_root, 'include')
config.substitutions.append( ('%clang-include-dir', config.clang_include_dir) )

config.swift_include_dir = make_path(config.swift_obj_root, 'include')
config.substitutions.append( ('%swift-include-dir', config.swift_include_dir) )

# This must come after all substitutions containing "%swift".
config.substitutions.append(
    ('%swift',
     "%r %s -disable-objc-attr-requires-foundation-module %s %s"
       % (config.swift_frontend, mcp_opt, config.swift_test_options, config.swift_frontend_test_options)) )

# Use this to build the basic set of Objective-C overlays.
config.substitutions.append(('%build-clang-importer-objc-overlays',
                             '%target-swift-frontend(mock-sdk: %clang-importer-sdk-nosource -I %t) -enable-objc-interop -emit-module -o %t %clang-importer-sdk-path/swift-modules/ObjectiveC.swift -disable-objc-attr-requires-foundation-module && '
                             '%target-swift-frontend(mock-sdk: %clang-importer-sdk-nosource -I %t) -enable-objc-interop -emit-module -o %t %clang-importer-sdk-path/swift-modules/CoreGraphics.swift && '
                             '%target-swift-frontend(mock-sdk: %clang-importer-sdk-nosource -I %t) -enable-objc-interop -emit-module -o %t %clang-importer-sdk-path/swift-modules/CoreFoundation.swift && '
                             '%target-swift-frontend(mock-sdk: %clang-importer-sdk-nosource -I %t) -enable-objc-interop -emit-module -o %t %clang-importer-sdk-path/swift-modules/Foundation.swift'))


# FIXME: BEGIN -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-without-job-path',
                             '%r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
config.substitutions.append(('%clang-importer-sdk-concurrency-without-job-nosource',
                             '-sdk %r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
# FIXME: END -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-without-job',
                             '-enable-source-import -sdk %r -I %r ' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'),
                                                                       make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk', 'swift-modules-concurrency-without-job'))))

# FIXME: BEGIN -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-typealias-struct-job-path',
                             '%r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
config.substitutions.append(('%clang-importer-sdk-concurrency-typealias-struct-job-nosource',
                             '-sdk %r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
# FIXME: END -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-typealias-struct-job',
                             '-enable-source-import -sdk %r -I %r ' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'),
                                                                       make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk', 'swift-modules-concurrency-typealias-struct-job'))))

# FIXME: BEGIN -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-consuming-job-param-path',
                             '%r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
config.substitutions.append(('%clang-importer-sdk-concurrency-consuming-job-param-nosource',
                             '-sdk %r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
# FIXME: END -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-consuming-job-param',
                             '-enable-source-import -sdk %r -I %r ' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'),
                                                                       make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk', 'swift-modules-concurrency-consuming-job-param'))))

# FIXME: BEGIN -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-owned-job-param-path',
                             '%r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
config.substitutions.append(('%clang-importer-sdk-concurrency-owned-job-param-nosource',
                             '-sdk %r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
# FIXME: END -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-concurrency-owned-job-param',
                             '-enable-source-import -sdk %r -I %r ' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'),
                                                                       make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk', 'swift-modules-concurrency-owned-job-param'))))

# FIXME: BEGIN -enable-source-import hackaround
config.substitutions.append(('%clang-importer-sdk-path',
                             '%r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))

config.substitutions.append(('%clang-importer-sdk-nosource',
                             '-sdk %r' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'))))
# FIXME: END -enable-source-import hackaround

config.substitutions.append(('%clang-importer-sdk',
                             '-enable-source-import -sdk %r -I %r ' % (make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk'),
                                                                       make_path(config.test_source_root, 'Inputs', 'clang-importer-sdk', 'swift-modules'))))

config.substitutions.append( ('%clang_apinotes',
                              "%r -cc1apinotes" %
                                (config.clang)) )

config.substitutions.append( ('%clangxx',
                              "%r %s" %
                                (config.clangxx, clang_mcp_opt)) )

# Alternative to %clang that doesn't require -fmodules.
config.substitutions.append( ('%clang-no-modules',
                              "%r" %
                                (config.clang)) )

# This must come after all substitutions containing "%clang".
# Note: %clang is the locally-built clang.
# To get Xcode's clang, use %target-clang.
config.substitutions.append( ('%clang',
                              "%r %s" %
                                (config.clang, clang_mcp_opt)) )

config.substitutions.append(('%existing-swift-features', shlex.quote(json.dumps(list(config.existing_swift_features)))))

###

def disallow(execName):
  warning = '''
    echo '*** Do not use \'{0}\' in tests; use \'%''{0}\'. ***' &&
    exit 1 && echo
  '''
  config.substitutions.append((' {0} '.format(execName),
                               warning.format(execName)))

disallow('swift')
disallow('swiftc')
disallow('swift_driver')
disallow('swiftc_driver')
disallow('sil-opt')
disallow('sil-func-extractor')
disallow('sil-llvm-gen')
disallow('sil-nm')
disallow('sil-passpipeline-dumper')
disallow('lldb-moduleimport-test')
disallow('swift-ide-test')
disallow('clang')
disallow('FileCheck')
disallow('llvm-dwarfdump')
disallow('llvm-dis')

config.substitutions.insert(0,
    ('%p',
     '$(echo "*** Use %""S instead of %""p in the Swift test suite ***" >&2)'))

###

# Set available features we allow tests to conditionalize on.
if platform.system() != 'Windows':
    config.available_features.add('crash-recovery')

# Clang cannot enable objc language mode on WebAssembly target
if run_cpu != 'wasm32':
    config.available_features.add('objc_codegen')

# Add each available build target CPU as a feature.
for target in config.llvm_code_generators:
  config.available_features.add("CODEGENERATOR=" + target)

# Add the run target CPU, OS, and pointer size as features.
config.available_features.add("CPU=" + run_cpu)
config.available_features.add("OS=" + run_os)
config.available_features.add("PTRSIZE=" + run_ptrsize)
config.available_features.add("VENDOR=" + run_vendor)

config.available_features.add("SWIFT_VERSION=" + swift_version)

config.available_features.add("STDLIB_VARIANT={}".format(config.variant_suffix[1:]))

if "target-same-as-host" in config.available_features:
    # Only add SWIFT_SDKS features if we're building host tools
    for sdk in config.swift_sdks:
        config.available_features.add("SWIFT_SDK=" + sdk.lower())

if "optimized_stdlib" in config.available_features:
  config.available_features.add("optimized_stdlib_" + run_cpu)

swift_test_mode = lit_config.params.get('swift_test_mode', 'optimize_none')
swift_execution_tests_extra_flags = ''
if swift_test_mode == 'optimize_none':
    config.available_features.add("nonexecutable_test")
    config.available_features.add("executable_test")
    config.available_features.add("swift_test_mode_optimize_none")
    # Add the cpu as a feature so we can selectively disable tests in an
    # optimize mode for a cpu.
    config.available_features.add("swift_test_mode_optimize_none_" + run_cpu)
    swift_execution_tests_extra_flags = ''
elif swift_test_mode == 'optimize_none_with_implicit_dynamic':
    config.available_features.add("executable_test")
    config.limit_to_features.add("executable_test")
    config.available_features.add("swift_test_mode_optimize_none_with_implicit_dynamic")
    # Add the cpu as a feature so we can selectively disable tests in an
    # optimize mode for a cpu.
    config.available_features.add("swift_test_mode_optimize_none_" + run_cpu)
    swift_execution_tests_extra_flags = '-Xfrontend -enable-implicit-dynamic -Xfrontend -enable-private-imports -Xfrontend -enable-dynamic-replacement-chaining'
elif swift_test_mode == 'optimize_with_implicit_dynamic':
    config.available_features.add("executable_test")
    config.limit_to_features.add("executable_test")
    config.available_features.add("swift_test_mode_optimize_with_implicit_dynamic")
    # Add the cpu as a feature so we can selectively disable tests in an
    # optimize mode for a cpu.
    config.available_features.add("swift_test_mode_optimize_" + run_cpu)
    swift_execution_tests_extra_flags = '-O -Xfrontend -enable-implicit-dynamic -Xfrontend -enable-private-imports -Xfrontend -enable-dynamic-replacement-chaining'
elif swift_test_mode == 'optimize':
    config.available_features.add("executable_test")
    config.limit_to_features.add("executable_test")
    config.available_features.add("swift_test_mode_optimize")
    # Add the cpu as a feature so we can selectively disable tests in an
    # optimize mode for a cpu.
    config.available_features.add("swift_test_mode_optimize_" + run_cpu)
    swift_execution_tests_extra_flags = '-O'
elif swift_test_mode == 'optimize_size':
    config.available_features.add("executable_test")
    config.limit_to_features.add("executable_test")
    config.available_features.add("swift_test_mode_optimize_size")
    # Add the cpu as a feature so we can selectively disable tests in an
    # optimize mode for a cpu.
    config.available_features.add("swift_test_mode_optimize_" + run_cpu)
    swift_execution_tests_extra_flags = '-Osize'
elif swift_test_mode == 'optimize_unchecked':
    config.available_features.add("executable_test")
    config.limit_to_features.add("executable_test")
    config.available_features.add("swift_test_mode_optimize_unchecked")
    # Add the cpu as a feature so we can selectively disable tests in an
    # optimize mode for a cpu.
    config.available_features.add("swift_test_mode_optimize_unchecked_" + run_cpu)
    swift_execution_tests_extra_flags = '-Ounchecked'
elif swift_test_mode == 'only_executable':
    config.available_features.add("executable_test")
    config.limit_to_features.add("executable_test")
elif swift_test_mode == 'only_non_executable':
    config.available_features.add("nonexecutable_test")
elif swift_test_mode == 'with_cxx_interop':
    config.available_features.add("nonexecutable_test")
    config.available_features.add("executable_test")
    config.available_features.add("with_cxx_interop")
    config.swift_frontend_test_options += ' -cxx-interoperability-mode=default'
    config.swift_driver_test_options += ' -cxx-interoperability-mode=default'
    config.swift_ide_test_test_options += ' -cxx-interoperability-mode=default'
else:
    lit_config.fatal("Unknown test mode %r" % swift_test_mode)

swift_test_subset = lit_config.params.get('swift_test_subset', 'validation')
if swift_test_subset in ['primary', 'validation', 'only_validation']:
    # No extra flags needed.
    pass
elif swift_test_subset == 'all':
    config.available_features.add("long_test")
    config.available_features.add("stress_test")
elif swift_test_subset == 'only_long':
    config.available_features.add("long_test")
    config.limit_to_features.add("long_test")
    config.limit_to_features.discard("executable_test")
elif swift_test_subset == 'only_stress':
    config.available_features.add("stress_test")
    config.limit_to_features.add("stress_test")
    config.limit_to_features.discard("executable_test")
else:
    lit_config.fatal("Unknown test subset %r" % swift_test_subset)

if 'swift_evolve' in lit_config.params:
    config.available_features.add("swift_evolve")

if not 'swift_driver' in lit_config.params:
    config.available_features.add("cplusplus_driver")

# SwiftCompilerSources are now always enabled:
# TODO: remove all the `REQUIRES: swift_in_compiler` in tests
config.available_features.add('swift_in_compiler')

# Check if we need to run lit tests using the legacy driver or the new driver
# The default for existing test runs is to use the legacy driver.
# The new driver is tested separately.
if os.environ.get('SWIFT_FORCE_TEST_NEW_DRIVER') is None:
    config.environment['SWIFT_USE_OLD_DRIVER'] = '1'
    config.environment['SWIFT_AVOID_WARNING_USING_OLD_DRIVER'] = '1'

# Enable benchmark testing when the binary is found (has fully qualified path).
if config.benchmark_o != 'Benchmark_O':
    config.available_features.add('benchmark')

# Add substitutions for the run target triple, CPU, OS, and pointer size.
config.substitutions.append(('%target-triple', config.variant_triple))

# Keep track of which sanitizers need to be enabled (matters for some tests)
config.sanitizers = []
if 'asan' in config.available_features:
    config.sanitizers.append('address')

if run_vendor == 'apple':
    if run_os == 'maccatalyst':
        config.stable_abi_triple = '%s-%s-ios13.1-macabi' % (run_cpu, run_vendor)
        config.pre_stable_abi_triple = config.stable_abi_triple
        config.next_stable_abi_triple = config.stable_abi_triple
        config.future_abi_triple = '%s-%s-ios99-macabi' % (run_cpu, run_vendor)
        config.abi_stability = 'stable'
        config.available_features.add('swift_stable_abi')
    else:
        # iOS 12.2 does not support 32-bit targets, so we cannot run tests that
        # want to deploy to an iOS that has Swift in the OS.
        if run_os == 'ios' and run_ptrsize == '32':
            pre_stable_version = '10'
            config.abi_stability = 'unstable'
        else:
            config.available_features.add('swift_stable_abi')
            PRE_STABLE_VERSION = {
                'macosx': '10.14.3',
                'ios': '12.1',
                'maccatalyst': '12.1',
                'tvos': '12.1',
                'watchos': '5.1',
                'xros': '1.0'
            }
            pre_stable_version = PRE_STABLE_VERSION.get(run_os, '')

        config.pre_stable_abi_triple = '%s-%s-%s%s%s' % (run_cpu, run_vendor, run_os,
                                                         pre_stable_version, run_environment)
        STABLE_VERSION = {
            'macosx': '10.14.4',
            'ios': '12.2',
            'maccatalyst': '12.2',
            'tvos': '12.2',
            'watchos': '5.2',
            'xros': '1.0'
        }
        stable_version = STABLE_VERSION.get(run_os, '')
        config.stable_abi_triple = '%s-%s-%s%s%s' % (run_cpu, run_vendor, run_os,
                                                     stable_version, run_environment)

        NEXT_STABLE_VERSION = {
            'macosx': '10.15',
            'ios': '13',
            'maccatalyst': '13',
            'tvos': '13',
            'watchos': '6',
            'xros': '1.0'
        }
        next_stable_version = NEXT_STABLE_VERSION.get(run_os, '')
        config.next_stable_abi_triple = '%s-%s-%s%s%s' % (run_cpu, run_vendor, run_os,
                                                          next_stable_version, run_environment)
        FUTURE_VERSION = {
            'macosx': '99.99',
            'ios': '99.99',
            'maccatalyst': '99.99',
            'tvos': '99.99',
            'watchos': '99.99'
        }
        future_version = FUTURE_VERSION.get(run_os, '')
        config.future_triple = '%s-%s-%s%s%s' % (run_cpu, run_vendor, run_os,
                                                 future_version, run_environment)
        config.abi_stability = 'stable'

else:
    config.pre_stable_abi_triple = config.variant_triple
    config.stable_abi_triple = config.variant_triple
    config.next_stable_abi_triple = config.variant_triple
    config.future_triple = config.variant_triple
    config.abi_stability = 'unstable'

# On Apple platforms, this substitution names the maximum OS version *without*
# Swift in the OS. On non-Apple platforms this is equivalent to %target-triple.
config.substitutions.append(('%target-pre-stable-abi-triple',
                             config.pre_stable_abi_triple))

# On Apple platforms, this substitution names the minimum OS version with
# Swift 5.0 in the OS. On non-Apple platforms this is equivalent to %target-triple.
config.substitutions.append(('%target-stable-abi-triple',
                             config.stable_abi_triple))

# On Apple platforms, this substitution names the minimum OS version with
# Swift 5.1 in the OS, and an Objective-C runtime supporting class stubs.
config.substitutions.append(('%target-next-stable-abi-triple',
                             config.next_stable_abi_triple))

config.substitutions.append(('%target-future-triple',
                             config.future_triple))

config.substitutions.append(('%target-abi-stability',
                             config.abi_stability))

config.substitutions.append(('%target-cpu', run_cpu))

target_os_abi = run_os
target_os_is_maccatalyst = "FALSE"
target_mandates_stable_abi = "FALSE"
if (run_cpu in ('arm64e',) or \
    (run_os == 'watchos' and run_cpu == 'x86_64') or \
    (run_os == 'xros')):
  target_mandates_stable_abi = "TRUE"
  config.available_features.add('swift_only_stable_abi')
if run_os in ('maccatalyst',):
  # For purposes of ABI, treat maccatalyst as macosx since the maccatalyst ABI
  # must match the macosx ABI.
  target_os_abi = 'macosx'
  target_os_is_maccatalyst = "TRUE"
  config.available_features.add("OS=ios")
# macOS and simulators on ASi use the stable ABI
if (run_os in ('macosx',) or 'simulator' in run_environment) and run_cpu in ('arm64',):
  target_mandates_stable_abi = "TRUE"
  config.available_features.add('swift_only_stable_abi')
if run_os in (
              'linux-android', 'linux-androideabi',             # Android
              'freebsd', 'openbsd',                             # BSD
              'linux-gnu', 'linux-gnueabihf',                   # Linux
              'windows-cygnus', 'windows-gnu', 'windows-msvc',  # Windows
             ):
  target_mandates_stable_abi = "TRUE"
  config.available_features.add('swift_only_stable_abi')

if run_os in ('macosx', 'ios', 'maccatalyst', 'tvos', 'watchos', 'xros'):
    target_os_family = 'DARWIN'
    target_os_binfmt = 'MACH-O'
elif run_os in ('windows-cygnus', 'windows-gnu', 'windows-msvc'):
    target_os_family = 'WINDOWS'
    target_os_binfmt = 'PE-COFF'
elif run_os in ('linux-gnu', 'linux-gnueabihf', 'linux-android', 'linux-androideabi'):
    target_os_family = 'LINUX'
    target_os_binfmt = 'ELF'
elif run_os in ('freebsd', 'openbsd'):
    target_os_family = 'BSD'
    target_os_binfmt = 'ELF'
else:
    target_os_family = 'UNKNOWN'
    target_os_binfmt = 'UNKNOWN'

config.available_features.add('OS_FAMILY={}'.format(target_os_family.lower()))
config.available_features.add('OS_BINFMT={}'.format(target_os_binfmt.lower()))

for family in ('DARWIN', 'WINDOWS', 'LINUX', 'BSD', 'UNKNOWN'):
    if family == target_os_family:
        subst = family
    else:
        subst = ""
    config.substitutions.append(
        ('%target-os-family-{}'.format(family.lower()), subst)
    )
config.substitutions.append(('%target-os-family', target_os_family))

for binfmt in ('MACH-O', 'PE-COFF', 'ELF', 'UNKNOWN'):
    if binfmt == target_os_binfmt:
        subst = binfmt
    else:
        subst = ""
    config.substitutions.append(
        ('%target-os-binfmt-{}'.format(binfmt.lower()), subst)
    )
config.substitutions.append(('%target-os-binfmt', target_os_binfmt))

config.substitutions.append(('%target-os-abi', target_os_abi))
config.substitutions.append(('%target-os-is-maccatalyst', target_os_is_maccatalyst))
config.substitutions.append(('%target-mandates-stable-abi',
                               target_mandates_stable_abi))
config.substitutions.append(('%target-endian', run_endian))
config.substitutions.append(('%target-os', run_os))
config.substitutions.append(('%target-ptrsize', run_ptrsize))
config.substitutions.append(('%target-vendor', run_vendor))
config.substitutions.append(('%target-alignment', "%d" % (int(run_ptrsize)/8)))

if platform.system() == 'Darwin':
  config.substitutions.append(('%is-darwin', 'isDarwin'))
else:
  config.substitutions.append(('%is-darwin', 'isNotDarwin'))

# Enable Darwin SDK-dependent tests if we have an SDK.
# On Linux, assume that SDK path does not point to the Darwin SDK.
if config.variant_sdk != "":
  config.substitutions.append(('%sdk', '"%s"' % config.variant_sdk))

# Enable interpreter-based tests on platforms where the interpreter is known to
# work.
if platform.system() == 'Darwin' and (run_os == 'macosx' or run_os == 'darwin'):
    # Disable REPL tests if SDK overlay is not in the resource dir.
    # <rdar://problem/16678410> Adding more libraries with -lfoo to REPL is broken
    if swift_test_mode != 'only_non_executable':
      config.available_features.add('swift_repl')
      config.available_features.add('swift_interpreter')
elif platform.system() == 'Linux':
    if swift_test_mode != 'only_non_executable':
      config.available_features.add('swift_interpreter')

# swift-remoteast-test requires the ability to compile and run code
# for the system we compiled the swift-remoteast-test executable on.
# This is potentially a stronger constraint than just "can we interpret",
# but use that as an approximation for now.
if 'swift_interpreter' in config.available_features:
    config.available_features.add('swift-remoteast-test')

config.target_runtime = "unknown"

if (getattr(config, 'darwin_enable_maccatalyst', False) and
    config.darwin_maccatalyst_build_flavor == "ios-like"):
    variant_suffix = config.darwin_osx_variant_suffix
else:
    variant_suffix = config.variant_suffix
swift_reflection_test_name = 'swift-reflection-test' + variant_suffix

def use_interpreter_for_simple_runs():
    def make_simple_target_run(gyb=False, stdlib=False, parameterized=False):
        result = ''
        if gyb:
            result += ('%empty-directory(%t) && '
                       '%gyb %s -o %t/main.swift && '
                       '%line-directive %t/main.swift -- ')
        # FIXME: SWIFT_INTERPRETER needs to be a set of arguments, not just a
        # path.
        result += (
            'env SWIFT_INTERPRETER=%r %s %r %s -module-name main %s %s %s '
            % (
                escape_for_substitute_captures(config.swift),
                escape_for_substitute_captures(xcrun_prefix),
                escape_for_substitute_captures(config.swift),
                escape_for_substitute_captures(target_options),
                escape_for_substitute_captures(config.swift_test_options),
                escape_for_substitute_captures(config.swift_driver_test_options),
                escape_for_substitute_captures(swift_execution_tests_extra_flags)
            )
        )
        if stdlib:
            result += '-Xfrontend -disable-access-control '
        if parameterized:
            result += r' \1 '
        if gyb:
            result += '%t/main.swift'
        else:
            result += '%s'
        return SubstituteCaptures(result)

    config.target_run_stdlib_swiftgyb = make_simple_target_run(gyb=True)
    config.target_run_simple_swiftgyb = make_simple_target_run(gyb=True)
    config.target_run_stdlib_swift = make_simple_target_run(stdlib=True)
    config.target_run_simple_swift = make_simple_target_run()
    config.target_run_simple_swift_parameterized = make_simple_target_run(parameterized=True)
    config.target_run_stdlib_swift_parameterized = make_simple_target_run(stdlib=True, parameterized=True)
    config.target_run_simple_swiftgyb_parameterized = make_simple_target_run(gyb=True, parameterized=True)
    config.available_features.add('interpret')

target_specific_module_triple = config.variant_triple
target_future = target_specific_module_triple

config.target_run = ''
config.target_not_crash = 'not --crash'
config.target_rtti_opt = '-fno-rtti'
config.target_pic_opt = ''
config.target_cxx_lib = '-lc++'
config.target_msvc_runtime_opt = ''
config.target_static_library_prefix = 'lib'
config.target_static_library_suffix = '.a'
config.target_env_prefix = ''
config.target_sdk_libcxx_path = ''
config.target_clang_resource_dir_opt = ''

if run_vendor == 'apple':
    target_specific_module_triple = '{}-apple-{}'.format(
        { 'aarch64': 'arm64', 'amd64': 'x86_64' }.get(run_cpu, run_cpu),
        { 'macosx': 'macos', 'darwin': 'macos' }.get(run_os, run_os)
    )

    config.target_object_format = "macho"
    config.target_shared_library_prefix = 'lib'
    config.target_shared_library_suffix = ".dylib"
    if 'use_os_stdlib' not in lit_config.params:
        config.target_codesign = make_path(config.swift_utils, "swift-darwin-postprocess.py")
    else:
        config.target_codesign = "codesign -f -s - --entitlements {}".format(os.path.join(config.swift_utils, 'get-task-allow.plist'))

    config.target_library_path_var = "DYLD_LIBRARY_PATH"
    config.target_runtime = "objc"
    config.target_sdk_libcxx_path = os.path.join(config.variant_sdk, 'usr', 'include', 'c++', 'v1')

    config.available_features.add('libdispatch')
    config.available_features.add('foundation')
    config.available_features.add('objc_interop')
    run_objc_interop = "objc"

    # The "freestanding" tests will link against the static libswiftCore.a and
    # cannot use any of Obj-C / Dispatch / Foundation.
    if "-freestanding" in config.variant_suffix:
        if not config.swift_freestanding_is_darwin:
            config.target_runtime = "native"
        if not config.swift_enable_dispatch:
            config.available_features.remove('libdispatch')
        if not config.swift_freestanding_is_darwin:
            config.available_features.remove('foundation')
        if not config.swift_stdlib_enable_objc_interop:
            config.available_features.remove('objc_interop')
        config.available_features.add('freestanding')

        # Build all "freestanding" tests with -disable-objc-interop
        if not config.swift_stdlib_enable_objc_interop:
            swift_execution_tests_extra_flags += ' -Xfrontend -disable-objc-interop'

        # The Concurrency module is not available in "freestanding" mode.
        if not 'concurrency' in config.available_features:
            swift_execution_tests_extra_flags += \
                    ' -Xfrontend -disable-implicit-concurrency-module-import'

        # Freestanding doesn't back deploy.
        swift_execution_tests_extra_flags += \
                ' -Xfrontend -disable-autolinking-runtime-compatibility-concurrency' + \
                ' -runtime-compatibility-version none'

        # To have visible references from symbolic manglings
        swift_execution_tests_extra_flags += \
                ' -Xfrontend -disable-standard-substitutions-in-reflection-mangling'

        # Link all "freestanding" tests with -dead_strip, which can effectively
        # even remove parts of the stdlib and runtime, if it's not needed. Since
        # it's a very desired behavior, let's enable it for all executable tests.
        if not config.swift_freestanding_is_darwin:
            swift_execution_tests_extra_flags += ' -Xlinker -dead_strip'

        # TODO: consider making the addition of these flags dependent on the CMake
        # setting for hermetic seal at link
        if not config.swift_freestanding_is_darwin and not config.swift_stdlib_use_use_fragile_resilient_protocol_witness_tables:
            swift_execution_tests_extra_flags += ' -experimental-hermetic-seal-at-link -lto=llvm-full'

        if not config.swift_freestanding_is_darwin:
            swift_execution_tests_extra_flags += ' -Xfrontend -disable-preallocated-instantiation-caches'

        if not config.swift_freestanding_is_darwin:
            swift_execution_tests_extra_flags += ' -Xfrontend -reflection-metadata-for-debugger-only'

        if config.swift_stdlib_use_relative_protocol_witness_tables:
            swift_execution_tests_extra_flags += ' -Xfrontend -enable-relative-protocol-witness-tables -Xfrontend -swift-async-frame-pointer=never'

        if config.swift_stdlib_use_use_fragile_resilient_protocol_witness_tables:
            swift_execution_tests_extra_flags += ' -Xfrontend -enable-fragile-relative-protocol-tables'

        # Build a resource dir for freestanding tests.
        new_resource_dir = os.path.join(config.test_exec_root, "resource_dir")
        if not os.path.exists(new_resource_dir): os.mkdir(new_resource_dir)
        def symlink_if_not_exists(src, dst):
            src = os.path.join(test_resource_dir, src)
            dst = os.path.join(new_resource_dir, dst)
            if not os.path.exists(dst): os.symlink(src, dst)
        symlink_if_not_exists("clang", "clang")
        symlink_if_not_exists("shims", "shims")
        symlink_if_not_exists("freestanding", "macosx")
        # This is needed to allow compiling against Dispatch
        # TODO: consider making this dependent on swift_enable_dispatch
        if config.swift_freestanding_is_darwin:
            symlink_if_not_exists("apinotes", "apinotes")
        config.resource_dir_opt = "-resource-dir %s" % new_resource_dir
        lit_config.note('Using freestanding resource dir: ' + new_resource_dir)

    # Auto-linking does not work when stdlib is built with LTO, because linked
    # libraries are discovered too late (after optimizations are applied), and
    # ld64 hits an assert and crashes, or worse, deadlocks. Until ld64 fixes
    # this, let's workaround it by explicitly -l linking all libraries needed in
    # tests.
    # rdar://70787171
    if "stdlib_lto" in config.available_features:
        libraries = ["swiftCore", "swiftStdlibUnittest",
                     "swiftStdlibUnicodeUnittest",
                     "swiftStdlibCollectionUnittest",
                     "swiftSwiftPrivateLibcExtras", "swiftSwiftPrivate",
                     "swiftDarwin", "swiftSwiftPrivateThreadExtras",
                     "swiftSwiftOnoneSupport", "swift_Concurrency"]
        if backtracing is not None:
            libraries.append('swiftRuntime')
        for library in libraries:
            swift_execution_tests_extra_flags += ' -Xlinker -l%s'% library

        swift_native_clang_tools_path = lit_config.params.get('swift_native_clang_tools_path', None)
        if swift_native_clang_tools_path:
            swift_execution_tests_extra_flags += ' -Xlinker -lto_library -Xlinker %s/../lib/libLTO.dylib' % swift_native_clang_tools_path

    xcrun_prefix = (
        "xcrun --toolchain %s --sdk %r" %
        (config.darwin_xcrun_toolchain, config.variant_sdk))
    extra_frameworks_dir = make_path(config.variant_sdk, "..", "..", "..",
                                     "Developer", "Library", "Frameworks")
    extra_platform_swift_modules = make_path(config.variant_sdk, "..", "..", "..",
                                             "Developer", "usr", "lib")
    extra_platform_search_paths = '-F %r -I %r' % (extra_frameworks_dir, extra_platform_swift_modules)

    target_options = (
        "-target %s %s %s" %
        (config.variant_triple, config.resource_dir_opt, mcp_opt))
    target_options_for_mock_sdk = (
        "-target %s %s %s" %
        (config.variant_triple, stdlib_resource_dir_opt, mcp_opt))
    target_options_for_mock_sdk_after = sdk_overlay_dir_opt
    target_future_version = ''

    # Only permit non-executable tests for ARM on Darwin unless you are on macOS
    if 'simulator' not in run_environment and run_os not in ('macosx',):
        if swift_test_mode != 'only_non_executable':
            raise RuntimeError('Device tests are currently only supported when '
            'the swift_test_mode is "only_non_executable". Current '
            'swift_test_mode is {}.'.format(swift_test_mode))

    if 'simulator' not in run_environment and not (run_os == 'macosx' or run_os == 'maccatalyst'):
       # iOS/tvOS/watchOS device
       if run_os == 'ios':
           lit_config.note('Testing iOS ' + config.variant_triple)
           xcrun_sdk_name = "iphoneos"
           target_future_version = "99.99.0"
       elif run_os == 'tvos':
           lit_config.note('Testing AppleTV ' + config.variant_triple)
           xcrun_sdk_name = "appletvos"
           target_future_version = "99.99.0"
       elif run_os == 'watchos':
           lit_config.note('Testing watchOS ' + config.variant_triple)
           xcrun_sdk_name = "watchos"
           target_future_version = "99.99.0"

       config.target_env_prefix = 'IOS_CHILD_'

       config.target_cc_options = (
           "-target %s %s" %
           (config.variant_triple, clang_mcp_opt))

       config.target_build_swift = (
           ("%s %s %s -F %r -toolchain-stdlib-rpath " +
            "-Xlinker -rpath -Xlinker %r " +
            "-Xlinker -rpath -Xlinker /usr/lib/swift " +
            # This ensures LC_LOAD_DYLIB rewrite will succeed in %target-codesign (rdar://7885126):
            "-Xlinker -headerpad_max_install_names " +
            "%s %s %s %s") %
           (xcrun_prefix, config.swiftc, target_options,
            extra_frameworks_dir,
            "/tmp/swifttest-device/lib",
            sdk_overlay_linker_opt, config.swift_test_options,
            config.swift_driver_test_options,
            swift_execution_tests_extra_flags))
       config.target_run = "unsupported"

       (sw_vers_name, sw_vers_vers, sw_vers_build) = \
            darwin_get_sdk_version(config.variant_sdk)

    elif 'simulator' in run_environment:
        # iOS/tvOS/watchOS simulator
        if run_os == 'ios':
            config.available_features.add('DARWIN_SIMULATOR=ios')
            lit_config.note("Testing iOS simulator " + config.variant_triple)
            xcrun_sdk_name = "iphonesimulator"
            target_future_version = "99.99.0"
        elif run_os == 'watchos':
            config.available_features.add('DARWIN_SIMULATOR=watchos')
            lit_config.note("Testing watchOS simulator " + config.variant_triple)
            xcrun_sdk_name = "watchsimulator"
            target_future_version = "99.99.0"
        elif run_os == 'xros':
            config.available_features.add('DARWIN_SIMULATOR=xros')
            lit_config.note("Testing xrOS simulator " + config.variant_triple)
            xcrun_sdk_name = "xrsimulator"
            target_future_version = "99.99.0"
        else:
            config.available_features.add('DARWIN_SIMULATOR=tvos')
            lit_config.note("Testing AppleTV simulator " + config.variant_triple)
            xcrun_sdk_name = "appletvsimulator"
            target_future_version = "99.99.0"

        target_specific_module_triple += "-simulator"

        config.target_env_prefix = 'SIMCTL_CHILD_'

        config.target_cc_options = (
            "-target %s %s" %
            (config.variant_triple, clang_mcp_opt))

        config.target_build_swift = (
            ("%s %s %s -F %r -toolchain-stdlib-rpath %s " +
             "-Xlinker -rpath -Xlinker /usr/lib/swift " +
             # This ensures LC_LOAD_DYLIB rewrite will succeed in %target-codesign (rdar://7885126):
             "-Xlinker -headerpad_max_install_names " +
             " %s %s %s") %
            (xcrun_prefix, config.swiftc, target_options,
             extra_frameworks_dir,
             sdk_overlay_linker_opt, config.swift_test_options,
             config.swift_driver_test_options,
             swift_execution_tests_extra_flags))
        # FIXME: allow specification of simulator and version
        #
        # Note: don't pass '--adopt-pid' to sim.  This can trigger a kernel
        # panic.
        # <rdar://problem/11806093> multithreaded 64-to-32 exec is broken
        # (foundation tool launched with sim --adopt-pid occasionally
        # segmentation faults)
        config.target_run = (
            "%s %s " %
            (xcrun_prefix, get_simulator_command(run_os, run_cpu)))

        (sw_vers_name, sw_vers_vers, sw_vers_build) = \
            darwin_get_sdk_version(config.variant_sdk)

        if (sw_vers_name == '' or sw_vers_vers == '' or sw_vers_build == ''):
            lit_config.fatal('Could not get or decode sw_vers output. ' +
                             'Perhaps the simulator is not working.')

    elif run_os == 'macosx' or run_os == 'maccatalyst':
        # OS X
        lit_config.note("Testing OS X " + config.variant_triple)

        xcrun_sdk_name = "macosx"

        config.target_cc_options = (
            "-target %s %s" %
            (config.variant_triple, clang_mcp_opt))

        maccatalyst_frameworks_component = ""
        if run_os == 'maccatalyst':
            # Additional framework search paths for macCatalyst.
            # These have to come before other search paths so that for
            # unzippered twin frameworks the unzippered twin version
            # is favored under macCatalyst.
          maccatalyst_frameworks_dir = make_path(config.variant_sdk,
                 "System", "iOSSupport", "System", "Library", "Frameworks")
          maccatalyst_frameworks_component = ( "-F %r" % maccatalyst_frameworks_dir )
            # Module triples end in ios-macabi.
          target_specific_module_triple = '{}-apple-ios-macabi'.format(
              { 'aarch64': 'arm64', 'amd64': 'x86_64' }.get(run_cpu, run_cpu)
          )

        config.target_build_swift = (
            ("%s %s %s %s -F %r -toolchain-stdlib-rpath "
             + "-Xlinker -rpath -Xlinker %r "
             + "-Xlinker -rpath -Xlinker /usr/lib/swift "
             # This ensures LC_LOAD_DYLIB rewrite will succeed in %target-codesign (rdar://7885126):
             + "-Xlinker -headerpad_max_install_names "
             + "%s %s %s %s "
             + "-F %r -Xlinker -rpath -Xlinker %r")
            % (xcrun_prefix, config.swiftc, target_options,
               maccatalyst_frameworks_component,
               extra_frameworks_dir, extra_frameworks_dir,
               sdk_overlay_linker_opt, config.swift_test_options,
               config.swift_driver_test_options,
               swift_execution_tests_extra_flags, sourcekitd_framework_dir,
               sourcekitd_framework_dir))

        config.target_run = ""
        target_future_version = "99.99"

        if 'interpret' in lit_config.params:
            use_interpreter_for_simple_runs()

        (sw_vers_name, sw_vers_vers, sw_vers_build) = \
            darwin_get_sw_vers()

        if re.match('^(1[3-9]|[2-9])', sw_vers_vers):
            config.available_features.add('macos_min_version_13')

    else:
        lit_config.fatal("Unknown Apple OS '" + run_os + "' " +
                         "(from " + config.variant_triple + ")")

    lit_config.note(
        'Running tests on %s version %s (%s)' %
        (sw_vers_name, sw_vers_vers, sw_vers_build))

    if "-freestanding" in config.variant_suffix and config.swift_freestanding_is_darwin:
        # This will ensure we are able to find libraries
        # and resource dir at the correct path in tests that require
        # Foundation and ObjectiveC capabilities
        config.target_sdk_name = config.freestanding_sdk_name
    else:
        config.target_sdk_name = xcrun_sdk_name
    config.target_ld = "%s ld -L%r" % (xcrun_prefix, make_path(test_resource_dir, config.target_sdk_name))

    maccatalyst_extra_frameworks = ""
    if run_os == 'maccatalyst':
        maccatalyst_extra_frameworks = "-F {}/System/iOSSupport/System/Library/Frameworks".format(config.variant_sdk)

    swift_frontend_platform_remap_config = ""
    swiftc_platform_remap_config = ""
    if run_os == 'xros':
        swift_frontend_platform_remap_config = "-platform-availability-inheritance-map-path %s" % platform_remap_mock_sdk_config
        swiftc_platform_remap_config = "-Xfrontend -platform-availability-inheritance-map-path -Xfrontend %s" % platform_remap_mock_sdk_config

    config.target_swift_frontend = (
        "%s %s -sdk %r %s %s %s %s" %
        (config.swift_frontend, target_options, config.variant_sdk, maccatalyst_extra_frameworks,
         config.swift_test_options, config.swift_frontend_test_options,
         swift_frontend_platform_remap_config))
    subst_target_swift_frontend_mock_sdk = (
        "%s %s -sdk %r %s %s %s" %
        (config.swift_frontend, target_options_for_mock_sdk, config.variant_sdk,
         config.swift_test_options, config.swift_frontend_test_options,
         swift_frontend_platform_remap_config))
    config.target_swift_modulewrap = (
        '%s -modulewrap -target %s' %
        (config.swiftc, config.variant_triple))
    config.target_swift_emit_pcm = (
        '%s -emit-pcm -target %s -sdk %r' %
        (config.swiftc, config.variant_triple, config.variant_sdk))
    subst_target_swift_frontend_mock_sdk_after = \
        target_options_for_mock_sdk_after
    config.target_sil_opt = (
        "%s %s %s %s" %
        (xcrun_prefix, config.sil_opt, target_options, config.sil_test_options))
    subst_target_sil_opt_mock_sdk = (
        "%s %s" %
        (config.sil_opt, target_options_for_mock_sdk))
    subst_target_sil_opt_mock_sdk_after = \
        target_options_for_mock_sdk_after
    config.target_swift_symbolgraph_extract = (
        "%s %s %s" %
        (xcrun_prefix, config.swift_symbolgraph_extract, target_options))
    config.target_swift_synthesize_interface = (
        "%s %s %s" %
        (xcrun_prefix, config.swift_synthesize_interface, target_options))
    config.target_swift_ide_test = (
        "%s %s %s %s %s" %
        (xcrun_prefix, config.swift_ide_test, target_options, ccp_opt,
         config.swift_ide_test_test_options))
    subst_target_swift_ide_test_mock_sdk = (
        "%s %s %s %s %s" %
        (xcrun_prefix, config.swift_ide_test, target_options_for_mock_sdk, ccp_opt,
         config.swift_ide_test_test_options))
    subst_target_swift_ide_test_mock_sdk_after = \
        target_options_for_mock_sdk_after
    config.target_swiftc_driver = (
        ("%s %s -toolchain-stdlib-rpath %s " +
         # This ensures LC_LOAD_DYLIB rewrite will succeed in %target-codesign (rdar://7885126):
         "-Xlinker -headerpad_max_install_names " +
         "-Xlinker -rpath -Xlinker /usr/lib/swift %s %s ")%
        (xcrun_prefix, config.swiftc, target_options, config.swift_driver_test_options, swiftc_platform_remap_config))
    config.target_stdlib_swiftc_driver = config.target_swiftc_driver
    config.target_clang = (
        "%s %s %s" %
        (xcrun_prefix, config.clangxx, config.target_cc_options))

    config.target_build_swift_dylib = SubstituteCaptures(
        f"{escape_for_substitute_captures(config.target_build_swift)}"
        r" -parse-as-library -emit-library -o '\1'"
        r" -Xlinker -install_name -Xlinker @executable_path/$(basename '\1')"
    )
    config.target_add_rpath = SubstituteCaptures(r'-Xlinker -rpath -Xlinker \1')

    target_future = format('%s-apple-%s%s%s' % (run_cpu, run_os, target_future_version, run_environment))

    config.otool_classic = ("%s otool-classic" % (xcrun_prefix))

    SDK_2020_VERSION = {
        'macosx': '11.0',
        'ios': '14.0',
        'maccatalyst': '14.0',
        'tvos': '14.0',
        'watchos': '7.0',
        'xros': '1.0'
    }
    sdk_2020_version = SDK_2020_VERSION.get(run_os, '')
    SDK_2021_VERSION = {
        'macosx': '12.0',
        'ios': '15.0',
        'maccatalyst': '15.0',
        'tvos': '15.0',
        'watchos': '8.0',
        'xros': '1.0'
    }
    sdk_2021_version = SDK_2021_VERSION.get(run_os, '')
    linker_os = {
        'iphoneos': 'ios',
        'appletvos': 'tvos',
        'watchos': 'watchos',
        'xros': 'xros',
        'iphonesimulator': 'ios-simulator',
        'watchsimulator': 'watchos-simulator',
        'appletvsimulator': 'tvos-simulator',
        'macosx': 'macos',
        'xrsimulator': 'xros-simulator'
    }.get(config.target_sdk_name, run_os)

    config.target_link_sdk_2020_version = (
      "-Xlinker -platform_version -Xlinker %s -Xlinker %s -Xlinker %s" %
      (linker_os, sdk_2020_version, sdk_2020_version))
    config.target_link_sdk_2021_version = (
      "-Xlinker -platform_version -Xlinker %s -Xlinker %s -Xlinker %s" %
      (linker_os, sdk_2021_version, sdk_2021_version))
    config.target_link_sdk_future_version = (
      "-Xlinker -platform_version -Xlinker %s -Xlinker %s -Xlinker %s" %
      (linker_os, target_future_version, target_future_version))

elif run_os in ['windows-msvc']:
    lit_config.note('Testing Windows ' + config.variant_triple)
    if 'NUMBER_OF_PROCESSORS' in os.environ:
        config.environment['NUMBER_OF_PROCESSORS'] = os.environ['NUMBER_OF_PROCESSORS']
    if 'PROCESSOR_ARCHITEW6432' in os.environ:
        config.environment['PROCESSOR_ARCHITEW6432'] = os.environ['PROCESSOR_ARCHITEW6432']
    if 'PROCESSOR_ARCHITECTURE' in os.environ:
        config.environment['PROCESSOR_ARCHITECTURE'] = os.environ['PROCESSOR_ARCHITECTURE']
    if 'PROCESSOR_IDENTIFIER' in os.environ:
        config.environment['PROCESSOR_IDENTIFIER'] = os.environ['PROCESSOR_IDENTIFIER']
    config.environment['PYTHON_EXECUTABLE'] = sys.executable
    config.target_object_format = 'coff'
    config.target_shared_library_prefix = ''
    config.target_shared_library_suffix = '.dll'
    config.target_static_library_prefix = ''
    config.target_static_library_suffix = '.lib'
    config.target_sdk_name = 'windows'
    config.target_runtime = 'native'
    config.target_cc_options = ""
    config.target_rtti_opt = "-frtti"
    config.target_cxx_lib = ""
    config.target_msvc_runtime_opt = '-%s -D_MT' % config.swift_stdlib_msvc_runtime
    if 'D' in config.swift_stdlib_msvc_runtime:
        config.target_msvc_runtime_opt += ' -D_DLL'
    config.target_env_prefix = ''

    config.target_build_swift =                                                  \
            ('%r -target %s %s %s %s %s %s -libc %s' %                           \
                    (config.swiftc, config.variant_triple,                       \
                     config.resource_dir_opt, config.swift_system_overlay_opt,   \
                     config.swift_test_options, config.swift_driver_test_options,\
                     swift_execution_tests_extra_flags,                          \
                     config.swift_stdlib_msvc_runtime))

    config.target_run = ''

    config.target_swift_frontend =                                               \
            ('%r -target %s %s %s %s %s %s' % (config.swift_frontend,            \
                                               config.variant_triple,            \
                                               config.resource_dir_opt, mcp_opt, \
                                               config.swift_system_overlay_opt,  \
                                               config.swift_test_options,        \
                                               config.swift_frontend_test_options))

    config.target_codesign = 'echo'

    subst_target_swift_frontend_mock_sdk = config.target_swift_frontend
    subst_target_swift_frontend_mock_sdk_after = ''

    config.target_build_swift_dylib =                                            \
            SubstituteCaptures(r"%s -parse-as-library -emit-library -o \1" % (
                escape_for_substitute_captures(config.target_build_swift)))
    config.target_add_rpath = r''

    config.target_clang =                                                        \
            ('clang++ -target %s %s %s -fobjc-runtime=ios-5.0' %                 \
             (config.variant_triple, clang_mcp_opt, config.target_cc_options))
    config.target_ld =                                                           \
            ('%r -libpath:%s' % (config.link, os.path.join(test_resource_dir,    \
                                                           config.target_sdk_name)))
    config.target_sil_opt =                                                      \
            ('%r -target %s %s %s %s %s' % (config.sil_opt,                      \
                                            config.variant_triple,               \
                                            config.resource_dir_opt, mcp_opt,    \
                                            config.swift_system_overlay_opt,     \
                                            config.sil_test_options))
    subst_target_sil_opt_mock_sdk = config.target_sil_opt
    subst_target_sil_opt_mock_sdk_after = ''
    config.target_swift_symbolgraph_extract =                                    \
            ('%r -target %s %s' % (config.swift_symbolgraph_extract,             \
                                         config.variant_triple,                  \
                                         mcp_opt))
    config.target_swift_synthesize_interface =                                   \
            ('%r -target %s %s' % (config.swift_synthesize_interface,            \
                                         config.variant_triple,                  \
                                         mcp_opt))
    config.target_swift_ide_test =                                               \
            ('%r -target %s %s %s %s %s' % (config.swift_ide_test,               \
                                            config.variant_triple,               \
                                            config.resource_dir_opt, mcp_opt,    \
                                            ccp_opt,                             \
                                            config.swift_ide_test_test_options))

    subst_target_swift_ide_test_mock_sdk = config.target_swift_ide_test
    subst_target_swift_ide_test_mock_sdk_after = ''

    config.target_swiftc_driver =                                                \
            ('%r -target %s %s %s %s %s' % (config.swiftc, config.variant_triple,\
                                            config.resource_dir_opt, mcp_opt,    \
                                            config.swift_system_overlay_opt,     \
                                            config.swift_driver_test_options))
    config.target_stdlib_swiftc_driver =                                         \
            ('%r -target %s %s %s %s' % (config.swiftc, config.variant_triple,   \
                                         config.resource_dir_opt, mcp_opt,       \
                                         config.swift_driver_test_options))
    config.target_swift_modulewrap =                                             \
            ('%r -modulewrap -target %s' % (config.swiftc, config.variant_triple))
    config.target_swift_emit_pcm =                                               \
            ('%r -emit-pcm -target %s %s' % (config.swiftc, config.variant_triple,  \
                                          config.swift_system_overlay_opt))


elif (run_os in ['linux-gnu', 'linux-gnueabihf', 'freebsd', 'openbsd', 'windows-cygnus', 'windows-gnu'] or
      (kIsAndroid and run_os in ['linux-android', 'linux-androideabi'])):
      # Running lit and the compiler on Android itself is more like running on Linux,
      # ie the NDK and adb aren't needed, so use this instead.

    config.target_cxx_lib = "-lstdc++"
    config.target_pic_opt = "-fPIC"

    # Linux/FreeBSD/Cygwin/Android
    if run_os == 'windows-cygnus':
      lit_config.note("Testing Cygwin " + config.variant_triple)
      config.target_object_format = "coff"
      config.target_shared_library_prefix = 'lib'
      config.target_shared_library_suffix = ".dll"
      config.target_sdk_name = "cygwin"
      config.target_cc_options = ""
    elif run_os == 'windows-gnu':
      lit_config.note("Testing MinGW " + config.variant_triple)
      config.target_object_format = "coff"
      config.target_shared_library_prefix = 'lib'
      config.target_shared_library_suffix = ".dll"
      config.target_sdk_name = "mingw"
      config.target_cc_options = ""
    elif run_os == 'freebsd':
      lit_config.note("Testing FreeBSD " + config.variant_triple)
      config.target_object_format = "elf"
      config.target_shared_library_prefix = 'lib'
      config.target_shared_library_suffix = ".so"
      config.target_sdk_name = "freebsd"
      config.target_cc_options = "-fPIE"
    elif run_os == 'openbsd':
      lit_config.note("Testing OpenBSD " + config.variant_triple)
      config.target_object_format = "elf"
      config.target_shared_library_prefix = 'lib'
      config.target_shared_library_suffix = ".so"
      config.target_sdk_name = "openbsd"
      config.target_cc_options = "-fPIE"
    elif kIsAndroid:
      lit_config.note("Testing Android " + config.variant_triple)
      config.target_object_format = "elf"
      config.target_shared_library_prefix = 'lib'
      config.target_shared_library_suffix = ".so"
      config.target_sdk_name = "android"
      config.target_cc_options = "-fPIE"
    else:
      lit_config.note("Testing Linux " + config.variant_triple)
      config.target_object_format = "elf"
      config.target_shared_library_prefix = 'lib'
      config.target_shared_library_suffix = ".so"
      config.target_sdk_name = "linux"
      config.target_cc_options = "-fPIE"
    config.target_library_path_var = "LD_LIBRARY_PATH"
    config.target_runtime = "native"
    config.target_swift_autolink_extract = inferSwiftBinary("swift-autolink-extract")

    libdispatch_artifact_dir = config.libdispatch_build_path
    libdispatch_swift_module_dir = make_path(libdispatch_artifact_dir, 'src', 'swift', 'swift')
    libdispatch_source_dir = make_path(config.swift_src_root, os.pardir, 'swift-corelibs-libdispatch')
    libdispatch_vfs_yaml =  make_path(libdispatch_artifact_dir, 'dispatch-vfs-overlay.yaml')
    libdispatch_artifacts = [
        libdispatch_vfs_yaml,
        make_path(libdispatch_artifact_dir, 'libdispatch.so'),
        make_path(libdispatch_artifact_dir, 'libswiftDispatch.so'),
        make_path(libdispatch_swift_module_dir, 'Dispatch.swiftmodule')]
    if (all(os.path.exists(p) for p in libdispatch_artifacts)):
        config.available_features.add('libdispatch')
        config.libdispatch_artifact_dir = libdispatch_artifact_dir
        config.import_libdispatch = ('-I %s -I %s -L %s -vfsoverlay %s'
            % (libdispatch_source_dir, libdispatch_swift_module_dir, libdispatch_artifact_dir, libdispatch_vfs_yaml))

    libdispatch_static_artifact_dir = os.path.join(config.libdispatch_static_build_path, 'lib')
    libdispatch_static_artifacts = [
        make_path(libdispatch_static_artifact_dir, 'libdispatch.a'),
        make_path(libdispatch_static_artifact_dir, 'libBlocksRuntime.a')]
    if (all(os.path.exists(p) for p in libdispatch_static_artifacts)):
        config.available_features.add('libdispatch_static')
        config.import_libdispatch_static = '-L %s' % libdispatch_static_artifact_dir

    config.target_build_swift = (
        '%s -target %s -toolchain-stdlib-rpath %s %s %s %s %s'
        % (config.swiftc, config.variant_triple, config.resource_dir_opt, mcp_opt,
           config.swift_test_options, config.swift_driver_test_options,
           swift_execution_tests_extra_flags))
    config.target_codesign = "echo"
    config.target_build_swift_dylib = SubstituteCaptures(
        f"{escape_for_substitute_captures(config.target_build_swift)}"
        r" -parse-as-library -emit-library -o '\1'"
    )
    config.target_add_rpath = SubstituteCaptures(r'-Xlinker -rpath -Xlinker \1')
    config.target_swift_frontend = (
        '%s -target %s %s %s %s %s '
        % (config.swift_frontend, config.variant_triple, config.resource_dir_opt, mcp_opt,
        config.swift_test_options, config.swift_frontend_test_options))
    subst_target_swift_frontend_mock_sdk = config.target_swift_frontend
    subst_target_swift_frontend_mock_sdk_after = ""
    config.target_run = ''
    if 'interpret' in lit_config.params:
        use_interpreter_for_simple_runs()
    config.target_sil_opt = (
        '%s -target %s %s %s %s' %
        (config.sil_opt, config.variant_triple, config.resource_dir_opt, mcp_opt, config.sil_test_options))
    subst_target_sil_opt_mock_sdk = config.target_sil_opt
    subst_target_sil_opt_mock_sdk_after = ""
    config.target_swift_symbolgraph_extract = (
        '%s -target %s %s' %
        (config.swift_symbolgraph_extract, config.variant_triple, mcp_opt))
    config.target_swift_synthesize_interface = (
        '%s -target %s %s' %
        (config.swift_synthesize_interface, config.variant_triple, mcp_opt))
    config.target_swift_ide_test = (
        '%s -target %s %s %s %s %s' %
        (config.swift_ide_test, config.variant_triple, config.resource_dir_opt,
         mcp_opt, ccp_opt, config.swift_ide_test_test_options))
    subst_target_swift_ide_test_mock_sdk = config.target_swift_ide_test
    subst_target_swift_ide_test_mock_sdk_after = ""
    config.target_swiftc_driver = (
        "%s -target %s -toolchain-stdlib-rpath %s %s %s" %
        (config.swiftc, config.variant_triple, config.resource_dir_opt, mcp_opt, config.swift_driver_test_options))
    config.target_stdlib_swiftc_driver = config.target_swiftc_driver
    config.target_swift_modulewrap = (
        '%s -modulewrap -target %s' %
        (config.swiftc, config.variant_triple))
    config.target_swift_emit_pcm = (
        '%s -emit-pcm -target %s' %
        (config.swiftc, config.variant_triple))
    config.target_clang = (
        "clang++ -target %s %s %s -fobjc-runtime=ios-5.0" %
        (config.variant_triple, clang_mcp_opt, config.target_cc_options))
    config.target_ld = "ld -L%r" % (make_path(test_resource_dir, config.target_sdk_name))
elif run_os == 'linux-androideabi' or run_os == 'linux-android':
    # The module triple for Android ARMv7 seems to be canonicalized in LLVM
    # to be armv7-unknown-linux-android, without the "eabi" bit. Let's remove the
    # same bit from the substitutions so the tests pass correctly.
    target_specific_module_triple = re.sub(r'androideabi', 'android',
                                           target_specific_module_triple)
    config.variant_triple = re.sub(r'androideabi', 'android', config.variant_triple)
    config.target_cc_options = "-fPIE"
    config.target_cxx_lib = "-lstdc++"
    config.target_pic_opt = "-fPIC"

    if platform.system() == 'Linux':
        prebuilt_directory = 'linux-x86_64'
    elif platform.system() == 'Darwin':
        prebuilt_directory = 'darwin-x86_64'
    elif platform.system() == 'Windows':
        # TODO: NDK distributes for Windows 32 and 64 bits. platform.machine()
        # should allow us to find out the word size, but I don't have a
        # machine to test right now. I think the values are AMD64 and x86, but
        # I'm not sure. Everybody gets the 64 bits version for now.
        prebuilt_directory = 'windows-x86_64'

    toolchain_directory = make_path(
        config.android_ndk_path, "toolchains", "llvm", "prebuilt",
        prebuilt_directory)
    tools_directory = shell_quote(make_path(
        toolchain_directory, "bin"))
    lit_config.note("Testing Android " + config.variant_triple)
    config.target_object_format = "elf"
    config.target_shared_library_prefix = 'lib'
    config.target_shared_library_suffix = ".so"
    config.target_runtime = "native"
    config.target_swift_autolink_extract = inferSwiftBinary("swift-autolink-extract")
    config.target_sdk_name = "android"
    config.target_library_path_var = "LD_LIBRARY_PATH"
    config.target_env_prefix = 'ANDROID_CHILD_'
    config.resource_dir_opt = ("-resource-dir %s" % test_resource_dir)
    # Since NDK r19, the headers and libraries are available in a unified
    # sysroot at $NDK_PATH/toolchains/llvm/prebuilt/$prebuilt_directory/sysroot,
    # so the -sdk switch can now be used.
    config.target_build_swift = ' '.join([
        config.swiftc,
        '-target', config.variant_triple,
        '-sdk', config.variant_sdk, '-Xclang-linker',
        '--target={}{}'.format(config.variant_triple, config.android_api_level),
        '-tools-directory', tools_directory,
        config.resource_dir_opt, mcp_opt, config.swift_test_options,
        config.swift_driver_test_options, swift_execution_tests_extra_flags])
    config.target_codesign = "echo"
    config.target_build_swift_dylib = SubstituteCaptures(
        f"{escape_for_substitute_captures(config.target_build_swift)}"
        r" -parse-as-library -emit-library -o '\1'"
    )
    config.target_add_rpath = SubstituteCaptures(r'-Xlinker -rpath -Xlinker \1')
    config.target_swift_frontend = ' '.join([
        config.swift_frontend,
        '-target', config.variant_triple,
        '-sdk', config.variant_sdk, config.resource_dir_opt,
        mcp_opt, config.swift_test_options, config.swift_frontend_test_options])
    subst_target_swift_frontend_mock_sdk = config.target_swift_frontend
    subst_target_swift_frontend_mock_sdk_after = ""
    config.target_run = make_path(config.swift_src_root, 'utils', 'android', 'adb_test_runner.py')
    # Use SDKROOT instead of -sdk because a couple tests set another -sdk and
    # sil-opt errors if passed -sdk multiple times.
    config.target_sil_opt = ' '.join([
        'env', 'SDKROOT={}'.format(shell_quote(config.variant_sdk)),
        config.sil_opt,
        '-target', config.variant_triple,
        config.resource_dir_opt, mcp_opt, config.sil_test_options])
    subst_target_sil_opt_mock_sdk = config.target_sil_opt
    subst_target_sil_opt_mock_sdk_after = ""
    config.target_swift_symbolgraph_extract = ' '.join([
        config.swift_symbolgraph_extract,
        '-target', config.variant_triple,
        '-sdk', config.variant_sdk, config.resource_dir_opt,
        mcp_opt])
    config.target_swift_synthesize_interface = ' '.join([
        config.swift_synthesize_interface,
        '-target', config.variant_triple,
        mcp_opt])
    config.target_swift_ide_test = ' '.join([
        'env', 'SDKROOT={}'.format(shell_quote(config.variant_sdk)),
        config.swift_ide_test,
        '-target', config.variant_triple,
        config.resource_dir_opt, mcp_opt, ccp_opt,
        config.swift_ide_test_test_options])
    subst_target_swift_ide_test_mock_sdk = config.target_swift_ide_test
    subst_target_swift_ide_test_mock_sdk_after = ""
    config.target_swiftc_driver = ' '.join([
        config.swiftc,
        '-target', config.variant_triple,
        '-toolchain-stdlib-rpath',
        '-sdk', config.variant_sdk, '-Xclang-linker',
        '--target={}{}'.format(config.variant_triple, config.android_api_level),
        '-tools-directory', tools_directory,
        config.resource_dir_opt, mcp_opt,
        config.swift_driver_test_options])
    config.target_stdlib_swiftc_driver = config.target_swiftc_driver
    config.target_swift_modulewrap = ' '.join([
        config.swiftc, '-modulewrap',
        '-target', config.variant_triple])
    config.target_swift_emit_pcm = ' '.join([
        config.swiftc, '-emit-pcm',
        '-target', config.variant_triple])
    config.target_clang = ' '.join([
        '{}/clang++'.format(tools_directory),
        '-target', config.variant_triple,
        clang_mcp_opt, '-isystem', config.variant_sdk, config.target_cc_options,
        '-fobjc-runtime=ios-5.0'])
    config.target_ld = ' '.join([
        tools_directory,
        '-L%s' % make_path(test_resource_dir, config.target_sdk_name)])
    # The Swift interpreter is not available when targeting Android.
    config.available_features.discard('swift_interpreter')
elif kIsWASI:
    lit_config.note("Testing WebAssembly/WASI " + config.variant_triple)

    config.target_object_format = "wasm"
    config.target_shared_library_prefix = 'lib'
    config.target_shared_library_suffix = ".a"
    config.target_sdk_name = "wasi"
    config.target_runtime = "native"
    config.target_not_crash = "not"
    config.target_clang_resource_dir_opt = f"-resource-dir {test_resource_dir}/../../../wasi-sysroot/wasm32-wasip1"

    config.target_swift_autolink_extract = inferSwiftBinary("swift-autolink-extract")

    config.target_build_swift = ' '.join([
        config.swiftc,
        '-target', config.variant_triple,
        '-sdk', config.variant_sdk,
        '-toolchain-stdlib-rpath', config.resource_dir_opt,
        mcp_opt, config.swift_test_options,
        config.swift_driver_test_options, swift_execution_tests_extra_flags])
    config.target_codesign = "echo"
    config.target_build_swift_dylib = SubstituteCaptures(
        f"{escape_for_substitute_captures(config.target_build_swift)}"
        r" -parse-as-library -emit-library -static -o '\1'"
    )
    config.target_add_rpath = ''
    config.target_swift_frontend = ' '.join([
        config.swift_frontend,
        '-target', config.variant_triple,
	'-sdk', config.variant_sdk,
        config.resource_dir_opt, mcp_opt,
        config.swift_test_options, config.swift_frontend_test_options])
    subst_target_swift_frontend_mock_sdk = config.target_swift_frontend
    subst_target_swift_frontend_mock_sdk_after = ""
    config.target_run = os.path.join(config.swift_utils, 'wasm-run.py')
    config.target_env_prefix = 'WASM_RUN_CHILD_'

    if 'interpret' in lit_config.params:
        use_interpreter_for_simple_runs()
    config.target_sil_opt = (
        '%s -target %s %s %s %s' %
        (config.sil_opt, config.variant_triple, config.resource_dir_opt, mcp_opt, config.sil_test_options))
    subst_target_sil_opt_mock_sdk = config.target_sil_opt
    subst_target_sil_opt_mock_sdk_after = ""
    config.target_swift_symbolgraph_extract = ' '.join([
        config.swift_symbolgraph_extract,
        '-target', config.variant_triple,
        mcp_opt])
    config.target_swift_synthesize_interface = ' '.join([
        config.swift_synthesize_interface,
        '-target', config.variant_triple,
        mcp_opt])
    config.target_swift_ide_test = (
        '%s -target %s %s %s %s %s' %
        (config.swift_ide_test, config.variant_triple, config.resource_dir_opt,
         mcp_opt, ccp_opt, config.swift_ide_test_test_options))
    subst_target_swift_ide_test_mock_sdk = config.target_swift_ide_test
    subst_target_swift_ide_test_mock_sdk_after = ""
    config.target_swiftc_driver = (
        "%s -target %s -toolchain-stdlib-rpath %s %s" %
        (config.swiftc, config.variant_triple, config.resource_dir_opt, mcp_opt))
    config.target_stdlib_swiftc_driver = config.target_swiftc_driver
    config.target_swift_modulewrap = (
        '%s -modulewrap -target %s' %
        (config.swiftc, config.variant_triple))
    config.target_swift_emit_pcm = (
        '%s -emit-pcm -target %s' %
        (config.swiftc, config.variant_triple))
    config.target_clang = (
        "%s -target %s %s -fobjc-runtime=ios-5.0 --sysroot %s" %
        (config.clang, config.variant_triple, clang_mcp_opt, config.variant_sdk))
    config.target_ld = (
        "%s -L%r" %
        (config.wasm_ld, make_path(test_resource_dir, config.target_sdk_name)))

    # The Swift interpreter is not available when targeting WebAssembly/WASI.
    config.available_features.discard('swift_interpreter')

elif config.external_embedded_platform:
    lit_config.note("Testing embedded platform " + config.variant_triple)

    config.target_object_format = "elf"
    config.target_sdk_name = "embedded"
    config.target_runtime = "native"
    config.target_shared_library_prefix = 'lib'
    config.target_shared_library_suffix = ".so"
    config.target_library_path_var = "LD_LIBRARY_PATH"

    config.target_swift_autolink_extract = inferSwiftBinary("swift-autolink-extract")

    embedded_test_support = os.path.join(config.swift_utils, 'embedded-test-support/embedded-test-support.py')
    PATH = config.environment['PATH']

    device = config.external_embedded_device
    embedded_swift_flags = subprocess.check_output([embedded_test_support, "--device", device, "print-swift-flags"], env=config.environment).rstrip().decode('utf-8')
    embedded_swift_frontend_flags = subprocess.check_output([embedded_test_support, "--device", device, "print-swift-frontend-flags"], env=config.environment).rstrip().decode('utf-8')
    embedded_clang_flags = subprocess.check_output([embedded_test_support, "--device", device, "print-c-flags"], env=config.environment).rstrip().decode('utf-8')

    config.target_build_swift = ' '.join([
        config.swiftc,
        '-target', config.variant_triple,
        embedded_swift_flags,
        mcp_opt, config.swift_test_options,
        config.swift_driver_test_options, swift_execution_tests_extra_flags])
    config.target_codesign = "echo"
    config.target_build_swift_dylib = SubstituteCaptures(
        f"{escape_for_substitute_captures(config.target_build_swift)}"
        r" -parse-as-library -emit-library -static -o '\1'"
    )
    config.target_add_rpath = ''
    config.target_swift_frontend = ' '.join([
        config.swift_frontend,
        '-target', config.variant_triple, embedded_swift_frontend_flags,
        config.resource_dir_opt, mcp_opt,
        config.swift_test_options, config.swift_frontend_test_options])
    subst_target_swift_frontend_mock_sdk = config.target_swift_frontend
    subst_target_swift_frontend_mock_sdk_after = ""
    config.target_run = embedded_test_support + ' --device %s run --elf-file ' % device
    config.target_env_prefix = ''

    config.target_sil_opt = (
        '%s -target %s %s %s %s' %
        (config.sil_opt, config.variant_triple, config.resource_dir_opt, mcp_opt, config.sil_test_options))
    subst_target_sil_opt_mock_sdk = config.target_sil_opt
    subst_target_sil_opt_mock_sdk_after = ""
    config.target_swift_symbolgraph_extract = ' '.join([
        config.swift_symbolgraph_extract,
        '-target', config.variant_triple,
        mcp_opt])
    config.target_swift_synthesize_interface = ' '.join([
        config.swift_synthesize_interface,
        '-target', config.variant_triple,
        mcp_opt])
    config.target_swift_ide_test = (
        '%s -target %s %s %s %s %s' %
        (config.swift_ide_test, config.variant_triple, config.resource_dir_opt,
         mcp_opt, ccp_opt, config.swift_ide_test_test_options))
    subst_target_swift_ide_test_mock_sdk = config.target_swift_ide_test
    subst_target_swift_ide_test_mock_sdk_after = ""
    config.target_swiftc_driver = (
        "%s -target %s -toolchain-stdlib-rpath %s %s" %
        (config.swiftc, config.variant_triple, config.resource_dir_opt, mcp_opt))
    config.target_stdlib_swiftc_driver = config.target_swiftc_driver
    config.target_swift_modulewrap = (
        '%s -modulewrap -target %s' %
        (config.swiftc, config.variant_triple))
    config.target_swift_emit_pcm = (
        '%s -emit-pcm -target %s' %
        (config.swiftc, config.variant_triple))
    config.target_clang = (
        "%s -target %s %s %s" %
        (config.clang, config.variant_triple, embedded_clang_flags, clang_mcp_opt))
    config.target_ld = (
        "%s -L%r" %
        (config.lld, make_path(test_resource_dir, config.target_sdk_name)))

    config.available_features.discard('swift_interpreter')

    config.excludes += ['Unit']

    if 'SWIFT_USE_OLD_DRIVER' in config.environment: del config.environment['SWIFT_USE_OLD_DRIVER']
    if 'SWIFT_AVOID_WARNING_USING_OLD_DRIVER' in config.environment: del config.environment['SWIFT_AVOID_WARNING_USING_OLD_DRIVER']

else:
    lit_config.fatal("Don't know how to define target_run and "
                     "target_build_swift for platform " + config.variant_triple)

config.swift_api_digester = (
    '%s -target %s' % (config.swift_api_digester, config.variant_triple))
config.substitutions.append(('%api-digester', config.swift_api_digester))

config.substitutions.append(('%cache-tool', config.swift_cache_tool))

# Enable typo-correction for testing purposes.
config.target_swift_frontend += " -typo-correction-limit 10 "
subst_target_swift_frontend_mock_sdk += " -typo-correction-limit 10 "

config.substitutions.append(('%module-target-triple',
                             target_specific_module_triple))
config.substitutions.append(('%module-target-future', target_future))

# Add 'target-sdk-name' as the name for platform-specific directories
config.substitutions.append(('%target-sdk-name', config.target_sdk_name))

# Also add 'target-arch' so we can locate some things inside the build tree
config.substitutions.append(('%target-arch', target_arch))

# Add 'stdlib_dir' as the path to the stdlib resource directory
stdlib_dir = os.path.join(config.swift_lib_dir, "swift")
if run_os == 'maccatalyst':
    stdlib_dir = os.path.join(stdlib_dir, run_os)
else:
    stdlib_dir = os.path.join(stdlib_dir, config.target_sdk_name)
config.substitutions.append(('%stdlib_dir', stdlib_dir))

# Add 'stdlib_module' as the path to the stdlib .swiftmodule file
stdlib_module = os.path.join(stdlib_dir, "Swift.swiftmodule",
                             target_specific_module_triple + ".swiftmodule")
config.substitutions.append(('%stdlib_module', stdlib_module))
config.substitutions.append(('%/stdlib_module',
                             '/'.join(os.path.normpath(stdlib_module).split(os.sep))))

# Add 'ononesupport_module' as the path to the SwiftOnoneSupport .swiftmodule file
ononesupport_module = os.path.join(stdlib_dir, "SwiftOnoneSupport.swiftmodule",
                                   target_specific_module_triple + ".swiftmodule")
config.substitutions.append(('%ononesupport_module', ononesupport_module))
config.substitutions.append(('%/ononesupport_module',
                             '/'.join(os.path.normpath(ononesupport_module).split(os.sep))))

# Add 'concurrency_module' as the path to the _Concurrency .swiftmodule file
concurrency_module = os.path.join(stdlib_dir, "_Concurrency.swiftmodule",
                                   target_specific_module_triple + ".swiftmodule")
config.substitutions.append(('%concurrency_module', concurrency_module))
config.substitutions.append(('%/concurrency_module',
                             '/'.join(os.path.normpath(concurrency_module).split(os.sep))))

# Add 'runtime_module' as the path to the Runtime .swiftmodule file
runtime_module = os.path.join(stdlib_dir, "Runtime.swiftmodule",
                                   target_specific_module_triple + ".swiftmodule")
config.substitutions.append(('%runtime_module', runtime_module))
config.substitutions.append(('%/runtime_module',
                             '/'.join(os.path.normpath(runtime_module).split(os.sep))))

# Add 'distributed_module' as the path to the Distributed .swiftmodule file
distributed_module = os.path.join(stdlib_dir, "Distributed.swiftmodule",
                                   target_specific_module_triple + ".swiftmodule")
config.substitutions.append(('%distributed_module', distributed_module))
config.substitutions.append(('%/distributed_module',
                             '/'.join(os.path.normpath(distributed_module).split(os.sep))))

# Add 'string_processing_module' as the path to the _StringProcessing .swiftmodule file
string_processing_module = os.path.join(stdlib_dir, "_StringProcessing.swiftmodule",
                                   target_specific_module_triple + ".swiftmodule")
config.substitutions.append(('%string_processing_module', string_processing_module))
config.substitutions.append(('%/string_processing_module',
                             '/'.join(os.path.normpath(string_processing_module).split(os.sep))))

back_deployment_runtime = lit_config.params.get('back_deployment_runtime', None)
if back_deployment_runtime is not None:
    config.available_features.add('back_deployment_runtime')

concurrency_back_deploy_path = ''
if run_vendor == 'apple':
    if 'back_deploy_concurrency' in lit_config.params:
        config.available_features.add('back_deploy_concurrency')
        concurrency_back_deploy_path = os.path.join(os.path.dirname(swift_obj_root), os.path.basename(swift_obj_root).replace("swift-", "backdeployconcurrency-"), 'lib', 'swift-5.5', xcrun_sdk_name)

backtracer_path = make_path(config.swift_libexec_dir, 'swift',
                            config.target_sdk_name, 'swift-backtrace')
config.substitutions.append(('%backtracer', backtracer_path))

def os_stdlib_paths():
    if run_vendor == 'apple':
        if run_os == 'maccatalyst':
            return ["/System/iOSSupport/usr/lib/swift", "/usr/lib/swift"]
        else:
            return ["/usr/lib/swift"]
    else:
        lit_config.fatal("Unsupported platform for os_stdlib_paths")

# This returns a shell variable assignment of the form <LIBRARY_PATH>=<VALUE>
# where <LIBRARY_PATH> is whatever environment variable we need to set to
# override dynamic library locations. (Usually DYLD_LIBRARY_PATH or
# LD_LIBRARY_PATH, sometimes prefixed by a special annotation to tunnel the
# setting through a helper tool.)
#
# The return value is designed to be passed to `/usr/bin/env` when executing a
# binary on the test target.
#
# The single parameter is an array of directory paths that hold the libraries.
def construct_library_path_env(dirs):
    return "{0}{1}='{2}' ".format(
        config.target_env_prefix,
        config.target_library_path_var,
        os.path.pathsep.join(dirs))

def configure_remote_run():
    if 'remote_run_tmpdir' not in lit_config.params:
        lit_config.fatal("'remote_run_host' provided, but no "
                         "'remote_run_tmpdir'")

    remote_run_host = lit_config.params['remote_run_host']
    remote_tmp_dir = lit_config.params['remote_run_tmpdir']
    remote_lib_dir = os.path.join(remote_tmp_dir, 'stdlib')
    remote_run_lib_path = [remote_lib_dir]
    if 'use_os_stdlib' in lit_config.params:
        config.available_features.add('use_os_stdlib')
        remote_run_lib_path = os_stdlib_paths() + [remote_lib_dir]
        lit_config.note('Remote testing with the standard libraries in the OS')
    elif 'back_deployment_runtime' in lit_config.params:
        lit_config.note('Remote testing with back deployment libraries')
    else:
        lit_config.note('Remote testing with the just-built libraries')

    lit_config.note(
        'Remote library load path: {0}'.format(os.path.pathsep.join(remote_run_lib_path)))

    remote_run_extra_args_param = lit_config.params.get('remote_run_extra_args')
    remote_run_extra_args = shlex.split(remote_run_extra_args_param or '')
    if 'remote_run_identity' in lit_config.params:
        remote_run_identity = lit_config.params['remote_run_identity']
        remote_run_extra_args += ['-i', remote_run_identity]

    if 'remote_run_skip_upload_stdlib' not in lit_config.params:
        lit_config.note(
            "Uploading resources to {0} on {1}".format(remote_lib_dir,
                                                       remote_run_host))

        def upload_files(files, input_prefix, remote_input_prefix):
            subprocess.check_call(
                [
                    os.path.join(config.swift_utils, 'remote-run'),
                    '--remote-dir', remote_tmp_dir,
                    '--input-prefix', input_prefix,
                    '--remote-input-prefix', remote_input_prefix
                ] + remote_run_extra_args + [
                    remote_run_host,
                    '--',
                    'true' # A dummy command that ignores its arguments.
                ] + files)

        def upload_dylibs(dylib_dir):
            glob_pattern = os.path.join(dylib_dir,
                                        '*' + config.target_shared_library_suffix)
            libs = glob.glob(glob_pattern)
            upload_files(libs, dylib_dir, 'stdlib/')

        upload_dylibs(os.path.join(test_resource_dir, config.target_sdk_name))
        # FIXME: This could be more principled.
        upload_dylibs(os.path.join(test_resource_dir, "clang", "lib", "darwin"))
        upload_dylibs(os.path.join(test_resource_dir, "clang", "lib", "linux"))
        # Only copy when we have use_os_stdlib, otherwise we want to rely on the just-build concurrency
        if concurrency_back_deploy_path and 'use_os_stdlib' in lit_config.params:
            upload_dylibs(concurrency_back_deploy_path)

        # FIXME: Uploading specific files in bin/ is not very scalable.
        local_swift_reflection_test = lit.util.which(
            swift_reflection_test_name, config.environment['PATH'])
        upload_files([local_swift_reflection_test],
                     os.path.dirname(local_swift_reflection_test),
                     'bin/')

        print("Contents of {0} on {1} after upload:".format(
            remote_lib_dir, remote_run_host))
        subprocess.check_call(
            [
                os.path.join(config.swift_utils, 'remote-run'),
                '--remote-dir', remote_tmp_dir,
            ] + remote_run_extra_args + [
                remote_run_host,
                '--',
                'ls', '-l', remote_lib_dir
            ])

    config.target_env_prefix = 'REMOTE_RUN_CHILD_'
    config.target_run = (
        "/usr/bin/env " +
        construct_library_path_env(remote_run_lib_path) +
        "'{0}'/remote-run ".format(config.swift_utils) +
        "--input-prefix '{0}' ".format(config.swift_src_root) +
        "--output-prefix %t " +
        "--remote-dir '{0}'%t ".format(remote_tmp_dir) +
        "{0} ".format(' '.join(remote_run_extra_args)) +
        "{0}".format(remote_run_host))
    config.target_swift_reflection_test = os.path.join(
        remote_tmp_dir, 'bin', swift_reflection_test_name)
    config.available_features.add('remote_run')
    # Interpreter runs require local execution.
    config.available_features.discard('swift_interpreter')


config.substitutions.append(("%target-sdk-name", config.target_sdk_name))

simulator_sdks = [
    'iphonesimulator',
    'watchsimulator',
    'appletvsimulator'
]
if config.target_sdk_name in simulator_sdks:
    config.substitutions.append(('%target-is-simulator', 'true'))
else:
    config.substitutions.append(('%target-is-simulator', 'false'))

config.compiler_rt_darwin_platform = {
    'iphoneos': 'ios',
    'appletvos': 'tvos',
    'watchos': 'watchos',
    'xros': 'xros',
    'iphonesimulator': 'iossim',
    'watchsimulator': 'watchossim',
    'appletvsimulator': 'tvossim',
    'xrsimulator': 'xrossim',
    'macosx': 'osx'
}.get(config.target_sdk_name, run_os)

def find_compiler_rt_libs():
    base = make_path(test_clang_resource_dir, 'lib')
    libs = {}

    # First check to see if this is 'clang/lib/darwin', it has its own custom filename pattern.
    path = make_path(base, 'darwin')
    if os.path.exists(path):
        for lib in os.listdir(path):
            # Include any libraries with the platform name.
            match = re.match(r'libclang_rt\.(?:(\w+)_)?' + config.compiler_rt_darwin_platform, lib)
            if not match:
                continue
            component = match[1]
            # An empty component corresponds to the 'builtins' library.
            if not component:
                component = 'builtins'
            libs[component] = lib

        return (path, libs)

    # Next check for the old scheme 'clang/lib/<os-name>', ignoring
    # any target environment which is currently part of 'run_os'.
    path = make_path(base, run_os.split('-')[0])

    # Check if the Android environment needs to be in the name.
    env = ''
    if run_os.startswith('linux-android'):
        env = '-android'
    if os.path.exists(path):
        # We should then have the architecture in the name.
        for lib in os.listdir(path):
            match = re.match(r'(?:lib)?clang_rt\.(\w+)-' + run_cpu + env, lib)
            if match:
                libs[match[1]] = lib

        return (path, libs)

    # Finally, check the new scheme 'clang/lib/<target>'
    path = make_path(base, config.variant_triple)
    if os.path.exists(path):
        # We can include all the libraries here that match the base pattern.
        for lib in os.listdir(path):
            match = re.match(r'(?:lib)?clang_rt\.(\w+)\.', lib)
            if match:
                libs[match[1]] = lib

        return (path, libs)

    lit_config.warning("Couldn't find clang_rt directory")
    return (None, {})

(compiler_rt_path, compiler_rt_libs) = find_compiler_rt_libs()
if compiler_rt_path:
    lit_config.note("Using clang_rt directory: " + compiler_rt_path)
    if compiler_rt_libs:
        lit_config.note("Found clang_rt libs: {}".format(compiler_rt_libs))
    else:
        lit_config.warning("Couldn't find any clang_rt libs for %s" % config.variant_triple)

def check_runtime_libs(features_to_check):
    for (libname, feature) in features_to_check.items():
        if libname in compiler_rt_libs:
            config.available_features.add(feature)

runtime_libs = {
    'profile': 'profile_runtime',
    'asan': 'asan_runtime',
    'ubsan': 'ubsan_runtime',
    'scudo': 'scudo_runtime',
    'safestack': 'safestack_runtime',
    'fuzzer': 'fuzzer_runtime',
    'builtins': 'c_runtime'
}

if run_ptrsize == '64' and 'libdispatch' in config.available_features:
    runtime_libs['tsan'] = 'tsan_runtime'

check_runtime_libs(runtime_libs)

config.substitutions.append(('%target-objc-interop', run_objc_interop))


def find_rsync():
    for path in os.getenv("PATH").split(":"):
        rsync_path = os.path.join(path, "rsync")
        if os.path.isfile(rsync_path):
            return rsync_path


if find_rsync():
    config.available_features.add("rsync")

subst_target_repl_run_simple_swift = ""
if 'swift_repl' in config.available_features:
    subst_target_repl_run_simple_swift = (
        "%s -repl %s < %%s 2>&1" %
        (config.target_swift_frontend, sdk_overlay_link_path))

config.target_parse_verify_swift = (
    '%s -typecheck -verify -disable-objc-attr-requires-foundation-module %%s'
    % (config.target_swift_frontend, ))

config.target_sil_func_extractor = (
    '%s -target %s %s'
    % (config.sil_func_extractor, config.variant_triple, mcp_opt))

config.target_sil_llvm_gen = (
    '%s -target %s %s'
    % (config.sil_llvm_gen, config.variant_triple, mcp_opt))

config.target_sil_nm = (
    '%s -target %s %s'
    % (config.sil_nm, config.variant_triple, mcp_opt))

rth_flags = ''
if swift_execution_tests_extra_flags:
    rth_flags = swift_execution_tests_extra_flags + ' -wmo'

relative_platform_module_dir_prefix = ''
if platform.system() != 'Darwin':
    relative_platform_module_dir_prefix = os.path.join(config.target_sdk_name, run_cpu)
    if platform.system() == 'OpenBSD':
      relative_platform_module_dir_prefix = os.path.join(config.target_sdk_name, target_arch)
platform_module_dir = make_path(test_resource_dir, config.target_sdk_name)

platform_dylib_dir = platform_module_dir
if run_os == 'maccatalyst' and config.darwin_maccatalyst_build_flavor == "ios-like":
    # When using the ios-macabi triple, look for module files
    # in the 'maccatalyst' compiler resource directory.
    platform_module_dir = make_path(test_resource_dir, 'maccatalyst')

lit_config.note('Using platform module dir: ' + platform_module_dir)
if test_sdk_overlay_dir:
    platform_sdk_overlay_dir = test_sdk_overlay_dir
else:
    platform_sdk_overlay_dir = platform_module_dir

# If static stdlib is present, enable static stdlib tests
static_stdlib_path = make_path(config.swift_lib_dir, "swift_static", config.target_sdk_name)
static_libswiftCore_path = make_path(static_stdlib_path, "libswiftCore.a")
if os.path.exists(static_libswiftCore_path):
    config.available_features.add("static_stdlib")
    config.substitutions.append(('%target-static-stdlib-path', static_stdlib_path))
    lit_config.note('using static stdlib path: %s' % static_stdlib_path)

# Determine whether the concurrency runtime is available.
if 'concurrency' in config.available_features:
    if 'use_os_stdlib' not in lit_config.params:
        config.available_features.add('concurrency_runtime')
    elif run_vendor == 'apple':
        # OS version in which concurrency was introduced
        CONCURRENCY_OS_VERSION = {
            'macosx': '12',
	    'ios': '15',
	    'maccatalyst': '15',
	    'tvos': '15',
	    'watchos': '8'
	}
        concurrency_os_version = CONCURRENCY_OS_VERSION.get(run_os, '')

	# OS version to which concurrency can back-deploy
        CONCURRENCY_BACK_DEPLOY_VERSION = {
	    'macosx': '10.15',
	    'ios': '13',
	    'maccatalyst': '13',
	    'tvos': '13',
	    'watchos': '6'
	}
        concurrency_back_deploy_version = CONCURRENCY_BACK_DEPLOY_VERSION.get(run_os, '')

        if run_vers >= concurrency_os_version:
            config.available_features.add('concurrency_runtime')
        elif 'back_deploy_concurrency' in config.available_features and run_vers >= concurrency_back_deploy_version:
            config.available_features.add('concurrency_runtime')
        elif 'back_deploy_concurrency' in config.available_features:
            print('Disabled concurrency runtime tests because run version',
                  run_vers, "< back deploy version",
                  concurrency_back_deploy_version)
        else:
            print('Disable concurrency runtime tests because run version',
                  run_vers, 'is too old and back-deployment is not enabled')
    else:
        config.available_features.add('concurrency_runtime')

# Set up testing with the standard libraries coming from either the OS, the back
# deployment runtime or the just-built libraries. By default, we run tests with
# the just-built libraries.
target_stdlib_path = [platform_dylib_dir]
if run_os == 'maccatalyst':
    # Under macCatalyst we need to have the unzippered twin dylib dir come before
    # the zippered/macosx dylib dir so that unzippered twins are picked upload_dylibs
    # before the macOS variant.
    target_stdlib_path = [platform_module_dir, platform_dylib_dir]

if run_vendor != 'apple':
    libdispatch_path = getattr(config, 'libdispatch_artifact_dir', None)
    if libdispatch_path is not None:
       target_stdlib_path.append(libdispatch_path)

if 'remote_run_host' in lit_config.params:
    configure_remote_run()
elif not kIsWindows and not kIsWASI:
    if 'use_os_stdlib' in lit_config.params:
        config.available_features.add('use_os_stdlib')

        target_stdlib_path = [concurrency_back_deploy_path] + os_stdlib_paths() + target_stdlib_path

        lit_config.note('Testing with the standard libraries in the OS')
    elif 'back_deployment_runtime' in lit_config.params:
        lit_config.note('Testing with back deployment runtime libraries')
    else:
        lit_config.note('Testing with the just-built libraries')

    lit_config.note('Library load path: {0}'.format(os.path.pathsep.join(target_stdlib_path)))
    env_path = "/usr/bin/env "
    # Android doesn't have /usr/bin/
    if kIsAndroid:
      env_path = "/bin/env "
    config.target_run = (
        env_path +
        construct_library_path_env(target_stdlib_path) +
        config.target_run)

# When running with the JIT on Darwin, force the usage of the just built stdlib
# when running the frontend. This is because we currently JIT in process
# resulting in weirdness around swift-frontend wanting to link against the host
# stdlib and the exec swift code wanting to link against the target stdlib. For
# now, we work around this by just saying in that case we will force
# swift-frontend to use the just built runtime so we are consistent. The only
# potential problem is that a bug in the just built runtime may now cause these
# tests to fail.
subst_target_jit_prefix = ""
if platform.system() == 'Darwin' and config.target_run:
   subst_target_jit_prefix = config.target_run

subst_target_jit_run = ""
if 'swift_interpreter' in config.available_features:
    subst_target_jit_run = (
        "%s %s -interpret %s" %
        (subst_target_jit_prefix,
         config.target_swift_frontend, sdk_overlay_link_path))

if not getattr(config, 'target_run_simple_swift', None):
    config.target_run_simple_swift_parameterized = SubstituteCaptures(
        r"%%empty-directory(%%t) && "
        r"%s %s %%s \1 -o %%t/a.out -module-name main  && "
        r"%s %%t/a.out && "
        r"%s %%t/a.out"
        % (escape_for_substitute_captures(config.target_build_swift),
           escape_for_substitute_captures(mcp_opt),
           escape_for_substitute_captures(config.target_codesign),
           escape_for_substitute_captures(config.target_run))
    )
    config.target_fail_simple_swift_parameterized = SubstituteCaptures(
        r"%%empty-directory(%%t) && "
        r"%s %s %%s \1 -o %%t/a.out -module-name main  && "
        r"%s %%t/a.out && "
        r"{ ! %s %%t/a.out; }" #
        % (escape_for_substitute_captures(config.target_build_swift),
           escape_for_substitute_captures(mcp_opt),
           escape_for_substitute_captures(config.target_codesign),
           escape_for_substitute_captures(config.target_run))
    )
    config.target_run_simple_swiftgyb_parameterized = SubstituteCaptures(
        r"%%empty-directory(%%t) && "
        r"%%gyb %%s -o %%t/main.swift && "
        r"%%line-directive %%t/main.swift -- "
        r"%s %s %%t/main.swift \1 -o %%t/a.out -module-name main  && "
        r"%s %%t/a.out && "
        r"%%line-directive %%t/main.swift -- "
        r"%s %%t/a.out"
        % (escape_for_substitute_captures(config.target_build_swift),
          escape_for_substitute_captures(mcp_opt),
          escape_for_substitute_captures(config.target_codesign),
          escape_for_substitute_captures(config.target_run))
    )
    config.target_run_stdlib_swift_parameterized = SubstituteCaptures(
        r"%%empty-directory(%%t) && "
        r"%s %s %%s \1 -o %%t/a.out -module-name main "
        r"    -Xfrontend -disable-access-control && "
        r"%s %%t/a.out && "
        r"%s %%t/a.out"
        % (escape_for_substitute_captures(config.target_build_swift),
           escape_for_substitute_captures(mcp_opt),
           escape_for_substitute_captures(config.target_codesign),
           escape_for_substitute_captures(config.target_run))
    )

    config.target_run_simple_swift = (
        '%%empty-directory(%%t) && '
        '%s %s %%s -o %%t/a.out -module-name main  && '
        '%s %%t/a.out && '
        '%s %%t/a.out'
        % (config.target_build_swift, mcp_opt, config.target_codesign, config.target_run))
    config.target_run_stdlib_swift = (
        '%%empty-directory(%%t) && '
        '%s %s %%s -o %%t/a.out -module-name main '
        '-Xfrontend -disable-access-control  && '
        '%s %%t/a.out && '
        '%s %%t/a.out'
        % (config.target_build_swift, mcp_opt, config.target_codesign, config.target_run))
    config.target_run_simple_swiftgyb = (
        '%%empty-directory(%%t) && '
        '%%gyb %%s -o %%t/main.swift && '
        '%%line-directive %%t/main.swift -- '
        '%s %s %%t/main.swift -o %%t/a.out -module-name main  && '
        '%s %%t/a.out && '
        '%%line-directive %%t/main.swift -- '
        '%s %%t/a.out'
        % (config.target_build_swift, mcp_opt, config.target_codesign, config.target_run))
    config.target_run_stdlib_swiftgyb = (
        '%%empty-directory(%%t) && '
        '%%gyb %%s -o %%t/main.swift && '
        '%%line-directive %%t/main.swift -- '
        '%s %s %%t/main.swift -o %%t/a.out -module-name main '
        '-Xfrontend -disable-access-control  && '
        '%s %%t/a.out && '
        '%%line-directive %%t/main.swift -- '
        '%s %%t/a.out'
        % (config.target_build_swift, mcp_opt, config.target_codesign, config.target_run))

# FIXME: why can we not use %rth and have that be expanded out?
config.target_resilience_test = (
     '%s %s --target-build-swift "%s" --target-run "%s" --t %%t --S %%S '
     '--s %%s --lib-prefix "%s" --lib-suffix "%s" --target-codesign "%s" '
     '--additional-compile-flags "%s" --triple "%s"'
     % (shell_quote(sys.executable), config.rth, config.target_build_swift,
        config.target_run, config.target_shared_library_prefix,
        config.target_shared_library_suffix, config.target_codesign,
        rth_flags, config.variant_triple))

# FIXME: Get symbol diffing working with binutils nm as well. The flags are slightly
# different.
if platform.system() != 'Darwin' or swift_test_mode == 'optimize_none_with_implicit_dynamic':
    config.target_resilience_test = ('%s --no-symbol-diff' %
                                     config.target_resilience_test)

#
# When changing substitutions, update docs/Testing.md.
#

if config.target_sdk_libcxx_path != '':
    config.substitutions.append(('%cxx-stdlib-include', '-nostdinc++ -isystem "%s"' % config.target_sdk_libcxx_path))
else:
    config.substitutions.append(('%cxx-stdlib-include', ''))

extraCheckWarningFlags = (
  # Turn on all warnings and promote them to errors
  '-Weverything -Werror '
  # Don't warn about unused macros in our clang header.
  '-Wno-unused-macros '
  # Don't warn about module imports used at #includes.
  '-Wno-incomplete-module -Wno-auto-import '
  # Don't warn about any variadic macros we might have.
  '-Wno-variadic-macros '
  # Don't warn about any C++98 compatibility issues.
  '-Wno-c++98-compat-pedantic '
  # Don't warn about poison system directories in the Linux system paths.
  '-Wno-poison-system-directories '
  # For -fmodules-cache-path, when modules are off.
  '-Wno-unused-command-line-argument '
  # Don't warn about nullability specifiers in C/C++ code.
  '-Wno-nullability-extension ')

# Verifies that a C++ file can be compiled without warnings except for some exceptions.
config.substitutions.insert(0, ('%check-c-header-in-clang',
  '%clang -fsyntax-only -x c-header ' + extraCheckWarningFlags +
  ' --sysroot %r ' % config.variant_sdk +
  '-target %r ' % config.variant_triple +
  # Use standard header/framework search paths.
  '-F %%clang-importer-sdk-path/frameworks '
  '-I %%clang-include-dir '
  '-isysroot %r/Inputs/clang-importer-sdk' % config.test_source_root) )

# Verifies that a C++ file can be compiled without warnings except for some exceptions.
config.substitutions.insert(0, ('%check-cxx-header-in-clang',
  '%clangxx -fsyntax-only -x c++-header ' + extraCheckWarningFlags +
  ' --sysroot %r ' % config.variant_sdk +
  '-target %r ' % config.variant_triple +
  # Use standard header/framework search paths.
  '-F %%clang-importer-sdk-path/frameworks '
  '-I %%clang-include-dir %%cxx-stdlib-include '
  '-isysroot %r/Inputs/clang-importer-sdk' % config.test_source_root) )

# Different OS's require different prefixes for the environment variables to be
# propagated to the calling contexts.
# In order to make tests OS-agnostic, names of environment variables should be
# prefixed with `%env-`, which is then expanded to the appropriate prefix.
config.substitutions.append(('%env-', config.target_env_prefix))

config.substitutions.append(('%target-clangxx', '%s -std=c++11' % config.target_clang))
config.substitutions.append(('%target-swiftxx-frontend', '%s -cxx-interoperability-mode=default' % config.target_swift_frontend))

config.substitutions.append(('%target-runtime', config.target_runtime))

config.substitutions.append(('%target-rtti-opt', config.target_rtti_opt))
config.substitutions.append(('%target-cxx-lib', config.target_cxx_lib))
config.substitutions.append(('%target-pic-opt', config.target_pic_opt))
config.substitutions.append(('%target-msvc-runtime-opt',
                             config.target_msvc_runtime_opt))

config.substitutions.append(('%target-swift-emit-module-interfaces\(([^)]+),\w*([^)]+)\)',
                             SubstituteCaptures(r'%target-swift-emit-module-interface(\1) -emit-private-module-interface-path \2')))
config.substitutions.append(('%target-swift-emit-module-interface\(([^)]+)\)',
                             SubstituteCaptures(r'%target-swift-frontend -swift-version 5 -enable-library-evolution -parse-as-library -typecheck -emit-module-interface-path \1')))

config.substitutions.append(('%target-swift-typecheck-module-from-interface\(([^)]+)\)',
                             SubstituteCaptures(r'%target-swift-frontend -swift-version 5 -enable-library-evolution -typecheck-module-from-interface \1')))

config.substitutions.append(('%target-typecheck-verify-swift', config.target_parse_verify_swift))

config.substitutions.append(('%target-swift-emit-silgen\(mock-sdk:([^)]+)\)',
                             SubstituteCaptures(r'%target-swift-frontend(mock-sdk:\1) -emit-silgen')))
config.substitutions.append(('%target-swift-emit-silgen', '%target-swift-frontend -emit-silgen'))
config.substitutions.append(('%target-swift-emit-sil\(mock-sdk:([^)]+)\)',
                             SubstituteCaptures(r'%target-swift-frontend(mock-sdk:\1) -emit-sil')))
config.substitutions.append(('%target-swift-emit-sil', '%target-swift-frontend -emit-sil'))
config.substitutions.append(('%target-swift-emit-ir\(mock-sdk:([^)]+)\)',
                             SubstituteCaptures(r'%target-swift-frontend(mock-sdk:\1) -emit-ir')))
config.substitutions.append(('%target-swift-emit-ir', '%target-swift-frontend -emit-ir'))
config.substitutions.append(('%target-swift-frontend\(mock-sdk:([^)]+)\)',
                             SubstituteCaptures(r'%s \1 %s' % (
                                 escape_for_substitute_captures(subst_target_swift_frontend_mock_sdk),
                                 escape_for_substitute_captures(subst_target_swift_frontend_mock_sdk_after)))))
config.substitutions.append(('%target-swift-frontend', config.target_swift_frontend))


config.substitutions.append(('%target-run-simple-swiftgyb\(([^)]+)\)',
                            config.target_run_simple_swiftgyb_parameterized))
config.substitutions.append(('%target-run-simple-swiftgyb', config.target_run_simple_swiftgyb))
config.substitutions.append(('%target-run-simple-swift\(([^)]+)\)',
                            config.target_run_simple_swift_parameterized))
config.substitutions.append(('%target-fail-simple-swift\(([^)]+)\)',
                            config.target_fail_simple_swift_parameterized))
config.substitutions.append(('%target-run-stdlib-swift\(([^)]+)\)',
                            config.target_run_stdlib_swift_parameterized))

config.substitutions.append(('%target-run-simple-swift', config.target_run_simple_swift))
config.substitutions.append(('%target-run-stdlib-swiftgyb', config.target_run_stdlib_swiftgyb))
config.substitutions.append(('%target-run-stdlib-swift', config.target_run_stdlib_swift))
config.substitutions.append(('%target-repl-run-simple-swift', subst_target_repl_run_simple_swift))
config.substitutions.append(('%target-run', config.target_run))
config.substitutions.append(('%target-jit-run', subst_target_jit_run))
config.substitutions.append(('%target-build-swift-dylib\(([^)]+)\)', config.target_build_swift_dylib))
config.substitutions.append(('%target-codesign', config.target_codesign))
config.substitutions.append(('%target-build-swift', config.target_build_swift))
config.substitutions.append(('%target-clang', config.target_clang))
config.substitutions.append(('%target-ld', config.target_ld))
if hasattr(config, 'target_cc_options'):
    config.substitutions.append(('%target-cc-options', config.target_cc_options))
else:
    config.substitutions.append(('%target-cc-options', ''))

# Build an -fsanitize= argument (used by some tests)
if config.sanitizers:
    config.substitutions.append(('%target-sanitizer-opt',
                                 '-fsanitize=' + ','.join(config.sanitizers)))
else:
    config.substitutions.append(('%target-sanitizer-opt', ''))

# Option to disable chained fixups on Darwin targets.
if platform.system() == 'Darwin':
    config.substitutions.append(('%no-fixup-chains',
                                 '-Xlinker -no_fixup_chains'))
else:
    config.substitutions.append(('%no-fixup-chains', ''))

# WORKAROUND(rdar://53507844): On some macOS versions, we see flaky failures in
# tests which create a hard link to an executable and immediately invoke it.
# Work around this by always copying on Darwin.
if platform.system() == 'Darwin':
  config.substitutions.append(
      (r'%hardlink-or-copy\(from: *(.*), *to: *(.*)\)',
       SubstituteCaptures(r'cp \1 \2')))
else:
  config.substitutions.append(
      (r'%hardlink-or-copy\(from: *(.*), *to: *(.*)\)',
       SubstituteCaptures(r'ln \1 \2 || cp \1 \2')))

config.substitutions.append(('%utils', config.swift_utils))
config.substitutions.append(('%line-directive', '%s %s' % (shell_quote(sys.executable), config.line_directive)))
config.substitutions.append(('%gyb', '%s %s' % (shell_quote(sys.executable), config.gyb)))
config.substitutions.append(('%round-trip-syntax-test',
                             '%s %s' % (shell_quote(sys.executable),
                                        config.round_trip_syntax_test)))
config.substitutions.append(('%rth', '%s %s' % (shell_quote(sys.executable), config.rth)))
config.substitutions.append(('%scale-test',
                             '{} {} --swiftc-binary={} --tmpdir=%t --exclude-timers'.format(
                                 shell_quote(sys.executable), config.scale_test,
                                 config.swiftc)))
config.substitutions.append(('%abi-symbol-checker', '%s %s' % (shell_quote(sys.executable), config.abi_symbol_checker)))
config.substitutions.append(('%target-sil-opt\(mock-sdk:([^)]+)\)',
                             SubstituteCaptures(r'%s \1 %s' % (
                                 escape_for_substitute_captures(subst_target_sil_opt_mock_sdk),
                                 escape_for_substitute_captures(subst_target_sil_opt_mock_sdk_after)))))
# NOTE: This needs to be appended after the mock-sdk expansion to ensure that we
# first expand the mock-sdk when lit is processing.
config.substitutions.append(('%target-sil-opt', config.target_sil_opt))

config.substitutions.append(('%target-sil-func-extractor', config.target_sil_func_extractor))
config.substitutions.append(('%target-sil-llvm-gen', config.target_sil_llvm_gen))
config.substitutions.append(('%target-sil-nm', config.target_sil_nm))

config.substitutions.append(('%batch-code-completion', '%empty-directory(%t/batch-code-completion) && %target-swift-ide-test -batch-code-completion -source-filename %s -filecheck %raw-FileCheck -completion-output-dir %t/batch-code-completion'))

config.substitutions.append(('%target-swift-ide-test\(mock-sdk:([^)]+)\)',
                             SubstituteCaptures(r'%s \1 %s %s' % (
                                 escape_for_substitute_captures(subst_target_swift_ide_test_mock_sdk),
                                 escape_for_substitute_captures(subst_target_swift_ide_test_mock_sdk_after),
                                 escape_for_substitute_captures(config.swift_test_options)))))
config.substitutions.append(('%target-swift-ide-test',
                             "%s %s %s" % (config.target_swift_ide_test,
                                           config.swift_test_options,
                                           config.clang_system_overlay_opt)))

config.substitutions.append(('%target-swift-symbolgraph-extract', config.target_swift_symbolgraph_extract))
config.substitutions.append(('%target-swift-synthesize-interface', config.target_swift_synthesize_interface))

config.substitutions.append(('%empty-directory\(([^)]+)\)',
                             SubstituteCaptures(r'rm -rf "\1" && mkdir -p "\1"')))

if not hasattr(config, 'target_swift_reflection_test'):
    config.target_swift_reflection_test = inferSwiftBinary(swift_reflection_test_name)

config.substitutions.append(('%target-swift-reflection-test', config.target_swift_reflection_test))

config.substitutions.append(('%target-swift-reflection-dump', '{} {} {}'.format(config.swift_reflection_dump, '-arch', run_cpu)))
config.substitutions.append(('%target-swiftc_driver', config.target_swiftc_driver))
config.substitutions.append(('%target-stdlib-swiftc_driver', config.target_stdlib_swiftc_driver))

config.substitutions.append(('%target-swift-remoteast-test-with-sdk',
                             '%s %s -sdk %r' %
                             (subst_target_jit_prefix,
                              config.swift_remoteast_test, config.variant_sdk)))
config.substitutions.append(('%target-swift-remoteast-test',
                             '%s %s' % (subst_target_jit_prefix,
                                        config.swift_remoteast_test)))

if hasattr(config, 'target_swift_autolink_extract'):
    config.available_features.add('autolink-extract')
    config.substitutions.append(('%target-swift-autolink-extract',
                                 config.target_swift_autolink_extract))

config.substitutions.append(('%target-swift-modulewrap',
                             config.target_swift_modulewrap))
config.substitutions.append(('%target-swift-emit-pcm',
                             config.target_swift_emit_pcm))

config.substitutions.insert(0, ('%platform-module-dir', platform_module_dir))
config.substitutions.insert(0, ('%relative-platform-module-dir-prefix', relative_platform_module_dir_prefix))
config.substitutions.insert(0, ('%platform-sdk-overlay-dir', platform_sdk_overlay_dir))
config.substitutions.insert(0, ('%platform-dylib-dir', platform_dylib_dir))
config.substitutions.insert(0, ('%test-resource-dir', test_resource_dir))

if run_vendor == 'apple':
    extra_frameworks_search_path = '-F %r' % extra_frameworks_dir
else:
    extra_frameworks_search_path = ''
    extra_platform_search_paths = ''
config.substitutions.append(('%xcode-extra-frameworks-search-path', extra_frameworks_search_path))
config.substitutions.append(('%xcode-extra-platform-search-paths', extra_platform_search_paths))

config.substitutions.append(('%target-swiftmodule-name', target_specific_module_triple + '.swiftmodule'))
config.substitutions.append(('%target-swiftdoc-name', target_specific_module_triple + '.swiftdoc'))
config.substitutions.append(('%target-swiftsourceinfo-name', target_specific_module_triple + '.swiftsourceinfo'))
config.substitutions.append(('%target-swiftinterface-name', target_specific_module_triple + '.swiftinterface'))
config.substitutions.append(('%target-private-swiftinterface-name', target_specific_module_triple + '.private.swiftinterface'))
config.substitutions.append(('%target-package-swiftinterface-name', target_specific_module_triple + '.package.swiftinterface'))

config.substitutions.append(('%target-object-format', config.target_object_format))
config.substitutions.append(('%{target-shared-library-prefix}', config.target_shared_library_prefix))
config.substitutions.append(('%{target-shared-library-suffix}', config.target_shared_library_suffix))
config.substitutions.insert(0, ('%target-library-name\(([^)]+)\)',
                                SubstituteCaptures(r'%s\1%s' % (
                                    escape_for_substitute_captures(config.target_shared_library_prefix),
                                    escape_for_substitute_captures(config.target_shared_library_suffix)))))
config.substitutions.insert(0, ('%target-static-library-name\(([^)]+)\)',
                                SubstituteCaptures(r'%s\1%s' % (
                                    escape_for_substitute_captures(config.target_static_library_prefix),
                                    escape_for_substitute_captures(config.target_static_library_suffix)))))
config.substitutions.append(('%target-rpath\(([^)]+)\)', config.target_add_rpath))

config.substitutions.append(('%target-resilience-test', config.target_resilience_test))

config.substitutions.append(('%llvm-profdata', config.llvm_profdata))
config.substitutions.append(('%llvm-cov', config.llvm_cov))
config.substitutions.append(('%hmaptool', os.path.join(config.llvm_src_root, '..', 'clang', 'utils', 'hmaptool', 'hmaptool')))
config.substitutions.append(('%target-not-crash', config.target_not_crash))
config.substitutions.insert(0, ('%target-clang-resource-dir-opt', config.target_clang_resource_dir_opt))

# Set up the host library environment.
if hasattr(config, 'target_library_path_var'):
  host_library_env = (
          "/usr/bin/env " +
          construct_library_path_env([make_path(config.swift_lib_dir, 'swift', 'host')]))
else:
  host_library_env = ""

config.substitutions.append(('%host-library-env', host_library_env))

if hasattr(config, 'otool_classic'):
    config.substitutions.append(('%otool-classic', config.otool_classic))

if hasattr(config, 'target_link_sdk_2020_version'):
    config.substitutions.append(('%target-link-sdk-2020-version',
                                 config.target_link_sdk_2020_version))
if hasattr(config, 'target_link_sdk_2021_version'):
    config.substitutions.append(('%target-link-sdk-2021-version',
                                 config.target_link_sdk_2021_version))
if hasattr(config, 'target_link_sdk_future_version'):
    config.substitutions.append(('%target-link-sdk-future-version',
                                 config.target_link_sdk_future_version))

run_filecheck = '%s %s --allow-unused-prefixes --sanitize BUILD_DIR=%s --sanitize SOURCE_DIR=%s --ignore-runtime-warnings --use-filecheck %s %s %s' % (
        shell_quote(sys.executable),
        shell_quote(config.PathSanitizingFileCheck),
        # LLVM Lit performs realpath with the config path, so all paths are relative
        # to the real path. cmake_binary_dir and swift_src_root come from CMake, which
        # might not do real path. Because we have to match what Lit uses against what
        # we provide we use realpath here. Because PathSanitizingFileCheck only
        # understands sanitize patterns with forward slashes, and realpath normalizes
        # the slashes, we have to replace them back to forward slashes.
        shell_quote(lit.util.abs_path_preserve_drive(config.cmake_binary_dir).replace("\\", "/")),
        shell_quote(lit.util.abs_path_preserve_drive(config.swift_src_root).replace("\\", "/")),
        shell_quote(config.filecheck),
        '--color' if config.color_output else '',
        '--enable-windows-compatibility' if kIsWindows else '')

config.substitutions.append(('%FileCheck', run_filecheck))
config.substitutions.append(('%raw-FileCheck', shell_quote(config.filecheck)))
config.substitutions.append(('%import-libdispatch', getattr(config, 'import_libdispatch', '')))
# WARNING: the order of components in a substitution name has to be different from the previous one, as lit does
# a pure string substitution without understanding that these components are grouped together. That is, the following
# subsitution name can't be `%import-libdispatch-static`, otherwise the first two components will be substituted with
# the value of `%import-libdispatch` substitution with `-static` string appended to it.
config.substitutions.append(('%import-static-libdispatch', getattr(config, 'import_libdispatch_static', '')))

# Disable COW soundness checks in the swift runtime by default.
# (But it's required to set this environment variable to something)
config.environment['SWIFT_DEBUG_ENABLE_COW_CHECKS'] = 'false'

# Add this to the command which runs an executable to enable COW checks in the swift runtime.
config.substitutions.append(('%enable-cow-checking', config.target_env_prefix + 'SWIFT_DEBUG_ENABLE_COW_CHECKS=true;'))

# We add an expansion to ensure that migrator tests can search for the api diff
# data dir from the host compiler toolchain instead of the resource dir of the
# stdlib. Since we are using the host compiler, we would not have built any
# tools meaning that we would not have generated the -api-diff-data-dir.
#
# In the case where we are not building against the host compiler, this just
# expands to the empty string.
api_diff_data_dir_flag = ''
if hasattr(config, 'testing_against_host_compiler'):
   migrator_dir = os.path.join(os.path.dirname(config.swiftc),
                               os.pardir, 'lib', 'swift', 'migrator')
   api_diff_data_dir_flag = ' -api-diff-data-dir {} '.format(migrator_dir)
config.substitutions.append(('%api_diff_data_dir', api_diff_data_dir_flag))

if config.lldb_build_root != "":
    lldb_python_path = get_lldb_python_path(config.lldb_build_root)
    lldb_python_interpreter = get_lldb_python_interpreter(config.lldb_build_root)
    if lldb_python_path == None:
        lit_config.warning("""
        Specified lldb_build_root, but could not find lldb in that build root
        """)
    elif lldb_python_interpreter == None:
        lit_config.warning("""
        Specified lldb_build_root, but could not find lldb-python in that build root
        """)
    else:
        config.available_features.add('lldb')
        config.substitutions.append(('%lldb-python-path', lldb_python_path))
        config.substitutions.append(('%{lldb-python}', 'PYTHONPATH=%s %s' % (lldb_python_path, lldb_python_interpreter)))

# Disable randomized hash seeding by default. Tests need to manually opt in to
# random seeds by unsetting the SWIFT_DETERMINISTIC_HASHING environment
# variable.
config.environment[config.target_env_prefix + 'SWIFT_DETERMINISTIC_HASHING'] = '1'

# Enable malloc scribble during tests by default.
config.environment[config.target_env_prefix + 'SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE'] = 'YES'

# Run lsb_release on the target to be tested and return the results.
def linux_get_lsb_release():
    lsb_release_path = '/usr/bin/lsb_release'
    if os.path.isfile(lsb_release_path) and os.access(lsb_release_path, os.X_OK):
        distributor = lit.util.executeCommand([lsb_release_path, '-is'])[0].rstrip()
        release = lit.util.executeCommand([lsb_release_path, '-rs'])[0].rstrip()
        return (distributor, release)
    return ('', '')

def linux_get_os_release():
    try:
        os_release_path = '/etc/os-release'
        os_release_file = open(os_release_path)
    except FileNotFoundError:
        return '', ''
    os_id = ''
    os_release = ''
    for line in os_release_file:
        line = line.rstrip()
        if not line or line.startswith('#'):
            continue
        if line.startswith('ID='):
            os_id = line[len('ID='):].strip('\"')
        if line.startswith('VERSION_ID='):
            os_release = line[len('VERSION_ID='):].strip('\"')
    return os_id, os_release

if platform.system() == 'Linux':
    # Retrieve the Linux distro and version from `/etc/os-release`.
    (distributor, release) = linux_get_os_release()
    if distributor == '' or release == '':
        # If `/etc/os-release` does not provide full results, fallback to `lsb_release`.
        (distributor, release) = linux_get_lsb_release()
    if distributor != '' and release != '':
        config.available_features.add("LinuxDistribution=" + distributor + '-' + release)
        lit_config.note('Running tests on %s-%s' % (distributor, release))

# XDG_CACHE_HOME can be used to influence the position of the clang
# module cache for all those tests that do not set that explicitly
if 'XDG_CACHE_HOME' in os.environ:
  config.environment['XDG_CACHE_HOME'] = os.environ['XDG_CACHE_HOME']

# Copy environment variables specified in --param copy_env=..., overriding
# anything computed here. It's assumed that the person setting this knows what
# they're doing.
copy_env = lit_config.params.get('copy_env', None)
if copy_env is not None:
  for key in copy_env.split(':'):
    config.environment[key] = os.environ[key]

# On macOS reflection information is read through the dyld APIs
# On other platforms, this information is exported through extra
# entry points in the Swift runtime that are only available in debug builds.
# Windows currently does not support basic reflection support.
if 'objc_interop' in config.available_features or ('swift_stdlib_asserts' in config.available_features and not kIsWindows):
    config.available_features.add('reflection_test_support')

# num_extra_inhabitants on 64 bits differs between Mac and everywhere else.
# Add it, as a variable in order to substitute it in the tests
if platform.system() == 'Darwin':
    num_extra_inhabitants_64bit = 2147483647
else:
    num_extra_inhabitants_64bit = 4096
add_num_extra_inhabitants = "-D#num_extra_inhabitants_64bit={} ".format(num_extra_inhabitants_64bit)
config.substitutions.append(('%add_num_extra_inhabitants', add_num_extra_inhabitants))

if kIsWindows:
  config.substitutions.append( ('%diff', 'diff --strip-trailing-cr') )
  # Use instead of %t when the possible temporal path (and suffix) might end
  # up being longer than 260 characters in Windows machines.
  config.substitutions.append( ('%long-tmp', '\\\\?\\%t') )
else:
  config.substitutions.append( ('%diff', 'diff') )
  config.substitutions.append( ('%long-tmp', '%t') )

# Compute the size of the Swift class metadata header in words.
run_class_metadata_header_size = 2
if run_objc_interop == 'objc':
  run_class_metadata_header_size = 5
if run_ptrsize == '64':
  run_class_metadata_header_size = run_class_metadata_header_size + 5
else:
  run_class_metadata_header_size = run_class_metadata_header_size + 8

# A FileCheck that automatically supports a large variety of target
# conditionalization that's useful in IRGen.
IRGenFileCheck = '%s --check-prefix=CHECK --check-prefix=CHECK-%s --check-prefix=CHECK-%s --check-prefix=CHECK-%s --check-prefix=CHECK-%s --check-prefix=CHECK-%s --check-prefix=CHECK-%s -DINT=i%s -DPTR_SIZE=%s -D#CLASS_METADATA_HEADER=%s' % (
        run_filecheck,
        run_os,
        run_cpu,
        run_endian,
        run_ptrsize,
        run_ptrauth,
        run_objc_interop,
        run_ptrsize,
        run_ptrsize,
        run_class_metadata_header_size)
config.substitutions.append( ('%IRGenFileCheck', IRGenFileCheck) )

visual_studio_version = os.environ.get('VisualStudioVersion')
if kIsWindows and visual_studio_version:
  config.available_features.add('MSVC_VER=%s' % visual_studio_version)

lit_config.note("Available features: " + ", ".join(sorted(config.available_features)))
config.substitutions.append( ('%use_no_opaque_pointers', '-Xcc -Xclang -Xcc -no-opaque-pointers' ) )
