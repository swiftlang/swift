//===--- SIMDConcreteIntegers.swift.gyb -----------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2021 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: %empty-directory(%t)
// RUN: %gyb -DCMAKE_SIZEOF_VOID_P=%target-ptrsize %s -o %t/SIMDConcreteIntegers.swift
// RUN: %line-directive %t/SIMDConcreteIntegers.swift -- %target-build-swift %t/SIMDConcreteIntegers.swift -o %t/a.out
// RUN: %target-codesign %t/a.out
// RUN: %line-directive %t/SIMDConcreteIntegers.swift -- %target-run %t/a.out
// REQUIRES: executable_test
// UNSUPPORTED: freestanding

import StdlibUnittest

%{
from SwiftIntTypes import all_integer_types
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8
storagescalarCounts = [2,4,8,16,32,64]
vectorscalarCounts = storagescalarCounts + [3]
}%

func genericComparisons<T>(
  _ a: T, _ b: T
) -> (
  eq: SIMDMask<T.MaskStorage>,
  ne: SIMDMask<T.MaskStorage>,
  lt: SIMDMask<T.MaskStorage>,
  le: SIMDMask<T.MaskStorage>,
  gt: SIMDMask<T.MaskStorage>,
  ge: SIMDMask<T.MaskStorage>
) where T: SIMD, T.Scalar: Comparable {(
  eq: a .== b,
  ne: a .!= b,
  lt: a .<  b,
  le: a .<= b,
  gt: a .>  b,
  ge: a .>= b
)}

func genericArithmetic<T>(
  _ a: T, _ b: T
) -> (
  add: T, sub: T, mul: T
) where T: SIMD, T.Scalar: FixedWidthInteger {(
  add: a &+ b,
  sub: a &- b,
  mul: a &* b
)}

%for int in all_integer_types(word_bits):
% Scalar = int.stdlib_name
% for n in vectorscalarCounts:
%  Vector = "SIMD" + str(n) + "<" + Scalar + ">"
%  storageN = 4 if n == 3 else n
%  s = "s" if int.is_signed else "u"
%  Builtin = "Vec" + str(storageN) + "xInt" + str(int.bits)
var ${Scalar}x${n}_TestSuite = TestSuite("${Scalar}x${n}")

${Scalar}x${n}_TestSuite.test("comparisons") {
  let a = ${Vector}.random(in: ${Scalar}.min ... .max)
  expectTrue(all(a .== a))
  expectFalse(any(a .!= a))
  expectFalse(any(a .== a &+ ${Vector}(repeating: 1)))
  expectTrue(all(a .!= a &+ ${Vector}(repeating: 1)))
  
  let b = a.replacing(
    with: ${Vector}.random(in: ${Scalar}.min ... .max),
    where: .random()
  )
  let (eq,ne,lt,le,gt,ge) = genericComparisons(a, b)
  expectEqual(eq, a .== b)
  expectEqual(ne, a .!= b)
  expectEqual(lt, a .<  b)
  expectEqual(le, a .<= b)
  expectEqual(gt, a .>  b)
  expectEqual(ge, a .>= b)
}

${Scalar}x${n}_TestSuite.test("comparisons with scalar") {
  let s = ${Scalar}.random(in: ${Scalar}.min ... .max)
  let sVector = ${Vector}(repeating: s)

  expectTrue(all(s .== sVector))
  expectFalse(any(s .!= sVector))
  expectFalse(any(s .< sVector))
  expectTrue(all(s .<= sVector))
  expectFalse(any(s .> sVector))
  expectTrue(all(s .>= sVector))

  expectTrue(all(sVector .== s))
  expectFalse(any(sVector .!= s))
  expectFalse(any(sVector .< s))
  expectTrue(all(sVector .<= s))
  expectFalse(any(sVector .> s))
  expectTrue(all(sVector .>= s))

  let aVector = ${Vector}.random(in: ${Scalar}.min ... .max)
  let leftScalar = genericComparisons(sVector, aVector)
  expectEqual(leftScalar.eq, s .== aVector)
  expectEqual(leftScalar.ne, s .!= aVector)
  expectEqual(leftScalar.lt, s .<  aVector)
  expectEqual(leftScalar.le, s .<= aVector)
  expectEqual(leftScalar.gt, s .>  aVector)
  expectEqual(leftScalar.ge, s .>= aVector)

  let rightScalar = genericComparisons(aVector, sVector)
  expectEqual(rightScalar.eq, aVector .== s)
  expectEqual(rightScalar.ne, aVector .!= s)
  expectEqual(rightScalar.lt, aVector .<  s)
  expectEqual(rightScalar.le, aVector .<= s)
  expectEqual(rightScalar.gt, aVector .>  s)
  expectEqual(rightScalar.ge, aVector .>= s)
}

${Scalar}x${n}_TestSuite.test("arithmetic") {
  let a = ${Vector}.random(in: ${Scalar}.min ... .max)
  let b = ${Vector}.random(in: ${Scalar}.min ... .max)
  let (add,sub,mul) = genericArithmetic(a, b)
  expectEqual(add, a &+ b)
  expectEqual(sub, a &- b)
  expectEqual(mul, a &* b)

  var addA = a
  addA &+= b
  expectEqual(add, addA)

  var subA = a
  subA &-= b
  expectEqual(sub, subA)

  var mulA = a
  mulA &*= b
  expectEqual(mul, mulA)
}

${Scalar}x${n}_TestSuite.test("arithmetic with scalar") {
  let s = ${Scalar}.random(in: ${Scalar}.min ... .max)
  let sVector = ${Vector}(repeating: s)
  let aVector = ${Vector}.random(in: ${Scalar}.min ... .max)

  let leftScalar = genericArithmetic(sVector, aVector)
  expectEqual(leftScalar.add, s &+ aVector)
  expectEqual(leftScalar.sub, s &- aVector)
  expectEqual(leftScalar.mul, s &* aVector)

  let rightScalar = genericArithmetic(aVector, sVector)
  expectEqual(rightScalar.add, aVector &+ s)
  expectEqual(rightScalar.sub, aVector &- s)
  expectEqual(rightScalar.mul, aVector &* s)

  var addA = aVector
  addA &+= s
  expectEqual(rightScalar.add, addA)

  var subA = aVector
  subA &-= s
  expectEqual(rightScalar.sub, subA)

  var mulA = aVector
  mulA &*= s
  expectEqual(rightScalar.mul, mulA)
}

% end
%end

runAllTests()
