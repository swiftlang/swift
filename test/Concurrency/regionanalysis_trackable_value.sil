// RUN: %target-sil-opt -module-name infer --test-runner %s 2>&1 | %FileCheck %s

// REQUIRES: concurrency
// REQUIRES: asserts

// PLEASE READ THIS!
//
// This test is specifically meant to test how we look through underlying
// objects for region analysis.

sil_stage raw

import Swift
import Builtin
import _Concurrency

////////////////////////
// MARK: Declarations //
////////////////////////

class NonSendableKlass {
}

class SendableKlass : @unchecked Sendable {
}

struct Struct2 {
  let nsLet: NonSendableKlass
  let sLet: SendableKlass
  var nsVar: NonSendableKlass
  var sVar: SendableKlass
}

struct Struct {
  let nsLet: NonSendableKlass
  let sLet: SendableKlass
  var nsVar: NonSendableKlass
  var sVar: SendableKlass

  let struct2Let: Struct2
  var struct2Var: Struct2

  let sStruct: SendableStruct
}

struct SendableStruct : @unchecked Sendable {
  let nsLet: NonSendableKlass
}

class NonSendableKlassWithState {
  let sLet: Struct
  var sVar: Struct
  let recurseLet: NonSendableKlassWithState?
  var recurseVar: NonSendableKlassWithState?
}

actor Custom {}

enum MyEnum<T> {
    case none
    indirect case some(NonSendableKlass)
    case some2(T)
}

enum MyEnum2 {
    case none
    case sendable(SendableKlass)
    case nonsendable(NonSendableKlass)
}

enum SendableEnum : @unchecked Sendable {
    case none
    case value(NonSendableKlass)
}

struct TupleMixed {
  var tuple: (NonSendableKlass, SendableKlass)
}

struct TupleNonSendable {
  var tuple: (NonSendableKlass, NonSendableKlass)
}

struct TupleSendable : @unchecked Sendable {
  var tuple: (SendableKlass, SendableKlass)
}

struct TupleNestedMixed {
  var tuple: ((NonSendableKlass, SendableKlass), SendableKlass)
}

@MainActor
struct MainActorStruct : @unchecked Sendable {
  var ns: NonSendableKlass
  var s: SendableKlass
  var nested: Struct2
}

sil @transferNonSendableKlass : $@convention(thin) @async (@guaranteed NonSendableKlass) -> ()
sil @useNonSendableKlass : $@convention(thin) (@guaranteed NonSendableKlass) -> ()
sil @constructNonSendableKlass : $@convention(thin) () -> @owned NonSendableKlass
sil @constructStruct : $@convention(thin) () -> @owned Struct
sil @constructSendableStruct : $@convention(thin) () -> @owned SendableStruct

sil @transferIndirect : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()

/////////////////
// MARK: Tests //
/////////////////

// CHECK-LABEL: begin running test 1 of 1 on allocbox_direct_access: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var NonSendableKlass }
// CHECK: end running test 1 of 1 on allocbox_direct_access: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_direct_access : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructNonSendableKlass : $@convention(thin) () -> @owned NonSendableKlass
  %c = apply %f() : $@convention(thin) () -> @owned NonSendableKlass
  %a = alloc_box ${ var NonSendableKlass }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*NonSendableKlass

  debug_value [trace] %p

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_nonsendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %nsLet = struct_element_addr %p : $*Struct, #Struct.nsLet
  debug_value [trace] %nsLet

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_nonsendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %nsVar = struct_element_addr %p : $*Struct, #Struct.nsVar
  debug_value [trace] %nsVar

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = struct_element_addr %4 : $*Struct, #Struct.sLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_sendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %addr = struct_element_addr %p : $*Struct, #Struct.sLet
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = struct_element_addr %4 : $*Struct, #Struct.sVar
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_sendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %addr = struct_element_addr %p : $*Struct, #Struct.sVar
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_nonsendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %nsLet = struct_element_addr %s2 : $*Struct2, #Struct2.nsLet

  debug_value [trace] %nsLet

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_nonsendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %nsVar = struct_element_addr %s2 : $*Struct2, #Struct2.nsVar
  debug_value [trace] %nsVar

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %7 = struct_element_addr %6 : $*Struct2, #Struct2.sLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_sendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sLet
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %7 = struct_element_addr %6 : $*Struct2, #Struct2.sVar
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_sendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sVar
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_nonsendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %nsLet = struct_element_addr %s2 : $*Struct2, #Struct2.nsLet

  debug_value [trace] %nsLet

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_nonsendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %nsVar = struct_element_addr %s2 : $*Struct2, #Struct2.nsVar
  debug_value [trace] %nsVar

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %7 = struct_element_addr %6 : $*Struct2, #Struct2.sLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_sendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sLet
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %7 = struct_element_addr %6 : $*Struct2, #Struct2.sVar
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_sendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sVar
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_sendable_struct_field_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = struct_element_addr %4 : $*SendableStruct, #SendableStruct.nsLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var SendableStruct }
// CHECK: end running test 1 of 1 on allocbox_access_sendable_struct_field_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_sendable_struct_field_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructSendableStruct : $@convention(thin) () -> @owned SendableStruct
  %c = apply %f() : $@convention(thin) () -> @owned SendableStruct
  %a = alloc_box ${ var SendableStruct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p

  %s2 = struct_element_addr %p : $*SendableStruct, #SendableStruct.nsLet
  debug_value [trace] %s2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_sendable_struct_field_let_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %4 = struct_element_addr %2 : $*SendableStruct, #SendableStruct.nsLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $SendableStruct
// CHECK: end running test 1 of 1 on allocbox_access_sendable_struct_field_let_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_sendable_struct_field_let_2 : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructSendableStruct : $@convention(thin) () -> @owned SendableStruct
  %c = apply %f() : $@convention(thin) () -> @owned SendableStruct
  %a = alloc_stack $SendableStruct
  store %c to [init] %a

  %s2 = struct_element_addr %a : $*SendableStruct, #SendableStruct.nsLet
  debug_value [trace] %s2

  destroy_addr %a
  dealloc_stack %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on class_lookthrough_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = ref_element_addr %5 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
// CHECK: end running test 1 of 1 on class_lookthrough_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @class_lookthrough_test : $@convention(thin) (@owned NonSendableKlassWithState) -> () {
bb0(%0 : @owned $NonSendableKlassWithState):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %a = alloc_box ${ var NonSendableKlassWithState }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %0 to [init] %p : $*NonSendableKlassWithState

  %p2 = load_borrow %p
  %s = ref_element_addr %p2 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
  debug_value [trace] %s
  end_borrow %p2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// We model unchecked_enum_data as an assign, so we do not look through it. The
// result of this is that we consider it a separate value (even though we could
// cheat potentially).
//
// CHECK-LABEL: begin running test 1 of 1 on class_lookthrough_test_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:    Rep Value:   %6 = ref_element_addr %5 : $NonSendableKlassWithState, #NonSendableKlassWithState.recurseLet
// CHECK: end running test 1 of 1 on class_lookthrough_test_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @class_lookthrough_test_2 : $@convention(thin) (@owned NonSendableKlassWithState) -> () {
bb0(%0 : @owned $NonSendableKlassWithState):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %a = alloc_box ${ var NonSendableKlassWithState }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %0 to [init] %p : $*NonSendableKlassWithState

  %p2 = load_borrow %p
  %s = ref_element_addr %p2 : $NonSendableKlassWithState, #NonSendableKlassWithState.recurseLet
  %s2 = load_borrow %s
  %s3 = unchecked_enum_data %s2 : $Optional<NonSendableKlassWithState>, #Optional.some!enumelt
  debug_value [trace] %s3
  end_borrow %s2
  end_borrow %p2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// We always stop at ref_element_addr since it is a base of a value.
//
// CHECK-LABEL: begin running test 1 of 1 on class_lookthrough_test_3: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:   Rep Value:   %9 = ref_element_addr %8 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
// CHECK: end running test 1 of 1 on class_lookthrough_test_3: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @class_lookthrough_test_3 : $@convention(thin) (@owned NonSendableKlassWithState) -> () {
bb0(%0 : @owned $NonSendableKlassWithState):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %a = alloc_box ${ var NonSendableKlassWithState }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %0 to [init] %p : $*NonSendableKlassWithState

  %p2 = load_borrow %p
  %s = ref_element_addr %p2 : $NonSendableKlassWithState, #NonSendableKlassWithState.recurseLet
  %s2 = load_borrow %s
  %s3 = unchecked_enum_data %s2 : $Optional<NonSendableKlassWithState>, #Optional.some!enumelt
  %s4 = ref_element_addr %s3 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
  debug_value [trace] %s4
  end_borrow %s2
  end_borrow %p2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on actor_deinit_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = unchecked_ref_cast %0 : $Custom to $Builtin.NativeObject
// CHECK: end running test 1 of 1 on actor_deinit_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @actor_deinit_test : $@convention(thin) (@guaranteed Custom) -> @owned Builtin.NativeObject {
bb0(%0 : @guaranteed $Custom):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %2 = builtin "destroyDefaultActor"(%0) : $()
  %3 = unchecked_ref_cast %0 to $Builtin.NativeObject
  %4 = unchecked_ownership_conversion %3, @guaranteed to @owned
  debug_value [trace] %3
  return %4
}

// CHECK-LABEL: begin running test 1 of 1 on project_box_loadable_test_case: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: task-isolated].
// CHECK:    Rep Value: %0 = argument of bb0 : $*{ var NonSendableKlass }
// CHECK: end running test 1 of 1 on project_box_loadable_test_case: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @project_box_loadable_test_case : $@convention(thin) @async (@in { var NonSendableKlass }) -> () {
bb0(%0 : $*{ var NonSendableKlass }):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %1 = load [take] %0
  %2 = project_box %1, 0
  // function_ref transferIndirect
  %3 = function_ref @transferIndirect : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  %4 = apply [callee_isolation=nonisolated] [caller_isolation=global_actor] %3<NonSendableKlass>(%2) : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  debug_value [trace] %2
  destroy_value %1
  %6 = tuple ()
  return %6
}

// CHECK-LABEL: begin running test 1 of 1 on deep_value_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: task-isolated].
// CHECK:     Rep Value: %0 = argument of bb0 : $*{ var { var NonSendableKlass } }
// CHECK: end running test 1 of 1 on deep_value_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @deep_value_test : $@convention(thin) @async (@in_guaranteed { var { var NonSendableKlass }  }) -> () {
bb0(%0 : $*{ var { var NonSendableKlass } }):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %1 = load_borrow %0
  %2 = project_box %1, 0
  %3 = load_borrow %2
  %4 = project_box %3, 0
  // function_ref transferIndirect
  %func = function_ref @transferIndirect : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  apply [callee_isolation=nonisolated] [caller_isolation=global_actor] %func<NonSendableKlass>(%4) : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  debug_value [trace] %4
  end_borrow %3
  end_borrow %1
  %6 = tuple ()
  return %6
}

// CHECK-LABEL: begin running test 1 of 1 on deep_base_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %5 = struct_element_addr %4 : $*Struct2, #Struct2.sLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: yes][is_sendable: no][region_value_kind: task-isolated].
// CHECK:     Rep Value: %0 = argument of bb0 : $*{ var { var Struct2 } }
// CHECK: end running test 1 of 1 on deep_base_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @deep_base_test : $@convention(thin) @async (@in_guaranteed { var { var Struct2 }  }) -> () {
bb0(%0 : $*{ var { var Struct2 } }):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %1 = load_borrow %0
  %2 = project_box %1, 0
  %3 = load_borrow %2
  %4 = project_box %3, 0
  %5 = struct_element_addr %4 : $*Struct2, #Struct2.sLet
  // function_ref transferIndirect
  %func = function_ref @transferIndirect : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  apply [callee_isolation=nonisolated] [caller_isolation=global_actor] %func<SendableKlass>(%5) : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  debug_value [trace] %5
  end_borrow %3
  end_borrow %1
  %6 = tuple ()
  return %6
}

// CHECK-LABEL: begin running test 1 of 1 on alloc_stack_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %3 = struct_element_addr %1 : $*Struct2, #Struct2.sLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %1 = alloc_stack $Struct2
// CHECK: end running test 1 of 1 on alloc_stack_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @alloc_stack_test : $@convention(thin) @async (@owned Struct2) -> () {
bb0(%0 : @owned $Struct2):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %1 = alloc_stack $Struct2, let
  store %0 to [init] %1

  %5 = struct_element_addr %1 : $*Struct2, #Struct2.sLet
  %func = function_ref @transferIndirect : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  apply [callee_isolation=nonisolated] [caller_isolation=global_actor] %func<SendableKlass>(%5) : $@convention(thin) @async <τ_0_0> (@in_guaranteed τ_0_0) -> ()
  debug_value [trace] %5

  destroy_addr %1
  dealloc_stack %1
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on indirect_enum_load_take: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:   Rep Value:   %1 = alloc_stack $MyEnum<T>
// CHECK: end running test 1 of 1 on indirect_enum_load_take: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @indirect_enum_load_take : $@convention(thin) @async <T> (@in_guaranteed MyEnum<T>) -> () {
bb0(%0 : $*MyEnum<T>):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %1 = alloc_stack $MyEnum<T>
  copy_addr %0 to [init] %1
  switch_enum_addr %1, case #MyEnum.some!enumelt: bb1, default bb2

bb1:
  %2 = unchecked_take_enum_data_addr %1, #MyEnum.some!enumelt
  %3 = load [take] %2
  %4 = project_box %3, 0
  %5 = load_borrow %4
  %6 = copy_value %5
  debug_value [trace] %5
  %7 = move_value [var_decl] %6
  debug_value %5, let, name "x"
  destroy_value %7
  end_borrow %5
  destroy_value %3
  dealloc_stack %1
  br bb3

bb2:
  destroy_addr %1
  dealloc_stack %1
  br bb3

bb3:
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on alloc_stack_inline_array_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value: %2 = vector_base_addr %1
// CHECK: end running test 1 of 1 on alloc_stack_inline_array_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @alloc_stack_inline_array_sendable : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %0 = alloc_stack $InlineArray<1, UInt8>
  %1 = struct_element_addr %0: $*InlineArray<1, UInt8>, #InlineArray._storage
  %2 = vector_base_addr %1 : $*Builtin.FixedArray<1, UInt8>
  %3 = integer_literal $Builtin.Int8, 0
  %4 = struct $UInt8 (%3)
  store %4 to [trivial] %2
  %6 = load [trivial] %0
  dealloc_stack %0
  debug_value [trace] %2

  %7 = tuple ()
  return %7 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on alloc_stack_inline_array_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value: %1 = alloc_stack $InlineArray
// CHECK: end running test 1 of 1 on alloc_stack_inline_array_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @alloc_stack_inline_array_nonsendable : $@convention(thin) (@owned NonSendableKlass) -> () {
bb0(%arg : @owned $NonSendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %0 = alloc_stack $InlineArray<1, NonSendableKlass>
  %1 = struct_element_addr %0: $*InlineArray<1, NonSendableKlass>, #InlineArray._storage
  %2 = vector_base_addr %1 : $*Builtin.FixedArray<1, NonSendableKlass>
  store %arg to [init] %2
  %6 = load [take] %0
  destroy_value %6
  dealloc_stack %0
  debug_value [trace] %2

  %7 = tuple ()
  return %7 : $()
}

////////////////////////////////////////////////////////////////////////////////
// MARK: tuple_element_addr Tests - Testing projection through tuple elements //
////////////////////////////////////////////////////////////////////////////////

// Test: NonSendable tuple, extract NonSendable element
// Expected: Look through both (operand and result are both non-Sendable)
// CHECK-LABEL: begin running test 1 of 1 on tuple_nonsendable_extract_nonsendable_0: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $(NonSendableKlass, NonSendableKlass)
// CHECK: end running test 1 of 1 on tuple_nonsendable_extract_nonsendable_0: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_nonsendable_extract_nonsendable_0 : $@convention(thin) (@owned NonSendableKlass, @owned NonSendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $NonSendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %tuple_addr = alloc_stack $(NonSendableKlass, NonSendableKlass)
  %tuple_val = tuple (%0 : $NonSendableKlass, %1 : $NonSendableKlass)
  store %tuple_val to [init] %tuple_addr : $*(NonSendableKlass, NonSendableKlass)

  %elem = tuple_element_addr %tuple_addr : $*(NonSendableKlass, NonSendableKlass), 0
  debug_value [trace] %elem : $*NonSendableKlass

  destroy_addr %tuple_addr : $*(NonSendableKlass, NonSendableKlass)
  dealloc_stack %tuple_addr : $*(NonSendableKlass, NonSendableKlass)
  %r = tuple ()
  return %r : $()
}

// Test: NonSendable tuple, extract NonSendable element (index 1)
// Expected: Look through both
// CHECK-LABEL: begin running test 1 of 1 on tuple_nonsendable_extract_nonsendable_1: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $(NonSendableKlass, NonSendableKlass)
// CHECK: end running test 1 of 1 on tuple_nonsendable_extract_nonsendable_1: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_nonsendable_extract_nonsendable_1 : $@convention(thin) (@owned NonSendableKlass, @owned NonSendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $NonSendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %tuple_addr = alloc_stack $(NonSendableKlass, NonSendableKlass)
  %tuple_val = tuple (%0 : $NonSendableKlass, %1 : $NonSendableKlass)
  store %tuple_val to [init] %tuple_addr : $*(NonSendableKlass, NonSendableKlass)

  %elem = tuple_element_addr %tuple_addr : $*(NonSendableKlass, NonSendableKlass), 1
  debug_value [trace] %elem : $*NonSendableKlass

  destroy_addr %tuple_addr : $*(NonSendableKlass, NonSendableKlass)
  dealloc_stack %tuple_addr : $*(NonSendableKlass, NonSendableKlass)
  %r = tuple ()
  return %r : $()
}

// Test: Mixed tuple (NonSendable, Sendable), extract NonSendable element
// Expected: Look through both (both are non-Sendable)
// CHECK-LABEL: begin running test 1 of 1 on tuple_mixed_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $(NonSendableKlass, SendableKlass)
// CHECK: end running test 1 of 1 on tuple_mixed_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_mixed_extract_nonsendable : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %tuple_addr = alloc_stack $(NonSendableKlass, SendableKlass)
  %tuple_val = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  store %tuple_val to [init] %tuple_addr : $*(NonSendableKlass, SendableKlass)

  %elem = tuple_element_addr %tuple_addr : $*(NonSendableKlass, SendableKlass), 0
  debug_value [trace] %elem : $*NonSendableKlass

  destroy_addr %tuple_addr : $*(NonSendableKlass, SendableKlass)
  dealloc_stack %tuple_addr : $*(NonSendableKlass, SendableKlass)
  %r = tuple ()
  return %r : $()
}

// Test: Mixed tuple (NonSendable, Sendable), extract Sendable element
// Expected: Stop at projection (operand is non-Sendable, result is Sendable)
// CHECK-LABEL: begin running test 1 of 1 on tuple_mixed_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %5 = tuple_element_addr %2 : $*(NonSendableKlass, SendableKlass), 1
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $(NonSendableKlass, SendableKlass)
// CHECK: end running test 1 of 1 on tuple_mixed_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_mixed_extract_sendable : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %tuple_addr = alloc_stack $(NonSendableKlass, SendableKlass)
  %tuple_val = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  store %tuple_val to [init] %tuple_addr : $*(NonSendableKlass, SendableKlass)

  %elem = tuple_element_addr %tuple_addr : $*(NonSendableKlass, SendableKlass), 1
  debug_value [trace] %elem : $*SendableKlass

  destroy_addr %tuple_addr : $*(NonSendableKlass, SendableKlass)
  dealloc_stack %tuple_addr : $*(NonSendableKlass, SendableKlass)
  %r = tuple ()
  return %r : $()
}

// Test: Sendable tuple, extract Sendable element
// CHECK-LABEL: begin running test 1 of 1 on tuple_sendable_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %5 = tuple_element_addr %2 : $*(SendableKlass, SendableKlass), 0
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $(SendableKlass, SendableKlass)
// CHECK: end running test 1 of 1 on tuple_sendable_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_sendable_extract_sendable : $@convention(thin) (@owned SendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $SendableKlass, %1 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %tuple_addr = alloc_stack $(SendableKlass, SendableKlass)
  %tuple_val = tuple (%0 : $SendableKlass, %1 : $SendableKlass)
  store %tuple_val to [init] %tuple_addr : $*(SendableKlass, SendableKlass)

  %elem = tuple_element_addr %tuple_addr : $*(SendableKlass, SendableKlass), 0
  debug_value [trace] %elem : $*SendableKlass

  destroy_addr %tuple_addr : $*(SendableKlass, SendableKlass)
  dealloc_stack %tuple_addr : $*(SendableKlass, SendableKlass)
  %r = tuple ()
  return %r : $()
}

// Test: Nested tuple ((NonSendable, Sendable), Sendable), extract outer element 0
// Expected: Look through (both tuple types are non-Sendable)
// CHECK-LABEL: begin running test 1 of 1 on tuple_nested_extract_tuple: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %5 = alloc_stack $((NonSendableKlass, SendableKlass), SendableKlass)
// CHECK: end running test 1 of 1 on tuple_nested_extract_tuple: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_nested_extract_tuple : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass, %2 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %inner = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  %outer = tuple (%inner : $(NonSendableKlass, SendableKlass), %2 : $SendableKlass)
  %tuple_addr = alloc_stack $((NonSendableKlass, SendableKlass), SendableKlass)
  store %outer to [init] %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)

  %elem0 = tuple_element_addr %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass), 0
  debug_value [trace] %elem0 : $*(NonSendableKlass, SendableKlass)

  destroy_addr %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)
  dealloc_stack %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)
  %r = tuple ()
  return %r : $()
}

// Test: Nested tuple, extract through two levels to NonSendable
// Expected: Look through all levels
// CHECK-LABEL: begin running test 1 of 1 on tuple_nested_double_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %5 = alloc_stack $((NonSendableKlass, SendableKlass), SendableKlass)
// CHECK: end running test 1 of 1 on tuple_nested_double_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_nested_double_extract_nonsendable : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass, %2 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %inner = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  %outer = tuple (%inner : $(NonSendableKlass, SendableKlass), %2 : $SendableKlass)
  %tuple_addr = alloc_stack $((NonSendableKlass, SendableKlass), SendableKlass)
  store %outer to [init] %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)

  %elem0 = tuple_element_addr %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass), 0
  %elem0_0 = tuple_element_addr %elem0 : $*(NonSendableKlass, SendableKlass), 0
  debug_value [trace] %elem0_0 : $*NonSendableKlass

  destroy_addr %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)
  dealloc_stack %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)
  %r = tuple ()
  return %r : $()
}

// Test: Nested tuple, extract through two levels to Sendable
// Expected: Stop at second projection (inner tuple is non-Sendable, extracted Sendable)
// CHECK-LABEL: begin running test 1 of 1 on tuple_nested_double_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %8 = tuple_element_addr %7 : $*(NonSendableKlass, SendableKlass), 1
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %5 = alloc_stack $((NonSendableKlass, SendableKlass), SendableKlass)
// CHECK: end running test 1 of 1 on tuple_nested_double_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @tuple_nested_double_extract_sendable : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass, %2 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %inner = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  %outer = tuple (%inner : $(NonSendableKlass, SendableKlass), %2 : $SendableKlass)
  %tuple_addr = alloc_stack $((NonSendableKlass, SendableKlass), SendableKlass)
  store %outer to [init] %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)

  %elem0 = tuple_element_addr %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass), 0
  %elem0_1 = tuple_element_addr %elem0 : $*(NonSendableKlass, SendableKlass), 1
  debug_value [trace] %elem0_1 : $*SendableKlass

  destroy_addr %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)
  dealloc_stack %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass)
  %r = tuple ()
  return %r : $()
}

////////////////////////////////////////////////////////////////////////////
// MARK: unchecked_enum_data_addr Tests - Testing enum payload extraction //
////////////////////////////////////////////////////////////////////////////

// Test: NonSendable enum, extract NonSendable payload
// Expected: Look through (both non-Sendable)
// CHECK-LABEL: begin running test 1 of 1 on enum_nonsendable_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %1 = alloc_stack $MyEnum2
// CHECK: end running test 1 of 1 on enum_nonsendable_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @enum_nonsendable_extract_nonsendable : $@convention(thin) (@owned NonSendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %enum_addr = alloc_stack $MyEnum2
  %enum_val = enum $MyEnum2, #MyEnum2.nonsendable!enumelt, %0 : $NonSendableKlass
  store %enum_val to [init] %enum_addr : $*MyEnum2

  %payload = unchecked_take_enum_data_addr %enum_addr : $*MyEnum2, #MyEnum2.nonsendable!enumelt
  debug_value [trace] %payload : $*NonSendableKlass

  destroy_addr %payload : $*NonSendableKlass
  dealloc_stack %enum_addr : $*MyEnum2
  %r = tuple ()
  return %r : $()
}

// Test: NonSendable enum, extract Sendable payload
// Expected: Stop at projection (operand non-Sendable, result Sendable)
// CHECK-LABEL: begin running test 1 of 1 on enum_nonsendable_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %4 = unchecked_take_enum_data_addr %1 : $*MyEnum2, #MyEnum2.sendable!enumelt
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %1 = alloc_stack $MyEnum2
// CHECK: end running test 1 of 1 on enum_nonsendable_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @enum_nonsendable_extract_sendable : $@convention(thin) (@owned SendableKlass) -> () {
bb0(%0 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %enum_addr = alloc_stack $MyEnum2
  %enum_val = enum $MyEnum2, #MyEnum2.sendable!enumelt, %0 : $SendableKlass
  store %enum_val to [init] %enum_addr : $*MyEnum2

  %payload = unchecked_take_enum_data_addr %enum_addr : $*MyEnum2, #MyEnum2.sendable!enumelt
  debug_value [trace] %payload : $*SendableKlass

  destroy_addr %payload : $*SendableKlass
  dealloc_stack %enum_addr : $*MyEnum2
  %r = tuple ()
  return %r : $()
}

// Test: Sendable enum (wrapping NonSendable), extract NonSendable payload
// Expected: Stop at projection and mark as non-Sendable value (Sendable operand, non-Sendable result)
// CHECK-LABEL: begin running test 1 of 1 on enum_sendable_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %4 = unchecked_take_enum_data_addr %1 : $*SendableEnum, #SendableEnum.value!enumelt
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %1 = alloc_stack $SendableEnum
// CHECK: end running test 1 of 1 on enum_sendable_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @enum_sendable_extract_nonsendable : $@convention(thin) (@owned NonSendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %enum_addr = alloc_stack $SendableEnum
  %enum_val = enum $SendableEnum, #SendableEnum.value!enumelt, %0 : $NonSendableKlass
  store %enum_val to [init] %enum_addr : $*SendableEnum

  %payload = unchecked_take_enum_data_addr %enum_addr : $*SendableEnum, #SendableEnum.value!enumelt
  debug_value [trace] %payload : $*NonSendableKlass

  destroy_addr %payload : $*NonSendableKlass
  dealloc_stack %enum_addr : $*SendableEnum
  %r = tuple ()
  return %r : $()
}

///////////////////////////////////////////////////////////////////
// MARK: Combined struct_element_addr + tuple_element_addr Tests //
///////////////////////////////////////////////////////////////////

// Test: Struct with tuple field, extract tuple then NonSendable element
// Expected: Look through all (all non-Sendable)
// CHECK-LABEL: begin running test 1 of 1 on struct_tuple_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $TupleMixed
// CHECK: end running test 1 of 1 on struct_tuple_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @struct_tuple_extract_nonsendable : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %struct_addr = alloc_stack $TupleMixed
  %tuple_val = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  %struct_val = struct $TupleMixed (%tuple_val : $(NonSendableKlass, SendableKlass))
  store %struct_val to [init] %struct_addr : $*TupleMixed

  %tuple_addr = struct_element_addr %struct_addr : $*TupleMixed, #TupleMixed.tuple
  %elem = tuple_element_addr %tuple_addr : $*(NonSendableKlass, SendableKlass), 0
  debug_value [trace] %elem : $*NonSendableKlass

  destroy_addr %struct_addr : $*TupleMixed
  dealloc_stack %struct_addr : $*TupleMixed
  %r = tuple ()
  return %r : $()
}

// Test: Struct with tuple field, extract tuple then Sendable element
// Expected: Stop at tuple_element_addr (tuple is non-Sendable, element is Sendable)
// CHECK-LABEL: begin running test 1 of 1 on struct_tuple_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %7 = tuple_element_addr %6 : $*(NonSendableKlass, SendableKlass), 1
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_stack $TupleMixed
// CHECK: end running test 1 of 1 on struct_tuple_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @struct_tuple_extract_sendable : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %struct_addr = alloc_stack $TupleMixed
  %tuple_val = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  %struct_val = struct $TupleMixed (%tuple_val : $(NonSendableKlass, SendableKlass))
  store %struct_val to [init] %struct_addr : $*TupleMixed

  %tuple_addr = struct_element_addr %struct_addr : $*TupleMixed, #TupleMixed.tuple
  %elem = tuple_element_addr %tuple_addr : $*(NonSendableKlass, SendableKlass), 1
  debug_value [trace] %elem : $*SendableKlass

  destroy_addr %struct_addr : $*TupleMixed
  dealloc_stack %struct_addr : $*TupleMixed
  %r = tuple ()
  return %r : $()
}

////////////////////////////////////////////////////////////////////////////////////
// MARK: Deep Nesting Tests - Multiple levels of projections                     //
////////////////////////////////////////////////////////////////////////////////////

// Test: Struct -> Struct -> Struct, all NonSendable fields
// Expected: Look through all levels
// CHECK-LABEL: begin running test 1 of 1 on deep_struct_triple_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %1 = alloc_stack $Struct
// CHECK: end running test 1 of 1 on deep_struct_triple_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @deep_struct_triple_nonsendable : $@convention(thin) (@owned Struct) -> () {
bb0(%0 : @owned $Struct):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %struct_addr = alloc_stack $Struct
  store %0 to [init] %struct_addr : $*Struct

  %l1 = struct_element_addr %struct_addr : $*Struct, #Struct.struct2Let
  %l2 = struct_element_addr %l1 : $*Struct2, #Struct2.nsLet
  debug_value [trace] %l2 : $*NonSendableKlass

  destroy_addr %struct_addr : $*Struct
  dealloc_stack %struct_addr : $*Struct
  %r = tuple ()
  return %r : $()
}

// Test: Struct -> Struct -> Sendable field (deep projection ending in Sendable)
// Expected: Stop at first projection.
// CHECK-LABEL: begin running test 1 of 1 on deep_struct_triple_to_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %4 = struct_element_addr %3 : $*Struct2, #Struct2.sLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %1 = alloc_stack $Struct
// CHECK: end running test 1 of 1 on deep_struct_triple_to_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @deep_struct_triple_to_sendable : $@convention(thin) (@owned Struct) -> () {
bb0(%0 : @owned $Struct):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %struct_addr = alloc_stack $Struct
  store %0 to [init] %struct_addr : $*Struct

  %l1 = struct_element_addr %struct_addr : $*Struct, #Struct.struct2Let
  %l2 = struct_element_addr %l1 : $*Struct2, #Struct2.sLet
  debug_value [trace] %l2 : $*SendableKlass

  destroy_addr %struct_addr : $*Struct
  dealloc_stack %struct_addr : $*Struct
  %r = tuple ()
  return %r : $()
}

// Test: Struct -> Tuple -> Struct (mixed projections)
// Expected: Look through all (all non-Sendable)
// CHECK-LABEL: begin running test 1 of 1 on mixed_struct_tuple_struct_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = alloc_stack $TupleNestedMixed
// CHECK: end running test 1 of 1 on mixed_struct_tuple_struct_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @mixed_struct_tuple_struct_nonsendable : $@convention(thin) (@owned NonSendableKlass, @owned SendableKlass, @owned SendableKlass) -> () {
bb0(%0 : @owned $NonSendableKlass, %1 : @owned $SendableKlass, %2 : @owned $SendableKlass):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %inner = tuple (%0 : $NonSendableKlass, %1 : $SendableKlass)
  %outer = tuple (%inner : $(NonSendableKlass, SendableKlass), %2 : $SendableKlass)
  %struct_val = struct $TupleNestedMixed (%outer : $((NonSendableKlass, SendableKlass), SendableKlass))
  %struct_addr = alloc_stack $TupleNestedMixed
  store %struct_val to [init] %struct_addr : $*TupleNestedMixed

  %tuple_addr = struct_element_addr %struct_addr : $*TupleNestedMixed, #TupleNestedMixed.tuple
  %inner_tuple = tuple_element_addr %tuple_addr : $*((NonSendableKlass, SendableKlass), SendableKlass), 0
  %elem = tuple_element_addr %inner_tuple : $*(NonSendableKlass, SendableKlass), 0
  debug_value [trace] %elem : $*NonSendableKlass

  destroy_addr %struct_addr : $*TupleNestedMixed
  dealloc_stack %struct_addr : $*TupleNestedMixed
  %r = tuple ()
  return %r : $()
}

////////////////////////////////////
// MARK: MainActor Isolated Tests //
////////////////////////////////////

// Test: MainActor struct as parameter, extract NonSendable field
//
// Should have MainActor as a base and non sendable field should be main actor
// isolated.
//
// CHECK-LABEL: begin running test 1 of 1 on mainactor_struct_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: main actor-isolated].
// CHECK:     Rep Value:   %1 = struct_element_addr %0 : $*MainActorStruct, #MainActorStruct.ns
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value: %0 = argument of bb0 : $*MainActorStruct
// CHECK: end running test 1 of 1 on mainactor_struct_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @mainactor_struct_extract_nonsendable : $@convention(thin) @async (@in_guaranteed MainActorStruct) -> () {
bb0(%0 : $*MainActorStruct):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %field = struct_element_addr %0 : $*MainActorStruct, #MainActorStruct.ns
  debug_value [trace] %field : $*NonSendableKlass

  %r = tuple ()
  return %r : $()
}

// Test: MainActor struct as parameter, extract Sendable field
// Expected: Sendable field, should have base pointing to MainActor struct
// CHECK-LABEL: begin running test 1 of 1 on mainactor_struct_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %1 = struct_element_addr %0 : $*MainActorStruct, #MainActorStruct.s
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value: %0 = argument of bb0 : $*MainActorStruct
// CHECK: end running test 1 of 1 on mainactor_struct_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @mainactor_struct_extract_sendable : $@convention(thin) @async (@in_guaranteed MainActorStruct) -> () {
bb0(%0 : $*MainActorStruct):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %field = struct_element_addr %0 : $*MainActorStruct, #MainActorStruct.s
  debug_value [trace] %field : $*SendableKlass

  %r = tuple ()
  return %r : $()
}

// Test: MainActor struct, extract nested struct then NonSendable field
// Expected: We should stop at nested and mark that as main actor-isolated.
// CHECK-LABEL: begin running test 1 of 1 on mainactor_struct_nested_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: main actor-isolated].
// CHECK:     Rep Value:   %1 = struct_element_addr %0 : $*MainActorStruct, #MainActorStruct.nested
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value: %0 = argument of bb0 : $*MainActorStruct
// CHECK: end running test 1 of 1 on mainactor_struct_nested_extract_nonsendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @mainactor_struct_nested_extract_nonsendable : $@convention(thin) @async (@in_guaranteed MainActorStruct) -> () {
bb0(%0 : $*MainActorStruct):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %nested = struct_element_addr %0 : $*MainActorStruct, #MainActorStruct.nested
  %field = struct_element_addr %nested : $*Struct2, #Struct2.nsLet
  debug_value [trace] %field : $*NonSendableKlass

  %r = tuple ()
  return %r : $()
}

// Test: MainActor struct, extract nested struct then Sendable field
// CHECK-LABEL: begin running test 1 of 1 on mainactor_struct_nested_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: Value:
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = struct_element_addr %1 : $*Struct2, #Struct2.sLet
// CHECK: Base:
// CHECK: TrackableValue. State: TrackableValueState[id: 1][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value: %0 = argument of bb0 : $*MainActorStruct
// CHECK: end running test 1 of 1 on mainactor_struct_nested_extract_sendable: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @mainactor_struct_nested_extract_sendable : $@convention(thin) @async (@in_guaranteed MainActorStruct) -> () {
bb0(%0 : $*MainActorStruct):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %nested = struct_element_addr %0 : $*MainActorStruct, #MainActorStruct.nested
  %field = struct_element_addr %nested : $*Struct2, #Struct2.sLet
  debug_value [trace] %field : $*SendableKlass

  %r = tuple ()
  return %r : $()
}
