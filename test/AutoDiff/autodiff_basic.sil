// RUN: %target-sil-opt -differentiation -sil-print-all %s | %FileCheck %s

import Builtin
import Swift

sil_stage raw

sil hidden @foo_adj : $@convention(thin) (Float, Float, Float) -> Float {
bb0(%0 : $Float, %1 : $Float, %2 : $Float):
  return %2 : $Float
}

sil hidden [reverse_differentiable wrt 0 primal @foo adjoint @foo_adj] @foo : $@convention(thin) (Float) -> Float {
bb0(%0 : $Float):
  return %0 : $Float
}

sil hidden @bar : $@convention(thin) (Float) -> Float {
bb0(%0 : $Float):
  %1 = function_ref @foo : $@convention(thin) (Float) -> Float
  %2 = gradient [wrt 0] %1 : $@convention(thin) (Float) -> Float
  %3 = apply %2(%0) : $@convention(thin) (Float) -> Float
  return %3 : $Float
}

// CHECK-LABEL: sil hidden @bar : $@convention(thin) (Float) -> Float {
// CHECK: bb0
// CHECK:   %1 = function_ref @foo : $@convention(thin) (Float) -> Float
// CHECK:   %2 = function_ref @foo__grad_wrt_0 : $@convention(thin) (Float) -> Float
// CHECK:   %3 = apply %2(%0) : $@convention(thin) (Float) -> Float
// CHECK:   return %3 : $Float
// CHECK: }

// CHECK-LABEL:sil hidden @foo__grad_wrt_0_s_p : $@convention(thin) (Float, Float) -> (Float, Float) {
// CHECK: bb0
// CHECK:   %2 = function_ref @foo : $@convention(thin) (Float) -> Float
// CHECK:   %3 = apply %2(%0) : $@convention(thin) (Float) -> Float
// CHECK:   %4 = function_ref @foo_adj : $@convention(thin) (Float, Float, Float) -> Float
// CHECK:   %5 = apply %4(%0, %3, %1) : $@convention(thin) (Float, Float, Float) -> Float
// CHECK:   %6 = tuple (%3 : $Float, %5 : $Float)
// CHECK:   return %6 : $(Float, Float)
// CHECK: }

// CHECK-LABEL:sil hidden @foo__grad_wrt_0 : $@convention(thin) (Float) -> Float {
// CHECK: bb0
// CHECK:  %1 = alloc_stack $Float
// CHECK:  %2 = integer_literal $Builtin.Int2048, 1
// CHECK:  %3 = metatype $@thin Float.Type
// CHECK:  // function_ref Float.init(_builtinIntegerLiteral:)
// CHECK:  %4 = function_ref @$SSf22_builtinIntegerLiteralSfBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Float.Type) -> Float
// CHECK:  %5 = apply %4(%2, %3) : $@convention(method) (Builtin.Int2048, @thin Float.Type) -> Float
// CHECK:  %6 = metatype $@thick Float.Type
// CHECK:  %7 = alloc_stack $Float
// CHECK:  store %5 to [trivial] %7 : $*Float
// CHECK:  %9 = witness_method $Float, #Differentiable.init!allocator.1 : <Self where Self : Differentiable> (Self.Type) -> (Self.DifferentiationCurrency) -> Self : $@convention(witness_method: Differentiable) <τ_0_0 where τ_0_0 : Differentiable> (@in τ_0_0.DifferentiationCurrency, @thick τ_0_0.Type) -> @out τ_0_0
// CHECK:  %10 = apply %9<Float>(%1, %7, %6) : $@convention(witness_method: Differentiable) <τ_0_0 where τ_0_0 : Differentiable> (@in τ_0_0.DifferentiationCurrency, @thick τ_0_0.Type) -> @out τ_0_0
// CHECK:  dealloc_stack %7 : $*Float
// CHECK:  %12 = load [trivial] %1 : $*Float
// CHECK:  dealloc_stack %1 : $*Float
// CHECK:  // function_ref foo__grad_wrt_0_s_p
// CHECK:  %14 = function_ref @foo__grad_wrt_0_s_p : $@convention(thin) (Float, Float) -> (Float, Float)
// CHECK:  %15 = apply %14(%0, %12) : $@convention(thin) (Float, Float) -> (Float, Float)
// CHECK:  %16 = tuple_extract %15 : $(Float, Float), 1
// CHECK:  return %16 : $Float
// CHECK: }
