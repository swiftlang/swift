// RUN: rm -rf %t && mkdir %t
// RUN: %build-irgen-test-overlays
// RUN: %target-swift-frontend -sdk %S/Inputs -I %t %s -emit-ir | FileCheck %s

// REQUIRES: CPU=x86_64
// XFAIL: linux

import Builtin
import Swift
import gizmo

// CHECK: [[ROOTGENERIC:%C15generic_classes11RootGeneric]] = type <{ %swift.refcounted, %VSs5UInt8 }>

// -- offset of RootGeneric<T>.x
// CHECK: [[ROOTGENERIC_NAME:@.*]] = private unnamed_addr constant [32 x i8] c"C15generic_classes11RootGeneric\00"
// CHECK: [[ROOTGENERIC_FIELDS:@.*]] = private unnamed_addr constant [7 x i8] c"x\00y\00z\00\00"
// CHECK: @_TMnC15generic_classes11RootGeneric = constant { {{.*}} i32 } {
// --       0 = class
// CHECK:   i64 0,
// --       name
// CHECK:   i8* getelementptr inbounds ([32 x i8], [32 x i8]* [[ROOTGENERIC_NAME]], i64 0, i64 0),
// --       num fields
// CHECK:   i32 3,
// --       field offset vector offset
// CHECK:   i32 14,
// --       field names
// CHECK:   i8* getelementptr inbounds ([7 x i8], [7 x i8]* [[ROOTGENERIC_FIELDS]], i64 0, i64 0),
// --       generic metadata pattern
// CHECK:   @_TMPdC15generic_classes11RootGeneric
// --       generic parameter vector offset
// CHECK:   i32 9,
// --       generic parameter count, primary count, witness table counts
// CHECK:   i32 1, i32 1, i32 0
// CHECK: }
// CHECK: @_TMPdC15generic_classes11RootGeneric = global { {{.*}}* } } {
// --       template fill function
// CHECK:   %swift.type* (%swift.type_pattern*, i8**)* [[CREATE_ROOTGENERIC:@create_generic_metadata[0-9]*]],
// --       nominal type descriptor
// CHECK:   @_TMnC15generic_classes11RootGeneric,
// --       vtable
// CHECK:   @_TFC15generic_classes11RootGeneric3fooU__fGS0_Q__FT_T_,
// CHECK:   @_TFC15generic_classes11RootGeneric3barU__fGS0_Q__FT_T_,
// CHECK:   @_TFC15generic_classes11RootGeneric3basU__fGS0_Q__FT_T_,
// --       field offset placeholders
// CHECK:   i64 16, i64 0, i64 0
// CHECK: }

// -- Check that offset vars are emitted for fixed-layout generics
//    <rdar://problem/15081049>
// CHECK: @_TWvdvC15generic_classes22RootGenericFixedLayout1xVSs5UInt8 = global i64 16, align 8
// CHECK: @_TWvdvC15generic_classes22RootGenericFixedLayout1yGSaQ__ = global i64 24, align 8
// CHECK: @_TWvdvC15generic_classes22RootGenericFixedLayout1zVSs5UInt8 = global i64 32, align 8

// -- fixed-layout nongeneric descriptor
// CHECK: [[ROOTNONGENERIC_NAME:@.*]] = private unnamed_addr constant [35 x i8] c"C15generic_classes14RootNonGeneric\00"
// CHECK: @_TMnC15generic_classes14RootNonGeneric = constant { {{.*}} i32 } {
// --       0 = class
// CHECK:   i64 0,
// --       name
// CHECK:   i8* getelementptr inbounds ([35 x i8], [35 x i8]* [[ROOTNONGENERIC_NAME]], i64 0, i64 0),
// --       num fields
// CHECK:   i32 3,
// --       -- field offset vector offset
// CHECK:   i32 10,
// --       field names
// CHECK:   i8* getelementptr inbounds ([7 x i8], [7 x i8]* [[ROOTGENERIC_FIELDS]], i64 0, i64 0),
// --       no generic metadata pattern
// CHECK:   %swift.type_pattern* null,
// --       0 = no generic parameter vector
// CHECK:   i32 0,
// --       number of generic params, primary params
// CHECK:   i32 0, i32 0
// CHECK: }

// CHECK: @_TMdC15generic_classes14RootNonGeneric = global { {{.*}} } {
// CHECK:   void (%C15generic_classes14RootNonGeneric*)* @_TFC15generic_classes14RootNonGenericD,
// CHECK:   i8** @_TWVBo,
// CHECK:   i64 ptrtoint (%objc_class* @_TMmC15generic_classes14RootNonGeneric to i64),
// CHECK:   %objc_class* @"OBJC_CLASS_$_SwiftObject",
// CHECK:   %swift.opaque* @_objc_empty_cache,
// CHECK:   %swift.opaque* {{(@_objc_empty_vtable|null)}},
// CHECK:   @_DATA__TtC15generic_classes14RootNonGeneric
// CHECK:   i32 33,
// CHECK:   i16 7,
// CHECK:   i16 0,
// CHECK:   {{.*}}* @_TMnC15generic_classes14RootNonGeneric,
// CHECK: }

// CHECK: @_TMPdC15generic_classes22GenericInheritsGeneric = global { {{.*}}* } } {
// --       template fill function
// CHECK:   %swift.type* (%swift.type_pattern*, i8**)* [[CREATE_GENERICINHERITSGENERIC:@create_generic_metadata[0-9]*]],
// --       RootGeneric vtable
// CHECK:   @_TFC15generic_classes11RootGeneric3fooU__fGS0_Q__FT_T_,
// CHECK:   @_TFC15generic_classes11RootGeneric3barU__fGS0_Q__FT_T_,
// CHECK:   @_TFC15generic_classes11RootGeneric3basU__fGS0_Q__FT_T_,
// --       RootGeneric field offset placeholders
// CHECK:   i64 16, i64 0, i64 0
// --       GenericInheritsGeneric vtable
// CHECK:   @_TFC15generic_classes22GenericInheritsGeneric7zippityU___fGS0_Q_Q0__FT_T_,
// CHECK:   @_TFC15generic_classes22GenericInheritsGeneric3dooU___fGS0_Q_Q0__FT_T_,
// CHECK:   @_TFC15generic_classes22GenericInheritsGeneric3dahU___fGS0_Q_Q0__FT_T_,
// --       GenericInheritsGeneric field offset placeholder
// CHECK:   i64 0
// CHECK: }

// CHECK: @_TMPdC15generic_classes25GenericInheritsNonGeneric

class RootGeneric<T> {
  var x : UInt8

  init()

  // Test that declaration order doesn't cause the field offset vector to end
  // up interleaved with the vtable.
  func foo()

  var y : T

  func bar()

  var z : UInt8

  func bas()
}
sil @_TFC15generic_classes11RootGenericD : $@cc(method) @thin <T> (RootGeneric<T>) -> ()

sil @_TFC15generic_classes11RootGeneric3fooU__fGS0_Q__FT_T_ : $@cc(method) @thin <T> (@guaranteed RootGeneric<T>) -> ()

sil @_TFC15generic_classes11RootGeneric3barU__fGS0_Q__FT_T_ : $@cc(method) @thin <T> (@guaranteed RootGeneric<T>) -> ()

sil @_TFC15generic_classes11RootGeneric3basU__fGS0_Q__FT_T_ : $@cc(method) @thin <T> (@guaranteed RootGeneric<T>) -> ()

sil_vtable RootGeneric {
  #RootGeneric.foo!1: _TFC15generic_classes11RootGeneric3fooU__fGS0_Q__FT_T_
  #RootGeneric.bar!1: _TFC15generic_classes11RootGeneric3barU__fGS0_Q__FT_T_
  #RootGeneric.bas!1: _TFC15generic_classes11RootGeneric3basU__fGS0_Q__FT_T_
}

class RootGenericFixedLayout<T> {
  var x : UInt8
  var y : [T]
  var z : UInt8

  init()
}
sil_vtable RootGenericFixedLayout {}
sil @_TFC15generic_classes22RootGenericFixedLayoutD : $@cc(method) @thin <T> (RootGenericFixedLayout<T>) -> ()

class RootNonGeneric {
  var x : UInt8
  var y : Int
  var z : UInt8

  init()
}
sil_vtable RootNonGeneric {}
sil @_TFC15generic_classes14RootNonGenericD : $@cc(method) @thin (RootNonGeneric) -> ()

class GenericInheritsGeneric<A, B> : RootGeneric<A> {
  var w : B

  func zippity()
  func doo()
  func dah()

  override init()
}
sil @_TFC15generic_classes22GenericInheritsGenericD : $@cc(method) @thin <T,U> (GenericInheritsGeneric<T,U>) -> ()

sil @_TFC15generic_classes22GenericInheritsGeneric7zippityU___fGS0_Q_Q0__FT_T_ : $@cc(method) @thin <A, B> (@guaranteed GenericInheritsGeneric<A, B>) -> ()

sil @_TFC15generic_classes22GenericInheritsGeneric3dooU___fGS0_Q_Q0__FT_T_ : $@cc(method) @thin <A, B> (@guaranteed GenericInheritsGeneric<A, B>) -> ()

sil @_TFC15generic_classes22GenericInheritsGeneric3dahU___fGS0_Q_Q0__FT_T_ : $@cc(method) @thin <A, B> (@guaranteed GenericInheritsGeneric<A, B>) -> ()

sil_vtable GenericInheritsGeneric {
  #RootGeneric.foo!1: _TFC15generic_classes11RootGeneric3fooU__fGS0_Q__FT_T_
  #RootGeneric.bar!1: _TFC15generic_classes11RootGeneric3barU__fGS0_Q__FT_T_
  #RootGeneric.bas!1: _TFC15generic_classes11RootGeneric3basU__fGS0_Q__FT_T_
  #GenericInheritsGeneric.zippity!1: _TFC15generic_classes22GenericInheritsGeneric7zippityU___fGS0_Q_Q0__FT_T_
  #GenericInheritsGeneric.doo!1: _TFC15generic_classes22GenericInheritsGeneric3dooU___fGS0_Q_Q0__FT_T_
  #GenericInheritsGeneric.dah!1: _TFC15generic_classes22GenericInheritsGeneric3dahU___fGS0_Q_Q0__FT_T_
}

class GenericInheritsNonGeneric<C> : RootNonGeneric {
  var w : UInt8

  override init()
}
sil_vtable GenericInheritsNonGeneric {}
sil @_TFC15generic_classes25GenericInheritsNonGenericD : $@cc(method) @thin <T> (GenericInheritsNonGeneric<T>) -> ()

// rdar://18067671
class RecursiveGenericInheritsGeneric<A, B> : RootGeneric<A> {
  var w : B
  var r : RecursiveGenericInheritsGeneric<A, B>?

  func zippity()
  func doo()
  func dah()

  override init()
}
sil_vtable RecursiveGenericInheritsGeneric {}
sil @_TFC15generic_classes31RecursiveGenericInheritsGenericD : $@cc(method) @thin <T,U> (RecursiveGenericInheritsGeneric<T,U>) -> ()


// CHECK: define [[ROOTGENERIC]]* @RootGeneric_fragile_dependent_alloc
// CHECK:   [[METADATA:%.*]] = call %swift.type* @swift_getGenericMetadata
// CHECK:   [[METADATA_ARRAY:%.*]] = bitcast %swift.type* [[METADATA]] to i8*
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8, i8* [[METADATA_ARRAY]], i32 48
// CHECK:   [[T1:%.*]] = bitcast i8* [[T0]] to i32*
// CHECK:   [[SIZE32:%.*]] = load i32, i32* [[T1]], align 8
// CHECK:   [[SIZE:%.*]] = zext i32 [[SIZE32]] to i64
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8, i8* [[METADATA_ARRAY]], i32 52
// CHECK:   [[T1:%.*]] = bitcast i8* [[T0]] to i32*
// CHECK:   [[ALIGN32:%.*]] = load i32, i32* [[T1]], align 4
// CHECK:   [[ALIGN:%.*]] = zext i32 [[ALIGN32]] to i64
// CHECK:   call noalias %swift.refcounted* @swift_allocObject(%swift.type* [[METADATA]], i64 [[SIZE]], i64 [[ALIGN]])
sil @RootGeneric_fragile_dependent_alloc : $<G> () -> RootGeneric<G> {
entry:
  %x = alloc_ref $RootGeneric<G>
  return %x : $RootGeneric<G>
}

// RootGeneric.x has fixed layout
// CHECK: define i8 @RootGeneric_concrete_fragile_dependent_member_access_x
// CHECK:   getelementptr inbounds [[ROOTGENERIC]], [[ROOTGENERIC]]* %0, i32 0, i32 1
sil @RootGeneric_concrete_fragile_dependent_member_access_x : $<F> RootGeneric<F> -> UInt8 {
entry(%c : $RootGeneric<F>):
  %p = ref_element_addr %c : $RootGeneric<F>, #RootGeneric.x
  %x = load %p : $*UInt8
  return %x : $UInt8
}

// RootGeneric.y has dependent layout; load the offset from the metadata
// CHECK-LABEL: define void @RootGeneric_concrete_fragile_dependent_member_access_y
// CHECK:   [[TYPE_METADATA_ARRAY:%.*]] = bitcast %swift.type* {{%.*}} to i8***
// CHECK:   [[Y_OFFSET_ADDR:%.*]] = getelementptr inbounds i8**, i8*** [[TYPE_METADATA_ARRAY]], i64 15
// CHECK:   [[Y_OFFSET_PTR:%.*]] = load i8**, i8*** [[Y_OFFSET_ADDR]], align 8
// CHECK:   [[Y_OFFSET:%.*]] = ptrtoint i8** [[Y_OFFSET_PTR]] to i64
// CHECK:   [[CLASS_BYTE_ARRAY:%.*]] = bitcast [[ROOTGENERIC]]* {{%.*}} to i8*
// CHECK:   [[Y_ADDR:%.*]] = getelementptr inbounds i8, i8* [[CLASS_BYTE_ARRAY]], i64 [[Y_OFFSET]]
// CHECK:   bitcast i8* [[Y_ADDR]] to %swift.opaque*
sil @RootGeneric_concrete_fragile_dependent_member_access_y : $<F> (@out F, RootGeneric<F>) -> () {
entry(%z : $*F, %c : $RootGeneric<F>):
  %p = ref_element_addr %c : $RootGeneric<F>, #RootGeneric.y
  copy_addr %p to [initialization] %z : $*F
  %t = tuple ()
  return %t : $()
}

// CHECK-LABEL: define void @RootGeneric_subst_concrete_fragile_dependent_member_access_y
// CHECK:   [[TYPE_METADATA_ARRAY:%.*]] = bitcast %swift.type* {{%.*}} to i8***
// CHECK:   [[Y_OFFSET_ADDR:%.*]] = getelementptr inbounds i8**, i8*** [[TYPE_METADATA_ARRAY]], i64 15
// CHECK:   [[Y_OFFSET_PTR:%.*]] = load i8**, i8*** [[Y_OFFSET_ADDR]], align 8
// CHECK:   [[Y_OFFSET:%.*]] = ptrtoint i8** [[Y_OFFSET_PTR]] to i64
// CHECK:   [[CLASS_BYTE_ARRAY:%.*]] = bitcast [[ROOTGENERIC]]* {{%.*}} to i8*
// CHECK:   [[Y_ADDR:%.*]] = getelementptr inbounds i8, i8* [[CLASS_BYTE_ARRAY]], i64 [[Y_OFFSET]]
// CHECK:   bitcast i8* [[Y_ADDR]] to %Si*
sil @RootGeneric_subst_concrete_fragile_dependent_member_access_y : $(@out Int, RootGeneric<Int>) -> () {
entry(%z : $*Int, %c : $RootGeneric<Int>):
  %p = ref_element_addr %c : $RootGeneric<Int>, #RootGeneric.y
  copy_addr %p to [initialization] %z : $*Int
  %t = tuple ()
  return %t : $()
}

// RootGeneric.z has dependent layout; load the offset from the metadata
// CHECK-LABEL: define i8 @RootGeneric_concrete_fragile_dependent_member_access_z
// CHECK:   [[TYPE_METADATA_ARRAY:%.*]] = bitcast %swift.type* {{%.*}} to i8***
// CHECK:   [[Z_OFFSET_ADDR:%.*]] = getelementptr inbounds i8**, i8*** [[TYPE_METADATA_ARRAY]], i64 16
// CHECK:   [[Z_OFFSET_PTR:%.*]] = load i8**, i8*** [[Z_OFFSET_ADDR]], align 8
// CHECK:   [[Z_OFFSET:%.*]] = ptrtoint i8** [[Z_OFFSET_PTR]] to i64
// CHECK:   [[CLASS_BYTE_ARRAY:%.*]] = bitcast [[ROOTGENERIC]]* {{%.*}} to i8*
// CHECK:   [[Z_ADDR:%.*]] = getelementptr inbounds i8, i8* [[CLASS_BYTE_ARRAY]], i64 [[Z_OFFSET]]
// CHECK:   bitcast i8* [[Z_ADDR]] to %VSs5UInt8*
sil @RootGeneric_concrete_fragile_dependent_member_access_z : $<F> RootGeneric<F> -> UInt8 {
entry(%c : $RootGeneric<F>):
  %p = ref_element_addr %c : $RootGeneric<F>, #RootGeneric.z
  %z = load %p : $*UInt8
  return %z : $UInt8
}

// CHECK-LABEL: define i8 @RootGeneric_subst_concrete_fragile_dependent_member_access_z
// CHECK:   [[TYPE_METADATA_ARRAY:%.*]] = bitcast %swift.type* {{%.*}} to i8***
// CHECK:   [[Z_OFFSET_ADDR:%.*]] = getelementptr inbounds i8**, i8*** [[TYPE_METADATA_ARRAY]], i64 16
// CHECK:   [[Z_OFFSET_PTR:%.*]] = load i8**, i8*** [[Z_OFFSET_ADDR]], align 8
// CHECK:   [[Z_OFFSET:%.*]] = ptrtoint i8** [[Z_OFFSET_PTR]] to i64
// CHECK:   [[CLASS_BYTE_ARRAY:%.*]] = bitcast [[ROOTGENERIC]]* {{%.*}} to i8*
// CHECK:   [[Z_ADDR:%.*]] = getelementptr inbounds i8, i8* [[CLASS_BYTE_ARRAY]], i64 [[Z_OFFSET]]
// CHECK:   bitcast i8* [[Z_ADDR]] to %VSs5UInt8*
sil @RootGeneric_subst_concrete_fragile_dependent_member_access_z : $RootGeneric<Int> -> UInt8 {
entry(%c : $RootGeneric<Int>):
  %p = ref_element_addr %c : $RootGeneric<Int>, #RootGeneric.z
  %z = load %p : $*UInt8
  return %z : $UInt8
}

/* TODO: Instantiate types for fragile generic instances so we can do
 * fixed-layout access
sil @RootGeneric_concrete_fragile_fixed_member_access : $RootGeneric<Int32> -> (UInt8, Int32, UInt8) {
entry(%c : $RootGeneric<Int32>):
  %p = ref_element_addr %c : $RootGeneric<Int32>, #RootGeneric.x
  %x = load %p : $*UInt8
  %q = ref_element_addr %c : $RootGeneric<Int32>, #RootGeneric.y
  %y = load %q : $*Int32
  %r = ref_element_addr %c : $RootGeneric<Int32>, #RootGeneric.z
  %z = load %r : $*UInt8
  %t = tuple (%x : $UInt8, %y : $Int32, %z : $UInt8)
  return %t : $(UInt8, Int32, UInt8)
}
 */

// CHECK: define private %swift.type* [[CREATE_ROOTGENERIC]](%swift.type_pattern*, i8**) {
// -- initialize the dependent field offsets
// CHECK:   call void @swift_initClassMetadata_UniversalStrategy(%swift.type* {{%.*}}, %swift.type* null, i64 3, i64* {{%.*}}, i64* {{%.*}})
// CHECK: }

// CHECK: define private %swift.type* [[CREATE_GENERICINHERITSGENERIC]](%swift.type_pattern*, i8**) {
//   Bind the generic parameters.
// CHECK:   [[T0:%.*]] = load i8*, i8** %1
// CHECK:   %A = bitcast i8* [[T0]] to %swift.type*
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8*, i8** %1, i32 1
// CHECK:   [[T1:%.*]] = load i8*, i8** [[T0]]
// CHECK:   %B = bitcast i8* [[T1]] to %swift.type*
//   Construct the superclass.
// CHECK:   [[T0:%.*]] = bitcast %swift.type* %A to i8*
// CHECK:   [[SUPER:%.*]] = call %swift.type* @swift_getGenericMetadata1(%swift.type_pattern* {{.*}} @_TMPdC15generic_classes11RootGeneric {{.*}}, i8* [[T0]])
// CHECK:   [[T0:%.*]] = bitcast %swift.type* [[SUPER]] to %objc_class*
// CHECK:   [[METADATA:%.*]] = call %swift.type* @swift_allocateGenericClassMetadata(%swift.type_pattern* %0, i8** %1, %objc_class* [[T0]])
// CHECK:   [[METADATA_ARRAY:%.*]] = bitcast %swift.type* [[METADATA]] to i8**
//   Put the generic arguments in their correct positions.
// CHECK:   [[T0:%.*]] = bitcast %swift.type* %A to i8*
// CHECK:   [[A_ADDR:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY:%.*]], i32 17
// CHECK:   store i8* [[T0]], i8** [[A_ADDR]], align 8
// CHECK:   [[T0:%.*]] = bitcast %swift.type* %B to i8*
// CHECK:   [[B_ADDR:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY:%.*]], i32 18
// CHECK:   store i8* [[T0]], i8** [[B_ADDR]], align 8
//   Set up the isa.
// CHECK:   [[METADATA_ARRAY:%.*]] = bitcast %swift.type* [[METADATA]] to i8**
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY]], i32 0
// CHECK:   [[T1:%.*]] = bitcast i8** [[T0]] to %objc_class**
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY]], i32 24
// CHECK:   [[METACLASS:%.*]] = bitcast i8** [[T0]] to %objc_class*
// CHECK:   store %objc_class* [[METACLASS]], %objc_class** [[T1]], align 8
//   Set up the instance rodata pointer.
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY]], i32 4
// CHECK:   [[T1:%.*]] = bitcast i8** [[T0]] to i64*
// CHECK:   [[RODATA:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY]], i32 29
// CHECK:   [[T2:%.*]] = ptrtoint i8** [[RODATA]] to i64
// CHECK:   [[T3:%.*]] = or i64 [[T2]], 1
// CHECK:   store i64 [[T3]], i64* [[T1]], align 8
//   Set up the class rodata pointer.
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY]], i32 28
// CHECK:   [[T1:%.*]] = bitcast i8** [[T0]] to i64*
// CHECK:   [[META_RODATA:%.*]] = getelementptr inbounds i8*, i8** [[METADATA_ARRAY]], i32 38
// CHECK:   [[T2:%.*]] = ptrtoint i8** [[META_RODATA]] to i64
// CHECK:   store i64 [[T2]], i64* [[T1]], align 8
//   Set up the rodatas.
// CHECK:   [[T0:%.*]] = call i8* @swift_getGenericClassObjCName(
// CHECK:   [[T1:%.*]] = getelementptr inbounds i8*, i8** [[RODATA]], i32 3
// CHECK:   store i8* [[T0]], i8** [[T1]], align 8
// CHECK:   [[T1:%.*]] = getelementptr inbounds i8*, i8** [[META_RODATA]], i32 3
// CHECK:   store i8* [[T0]], i8** [[T1]], align 8
//   Load out the superclass.
// CHECK:   [[T0:%.*]] = bitcast %swift.type* [[METADATA]] to %swift.type**
// CHECK:   [[T1:%.*]] = getelementptr inbounds %swift.type*, %swift.type** [[T0]], i32 1
// CHECK:   [[SUPER:%.*]] = load %swift.type*, %swift.type** [[T1]], align 8
//   Set up the metaclass's superclass from the superclass's metaclass.
// CHECK:   [[T0:%.*]] = bitcast %swift.type* [[SUPER]] to i64*
// CHECK:   [[T1:%.*]] = load i64, i64* [[T0]], align 8
// CHECK:   [[T2:%.*]] = load i64, i64* @swift_isaMask, align 8
// CHECK:   [[T3:%.*]] = and i64 [[T1]], [[T2]]
// CHECK:   [[SUPER_METACLASS:%.*]] = inttoptr i64 [[T3]] to %swift.type*
// CHECK:   [[T0:%.*]] = bitcast %objc_class* [[METACLASS]] to %swift.type**
// CHECK:   [[META_SUPERCLASS_ADDR:%.*]] = getelementptr inbounds %swift.type*, %swift.type** [[T0]], i32 1
// CHECK:   store %swift.type* [[SUPER_METACLASS]], %swift.type** [[META_SUPERCLASS_ADDR]]
//   Copy various stuff from the superclass:
// CHECK:   [[SUPER_ARRAY:%.*]] = bitcast %swift.type* [[SUPER]] to i64*
// CHECK:   [[METADATA_ARRAY:%.*]] = bitcast %swift.type* [[METADATA]] to i64*
//    - the superclass's generic args
// CHECK:   [[SUPER_T_ADDR:%.*]] = getelementptr inbounds i64, i64* [[SUPER_ARRAY]], i32 9
// CHECK:   [[SELF_T_ADDR:%.*]] = getelementptr inbounds i64, i64* [[METADATA_ARRAY]], i32 9
// CHECK:   [[T:%.*]] = load i64, i64* [[SUPER_T_ADDR]], align 8
// CHECK:   store i64 [[T]], i64* [[SELF_T_ADDR]], align 8
//    - the super field offsets
// CHECK:   [[SUPER_BASE_VEC:%.*]] = getelementptr inbounds i64, i64* [[SUPER_ARRAY]], i32 14
// CHECK:   [[SELF_BASE_VEC:%.*]] = getelementptr inbounds i64, i64* [[METADATA_ARRAY]], i32 14
// CHECK:   [[SELF_BASE_VEC_I8:%.*]] = bitcast i64* [[SELF_BASE_VEC]] to i8*
// CHECK:   [[SUPER_BASE_VEC_I8:%.*]] = bitcast i64* [[SUPER_BASE_VEC]] to i8*
// CHECK:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* [[SELF_BASE_VEC_I8]], i8* [[SUPER_BASE_VEC_I8]], i64 24, i32 8, i1 false)
//   Initialize our own dependent field offsets.
// CHECK:   [[METADATA_ARRAY:%.*]] = bitcast %swift.type* [[METADATA]] to i64*
// CHECK:   [[OFFSETS:%.*]] = getelementptr inbounds i64, i64* [[METADATA_ARRAY]], i32 22
// CHECK:   [[T0:%.*]] = bitcast %swift.type* %B to i8***
// CHECK:   [[T1:%.*]] = getelementptr inbounds i8**, i8*** [[T0]], i64 -1
// CHECK:   [[VWT:%.*]] = load i8**, i8*** [[T1]], align 8
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8*, i8** [[VWT]], i32 17
// CHECK:   [[T1:%.*]] = load i8*, i8** [[T0]], align 8
// CHECK:   [[SIZE:%.*]] = ptrtoint i8* [[T1]] to i64
// CHECK:   [[T0:%.*]] = getelementptr inbounds i8*, i8** [[VWT]], i32 18
// CHECK:   [[T1:%.*]] = load i8*, i8** [[T0]], align 8
// CHECK:   [[T2:%.*]] = ptrtoint i8* [[T1]] to i64
// CHECK:   [[ALIGN:%.*]] = and i64 [[T2]], 65535
// CHECK:   [[SIZE_ADDR:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[TYPES:%.*]], i32 0, i32 0
// CHECK:   store i64 [[SIZE]], i64* [[SIZE_ADDR]], align 8
// CHECK:   [[ALIGN_ADDR:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[TYPES]], i32 0, i32 1
// CHECK:   store i64 [[ALIGN]], i64* [[ALIGN_ADDR]], align 8
// CHECK:   call void @swift_initClassMetadata_UniversalStrategy(%swift.type* [[METADATA]], %swift.type* [[SUPER]], i64 1, i64* [[SIZE_ADDR]], i64* [[OFFSETS]])
// CHECK:   ret %swift.type* [[METADATA]]
// CHECK: }
