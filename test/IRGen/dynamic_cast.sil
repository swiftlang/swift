// RUN: %swift -emit-ir -target x86_64-apple-darwin10 %s | FileCheck %s
sil_stage canonical

import Builtin
import Swift

protocol P {
  func f() -> Self
}

struct S {
  var v: Int
}

// CHECK-LABEL: define void @testUnconditional0(
sil @testUnconditional0 : $@thin (@in P) -> () {
bb0(%0 : $*P):
  // CHECK: [[T0:%.*]] = alloca [[S:%.*]], align
  // CHECK: [[T1:%.*]] = bitcast [[S]]* [[T0]] to [[OPAQUE:%swift.opaque]]*
  // CHECK: [[T2:%.*]] = bitcast [[P:%.*]]* {{%.*}} to [[OPAQUE]]*
  // CHECK: [[T3:%.*]] = call [[TYPE:%.*]]* @swift_getExistentialTypeMetadata
  // CHECK: call i1 @swift_dynamicCast([[OPAQUE]]* [[T1]], [[OPAQUE]]* [[T2]], [[TYPE]]* [[T3]], [[TYPE]]* getelementptr {{.*}}, i64 7)
  %1 = alloc_stack $S
  unconditional_checked_cast_addr existential_to_concrete take_always %0 : $*P to %1#1 : $*S
  destroy_addr %1#1 : $*S
  dealloc_stack %1#0 : $*@local_storage S
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: define void @testUnconditional1(
sil @testUnconditional1 : $@thin (@in P) -> () {
bb0(%0 : $*P):
  // CHECK: [[T0:%.*]] = alloca [[S:%.*]], align
  // CHECK: [[T1:%.*]] = bitcast [[S]]* [[T0]] to [[OPAQUE:%swift.opaque]]*
  // CHECK: [[T2:%.*]] = bitcast [[P:%.*]]* {{%.*}} to [[OPAQUE]]*
  // CHECK: [[T3:%.*]] = call [[TYPE:%.*]]* @swift_getExistentialTypeMetadata
  // CHECK: call i1 @swift_dynamicCast([[OPAQUE]]* [[T1]], [[OPAQUE]]* [[T2]], [[TYPE]]* [[T3]], [[TYPE]]* getelementptr {{.*}}, i64 3)
  %1 = alloc_stack $S
  unconditional_checked_cast_addr existential_to_concrete take_on_success %0 : $*P to %1#1 : $*S
  destroy_addr %1#1 : $*S
  dealloc_stack %1#0 : $*@local_storage S
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: define void @testUnconditional2(
sil @testUnconditional2 : $@thin (@in P) -> () {
bb0(%0 : $*P):
  // CHECK: [[T0:%.*]] = alloca [[S:%.*]], align
  // CHECK: [[T1:%.*]] = bitcast [[S]]* [[T0]] to [[OPAQUE:%swift.opaque]]*
  // CHECK: [[T2:%.*]] = bitcast [[P:%.*]]* {{%.*}} to [[OPAQUE]]*
  // CHECK: [[T3:%.*]] = call [[TYPE:%.*]]* @swift_getExistentialTypeMetadata
  // CHECK: call i1 @swift_dynamicCast([[OPAQUE]]* [[T1]], [[OPAQUE]]* [[T2]], [[TYPE]]* [[T3]], [[TYPE]]* getelementptr {{.*}}, i64 1)
  %1 = alloc_stack $S
  unconditional_checked_cast_addr existential_to_concrete copy_on_success %0 : $*P to %1#1 : $*S
  destroy_addr %1#1 : $*S
  dealloc_stack %1#0 : $*@local_storage S
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: define void @testConditional0(
sil @testConditional0 : $@thin (@in P) -> () {
bb0(%0 : $*P):
  // CHECK: [[T0:%.*]] = alloca [[S:%.*]], align
  // CHECK: [[T1:%.*]] = bitcast [[S]]* [[T0]] to [[OPAQUE:%swift.opaque]]*
  // CHECK: [[T2:%.*]] = bitcast [[P:%.*]]* {{%.*}} to [[OPAQUE]]*
  // CHECK: [[T3:%.*]] = call [[TYPE:%.*]]* @swift_getExistentialTypeMetadata
  // CHECK: [[T4:%.*]] = call i1 @swift_dynamicCast([[OPAQUE]]* [[T1]], [[OPAQUE]]* [[T2]], [[TYPE]]* [[T3]], [[TYPE]]* getelementptr {{.*}}, i64 6)
  // CHECK: br i1 [[T4]], 
  %1 = alloc_stack $S
  checked_cast_addr_br existential_to_concrete take_always %0 : $*P to %1#1 : $*S, bb1, bb2
bb1:
  br bb2
bb2:
  destroy_addr %1#1 : $*S
  dealloc_stack %1#0 : $*@local_storage S
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: define void @testConditional1(
sil @testConditional1 : $@thin (@in P) -> () {
bb0(%0 : $*P):
  // CHECK: [[T0:%.*]] = alloca [[S:%.*]], align
  // CHECK: [[T1:%.*]] = bitcast [[S]]* [[T0]] to [[OPAQUE:%swift.opaque]]*
  // CHECK: [[T2:%.*]] = bitcast [[P:%.*]]* {{%.*}} to [[OPAQUE]]*
  // CHECK: [[T3:%.*]] = call [[TYPE:%.*]]* @swift_getExistentialTypeMetadata
  // CHECK: [[T4:%.*]] = call i1 @swift_dynamicCast([[OPAQUE]]* [[T1]], [[OPAQUE]]* [[T2]], [[TYPE]]* [[T3]], [[TYPE]]* getelementptr {{.*}}, i64 2)
  // CHECK: br i1 [[T4]], 
  %1 = alloc_stack $S
  checked_cast_addr_br existential_to_concrete take_on_success %0 : $*P to %1#1 : $*S, bb1, bb2
bb1:
  br bb2
bb2:
  destroy_addr %1#1 : $*S
  dealloc_stack %1#0 : $*@local_storage S
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: define void @testConditional2(
sil @testConditional2 : $@thin (@in P) -> () {
bb0(%0 : $*P):
  // CHECK: [[T0:%.*]] = alloca [[S:%.*]], align
  // CHECK: [[T1:%.*]] = bitcast [[S]]* [[T0]] to [[OPAQUE:%swift.opaque]]*
  // CHECK: [[T2:%.*]] = bitcast [[P:%.*]]* {{%.*}} to [[OPAQUE]]*
  // CHECK: [[T3:%.*]] = call [[TYPE:%.*]]* @swift_getExistentialTypeMetadata
  // CHECK: [[T4:%.*]] = call i1 @swift_dynamicCast([[OPAQUE]]* [[T1]], [[OPAQUE]]* [[T2]], [[TYPE]]* [[T3]], [[TYPE]]* getelementptr {{.*}}, i64 0)
  // CHECK: br i1 [[T4]], 
  %1 = alloc_stack $S
  checked_cast_addr_br existential_to_concrete copy_on_success %0 : $*P to %1#1 : $*S, bb1, bb2
bb1:
  br bb2
bb2:
  destroy_addr %1#1 : $*S
  dealloc_stack %1#0 : $*@local_storage S
  %2 = tuple ()
  return %2 : $()
}
