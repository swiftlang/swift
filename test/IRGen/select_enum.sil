// RUN: %target-swift-frontend -gnone -emit-ir %s | FileCheck %s

import Builtin

enum SinglePayloadSingleEmpty {
  case EmptyCase
  case DataCase(Builtin.Word)
}

// CHECK-LABEL: define void @select_enum_SinglePayloadSingleEmpty(%O11select_enum24SinglePayloadSingleEmpty*)
sil @select_enum_SinglePayloadSingleEmpty : $@thin (@in SinglePayloadSingleEmpty) -> () {
bb0(%0 : $*SinglePayloadSingleEmpty):
  %1 = load %0 : $*SinglePayloadSingleEmpty
  // CHECK: [[PAYLOAD1:%[0-9]+]] = load [[WORD_TY:(i32|i64)]], [[WORD_TY:(i32|i64)]]*
  // CHECK: [[TAG1:%[0-9]+]] = load i1, i1*

  %2 = integer_literal $Builtin.Int32, 2
  %3 = integer_literal $Builtin.Int32, 3

  // CHECK:      [[V1:%[0-9]+]] = icmp eq [[WORD_TY]] [[PAYLOAD1]], 0
  // CHECK-NEXT: [[V2:%[0-9]+]] = and i1 [[TAG1]], [[V1]]
  // CHECK-NEXT:   select i1 [[V2]], i32 2, i32 3
  %4 = select_enum %1 : $SinglePayloadSingleEmpty, case #SinglePayloadSingleEmpty.EmptyCase!enumelt: %2, case #SinglePayloadSingleEmpty.DataCase!enumelt.1: %3 : $Builtin.Int32

  // CHECK:      [[V1:%[0-9]+]] = icmp eq [[WORD_TY]] [[PAYLOAD1]], 0
  // CHECK-NEXT: [[V2:%[0-9]+]] = and i1 [[TAG1]], [[V1]]
  // CHECK-NEXT: [[V3:%[0-9]+]] = xor i1 [[V2]], true
  // CHECK-NEXT:   select i1 [[V3]], i32 3, i32 2
  %5 = select_enum %1 : $SinglePayloadSingleEmpty, case #SinglePayloadSingleEmpty.DataCase!enumelt.1: %3, case #SinglePayloadSingleEmpty.EmptyCase!enumelt: %2 : $Builtin.Int32

  // CHECK: [[PAYLOAD0:%[0-9]+]] = load [[WORD_TY]], [[WORD_TY]]*
  // CHECK: [[TAG0:%[0-9]+]] = load i1, i1*

  // CHECK:      [[V1:%[0-9]+]] = icmp eq [[WORD_TY]] [[PAYLOAD0]], 0
  // CHECK-NEXT: [[V2:%[0-9]+]] = and i1 [[TAG0]], [[V1]]
  // CHECK-NEXT:   select i1 [[V2]], i32 2, i32 3
  %6 = select_enum_addr %0 : $*SinglePayloadSingleEmpty, case #SinglePayloadSingleEmpty.EmptyCase!enumelt: %2, case #SinglePayloadSingleEmpty.DataCase!enumelt.1: %3 : $Builtin.Int32

  // CHECK:      [[V1:%[0-9]+]] = icmp eq [[WORD_TY]] [[PAYLOAD1]], 0
  // CHECK-NEXT: [[V2:%[0-9]+]] = and i1 [[TAG1]], [[V1]]
  // CHECK-NEXT:   select i1 [[V2]], i32 2, i32 3
  %7 = select_enum %1 : $SinglePayloadSingleEmpty, case #SinglePayloadSingleEmpty.EmptyCase!enumelt: %2, default %3 : $Builtin.Int32

  return undef : $()
}

enum TwoCasesNoPayload { case X, Y }

enum MyOptional<T> {
  case Some(T), None
}


sil @select_enum_TwoCasesNoPayload :$ @thin (@in TwoCasesNoPayload, @in MyOptional<TwoCasesNoPayload>) -> () {
bb0(%0 : $*TwoCasesNoPayload, %10 : $*MyOptional<TwoCasesNoPayload>):
// CHECK: [[PAYLOAD1:%[0-9]+]] = load i1, i1*
  %1 = load %0 : $*TwoCasesNoPayload

  %2 = integer_literal $Builtin.Int32, 2
  %3 = integer_literal $Builtin.Int32, 42

  // CHECK-NEXT: [[V2:%[0-9]+]] = icmp eq i1 [[PAYLOAD1]], false
  // CHECK-NEXT:   select i1 [[V2]], i32 2, i32 42
  %4 = select_enum %1 : $TwoCasesNoPayload, case #TwoCasesNoPayload.X!enumelt: %2, case #TwoCasesNoPayload.Y!enumelt: %3 : $Builtin.Int32

  // CHECK-NEXT: [[V2:%[0-9]+]] = icmp eq i1 [[PAYLOAD1]], true
  // CHECK-NEXT:   select i1 [[V2]], i32 42, i32 2
  %5 = select_enum %1 : $TwoCasesNoPayload, case #TwoCasesNoPayload.Y!enumelt: %3, default %2 : $Builtin.Int32


  // CHECK: [[PAYLOAD2:%[0-9]+]] = load i8, i8*
  %11 = load %10 : $*MyOptional<TwoCasesNoPayload>

  // CHECK-NEXT: [[V1:%[0-9]+]] = icmp eq i8 [[PAYLOAD2]], 2
  // CHECK-NEXT: [[V2:%[0-9]+]] = xor i1 [[V1]], true
  // CHECK:  = select i1 [[V2]], i32 2, i32 42
  %14 = select_enum %11 : $MyOptional<TwoCasesNoPayload>, case #MyOptional.Some!enumelt.1: %2, case #MyOptional.None!enumelt: %3 : $Builtin.Int32

  // CHECK-NEXT: [[V1:%[0-9]+]] = icmp eq i8 [[PAYLOAD2]], 2
  // CHECK:  = select i1 [[V1]], i32 42, i32 2
  %15 = select_enum %11 : $MyOptional<TwoCasesNoPayload>, case #MyOptional.None!enumelt: %3, default %2 : $Builtin.Int32

  return undef : $()
}
