// RUN: not %swift -typecheck -target %target-triple %s -fixit-all -emit-fixits-path %t.remap
// RUN: c-arcmt-test %t.remap | arcmt-test -verify-transformed-files %s.result

protocol P {}

// FIX-ME(SR-8102): Emit fix-its for the last requirements once we support bulk
// removal of 'dependant' fix-its.
struct S1<T> where T : Any {}
struct S2<T> where T : P, T : Any {}
struct S3<T> where T : P, T : Any {}
struct S4<T> where T : P {}
struct S5<T> {}

protocol P1 {
  associatedtype X1 
  associatedtype X2 where X2 : Any
  associatedtype X3 where X2 : P
}

// FIX-ME(SR-8102): Always emit fix-its for the second conformances once we
// support bulk removal of 'dependant' fix-its.
struct S6 : Any {}
struct S7 : P {}
struct S8 : P {}
struct S9 : Any, P {}
struct S10 {}
struct S11 : P {}

enum E1 : String { case x }
enum E2 : String { case x }
enum E3 {}
enum E4 : String, Any { case x }

class C {}
class C1 : C {}
class C2 : C {}
class C3 {}
class C4 : C, Any {}
class C5 : AnyObject {}
class C6 : AnyObject {}
class C7 : Any, AnyObject {}

// FIX-ME: Implement redundant Any fix-its for requirements parsed as inheritance clauses.
struct S12<T : Any> {}
protocol P2 : Any {}
protocol P3 : Any {}
protocol P4 : class, Any, AnyObject {} // Parse will re-arrange 'class' to be first.
protocol P5 : Any, AnyObject {}
protocol P6 : AnyObject, Any {}

protocol P7 {
  associatedtype X1 : Any
  associatedtype X2 : Any
}
