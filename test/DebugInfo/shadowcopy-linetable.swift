// RUN: %target-swift-frontend %s -emit-sil -Xllvm -sil-print-debuginfo -Xllvm -sil-print-debuginfo-verbose -g -o - | %FileCheck %s --check-prefix=SILCHECK
// RUN: %target-swift-frontend %s -emit-ir -g -o - | %FileCheck %s --check-prefix=IRCHECK
func markUsed<T>(_ t: T) {}

func foo(_ x: inout Int64) {

  // Make sure that the begin_access, load, and end_access instructions
  // are not marked as isImplicit: true. They should not be implicit
  // because they are generated from a member_ref_expr which is the
  // lvalue SubExpr of a LoadExpr. LoadExpr's are always implicit, but 
  // that doesn't necessarily mean their SubExprs are implicit as well.
  // SILCHECK: sil hidden @$s4main3fooyys5Int64VzF
  // SILCHECK: debug_value %0, var, name "x", argno 1, expr op_deref, loc {{.*}} isImplicit: false, isAutoGenerated: false, isHiddenFromDebugInfo: false, scope 7 // id: %1
  // SILCHECK: begin_access [read] [static] %0, loc {{.*}} isImplicit: false, isAutoGenerated: false, isHiddenFromDebugInfo: false
  // SILCHECK-NEXT: load %2, loc {{.*}} isImplicit: false, isAutoGenerated: false, isHiddenFromDebugInfo: false
  // SILCHECK-NEXT: end_access %2, loc * {{.*}} isImplicit: false, isAutoGenerated: true, isHiddenFromDebugInfo: true

  // Make sure the shadow copy is being made in the prologue or (at
  // line 0), but the code to load the value from the inout storage is
  // not.
  // IRCHECK: define hidden swiftcc void @"$s4main3fooyys5Int64VzF"
  // IRCHECK: %[[X:.*]] = alloca ptr, align {{(4|8)}}
  // IRCHECK-NEXT: #dbg_declare
  // IRCHECK-NEXT: call void @llvm.memset.{{.*}}(ptr align {{(4|8)}} %[[X]], i8 0
  // IRCHECK: store ptr %0, ptr %[[X]], align {{(4|8)}}
  // IRCHECK-SAME: !dbg ![[LOC0:.*]]
  // IRCHECK-NEXT: %[[VALUE:.*]] = getelementptr inbounds %Ts5Int64V, ptr %0, i32 0, i32 0,
  // IRCHECK-SAME: !dbg ![[LOCLOAD:.*]]
  // IRCHECK-NEXT: load i64, ptr %[[VALUE]], align {{(4|8)}}
  // IRCHECK-SAME: !dbg ![[LOCLOAD]]
  // IRCHECK: ![[LOC0]] = !DILocation(line: 0,
  // IRCHECK: !DILocation(line: [[@LINE+1]],
  x = x + 2
}

func main() {
  var x : Int64 = 1
  foo(&x)
  markUsed("break here to see \(x)")
}

main()
