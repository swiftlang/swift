// RUN: %target-sil-opt -global-arc-opts -verify %s | FileCheck %s

sil_stage canonical

import Swift
import Builtin

// Utilities

sil @user : $@thin (Builtin.NativeObject) -> ()

struct S {
  var x : Builtin.NativeObject
}
sil @S_user : $@thin (S) -> ()

struct S2 {
  var x : Builtin.Int32
  var y : Builtin.NativeObject
  var z : Builtin.Int32
}

struct S3 {
  var x : Builtin.Int32
  var y : Builtin.NativeObject
  var y1 : Builtin.NativeObject
  var z : Builtin.Int32
}

class Cls {
  var random : Builtin.Int32

  init()
}

class C {
  var w : Optional<Builtin.NativeObject>
}

class RetainUser { }

sil @rawpointer_use: $@thin (Builtin.RawPointer) -> Bool

enum FakeOptional<T> {
  case None
  case Some(T)
}
sil @fakeoptional_user : $@thin (FakeOptional<Builtin.NativeObject>) -> ()

enum Either<LTy, RTy> {
  case Left(LTy)
  case Right(RTy)
}

/// This type allows us to make sure we are skipping cases correctly when
/// stripping off ref count identical opts.
enum FakeCasesOptional<T> {
  case None
  case None1
  case Some(T)
  case None2
  case Some2(T)
  case None3
}

///////////
// Tests //
///////////

// CHECK-LABEL: sil @silargument_strip_single_payload_case_enum1 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
// CHECK-NOT: retain
// CHECK-NOT: release
sil @silargument_strip_single_payload_case_enum1 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : $FakeOptional<Builtin.NativeObject>):
  switch_enum %0 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  br bb3(%0 : $FakeOptional<Builtin.NativeObject>)

bb2:
  br bb3(%0 : $FakeOptional<Builtin.NativeObject>)

bb3(%1 : $FakeOptional<Builtin.NativeObject>):
  retain_value %1 : $FakeOptional<Builtin.NativeObject>
  release_value %0 : $FakeOptional<Builtin.NativeObject>
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @silargument_strip_single_payload_case_enum2 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
// CHECK-NOT: retain
// CHECK-NOT: release
sil @silargument_strip_single_payload_case_enum2 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : $FakeOptional<Builtin.NativeObject>):
  switch_enum %0 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  br bb3(%0 : $FakeOptional<Builtin.NativeObject>)

bb2:
  %1 = enum $FakeOptional<Builtin.NativeObject>, #FakeOptional.None!enumelt
  br bb3(%1 : $FakeOptional<Builtin.NativeObject>)

bb3(%2 : $FakeOptional<Builtin.NativeObject>):
  retain_value %2 : $FakeOptional<Builtin.NativeObject>
  release_value %0 : $FakeOptional<Builtin.NativeObject>
  %3 = tuple()
  return %3 : $()
}

// CHECK-LABEL: sil @silargument_strip_single_payload_case_enum3 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
// CHECK-NOT: retain
// CHECK-NOT: release
sil @silargument_strip_single_payload_case_enum3 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : $FakeOptional<Builtin.NativeObject>):
  switch_enum %0 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  %1 = enum $FakeOptional<Builtin.NativeObject>, #FakeOptional.None!enumelt
  br bb3(%1 : $FakeOptional<Builtin.NativeObject>)

bb2:
  br bb3(%0 : $FakeOptional<Builtin.NativeObject>)

bb3(%2 : $FakeOptional<Builtin.NativeObject>):
  retain_value %2 : $FakeOptional<Builtin.NativeObject>
  release_value %0 : $FakeOptional<Builtin.NativeObject>
  %3 = tuple()
  return %3 : $()
}

// Make sure we do not do anything dubm when we have two enums without payloads.
// CHECK-LABEL: sil @silargument_strip_single_payload_case_enum4 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
// CHECK: retain_value
// CHECK: release_value
sil @silargument_strip_single_payload_case_enum4 : $@thin (FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : $FakeOptional<Builtin.NativeObject>):
  switch_enum %0 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  %1 = enum $FakeOptional<Builtin.NativeObject>, #FakeOptional.None!enumelt
  br bb3(%1 : $FakeOptional<Builtin.NativeObject>)

bb2:
  %2 = enum $FakeOptional<Builtin.NativeObject>, #FakeOptional.None!enumelt
  br bb3(%2 : $FakeOptional<Builtin.NativeObject>)

bb3(%3 : $FakeOptional<Builtin.NativeObject>):
  retain_value %3 : $FakeOptional<Builtin.NativeObject>
  release_value %0 : $FakeOptional<Builtin.NativeObject>
  %4 = tuple()
  return %4 : $()
}

// Make sure that we can handle the multi payload case with interleaved empty
// payloads.
// CHECK-LABEL: sil @silargument_strip_multipayload_with_fake_nopayload_cases : $@thin (FakeCasesOptional<Builtin.NativeObject>) -> () {
// CHECK-NOT: retain
// CHECK-NOT: release
sil @silargument_strip_multipayload_with_fake_nopayload_cases : $@thin (FakeCasesOptional<Builtin.NativeObject>) -> () {
bb0(%0 : $FakeCasesOptional<Builtin.NativeObject>):
  switch_enum %0 : $FakeCasesOptional<Builtin.NativeObject>, case #FakeCasesOptional.None!enumelt: bb1, case #FakeCasesOptional.None1!enumelt: bb2, case #FakeCasesOptional.Some!enumelt.1: bb3, case #FakeCasesOptional.None2!enumelt: bb4, case #FakeCasesOptional.Some2!enumelt.1: bb5, case #FakeCasesOptional.None3!enumelt: bb6

bb1:
  %1 = enum $FakeCasesOptional<Builtin.NativeObject>, #FakeCasesOptional.None!enumelt
  br bb7(%1 : $FakeCasesOptional<Builtin.NativeObject>)

bb2:
  %2 = enum $FakeCasesOptional<Builtin.NativeObject>, #FakeCasesOptional.None1!enumelt
  br bb7(%2 : $FakeCasesOptional<Builtin.NativeObject>)

bb3:
  br bb7(%0 : $FakeCasesOptional<Builtin.NativeObject>)

bb4:
  %3 = enum $FakeCasesOptional<Builtin.NativeObject>, #FakeCasesOptional.None2!enumelt
  br bb7(%3 : $FakeCasesOptional<Builtin.NativeObject>)

bb5:
  br bb7(%0 : $FakeCasesOptional<Builtin.NativeObject>)

bb6:
  %4 = enum $FakeCasesOptional<Builtin.NativeObject>, #FakeCasesOptional.None3!enumelt
  br bb7(%4 : $FakeCasesOptional<Builtin.NativeObject>)

bb7(%5 : $FakeCasesOptional<Builtin.NativeObject>):
  retain_value %5 : $FakeCasesOptional<Builtin.NativeObject>
  release_value %0 : $FakeCasesOptional<Builtin.NativeObject>
  %6 = tuple()
  return %6 : $()
}

// CHECK-LABEL: sil @silargument_nondominated_strip : $@thin (@in FakeOptional<Builtin.NativeObject>) -> () {
// CHECK: retain_value
// CHECK: release_value
sil @silargument_nondominated_strip : $@thin (@in FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : $*FakeOptional<Builtin.NativeObject>):
  cond_br undef, bb1, bb2

bb1:
  %1 = load %0 : $*FakeOptional<Builtin.NativeObject>
  br bb3(%1 : $FakeOptional<Builtin.NativeObject>)

bb2:
  %2 = enum $FakeOptional<Builtin.NativeObject>, #FakeOptional.None!enumelt
  br bb3(%2 : $FakeOptional<Builtin.NativeObject>)

bb3(%3 : $FakeOptional<Builtin.NativeObject>):
  %4 = function_ref @fakeoptional_user : $@thin (FakeOptional<Builtin.NativeObject>) -> ()
  retain_value %3 : $FakeOptional<Builtin.NativeObject>
  apply %4(%3) : $@thin (FakeOptional<Builtin.NativeObject>) -> ()
  apply %4(%3) : $@thin (FakeOptional<Builtin.NativeObject>) -> ()
  release_value %3 : $FakeOptional<Builtin.NativeObject>
  %5 = tuple()
  return %5 : $()
}

struct _SwiftEmptyArrayStorage {
}

sil_global [fragile] @_swiftEmptyArrayStorage : $_SwiftEmptyArrayStorage

// CHECK-LABEL: sil @dont_strip_rawpointer_to_adress
// CHECK: raw_pointer_to_ref
// CHECK: strong_retain
// CHECK: return
sil @dont_strip_rawpointer_to_adress : $@thin(FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : $FakeOptional<Builtin.NativeObject>):
  %2 = global_addr @_swiftEmptyArrayStorage : $*_SwiftEmptyArrayStorage
  %3 = address_to_pointer %2 : $*_SwiftEmptyArrayStorage to $Builtin.RawPointer
  %4 = raw_pointer_to_ref %3 : $Builtin.RawPointer to $Builtin.NativeObject
  strong_retain %4 : $Builtin.NativeObject
  %5 = function_ref @user : $@thin (Builtin.NativeObject) -> ()
  apply %5(%4) : $@thin (Builtin.NativeObject) -> ()
  apply %5(%4) : $@thin (Builtin.NativeObject) -> ()
  strong_release %4 : $Builtin.NativeObject
  %6 = tuple()
  return %6 : $()
}

// CHECK-LABEL: sil @dont_strip_phi_nodes_over_backedges_1bb : $@thin () -> () {
// CHECK: retain_value
// CHECK: release_value
sil @dont_strip_phi_nodes_over_backedges_1bb : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional<Cls>, #FakeOptional.None!enumelt
  br bb1(%0 : $FakeOptional<Cls>)

bb1(%1 : $FakeOptional<Cls>):
  %2 = alloc_ref $Cls
  retain_value %2 : $Cls
  release_value %1 : $FakeOptional<Cls>
  %3 = enum $FakeOptional<Cls>, #FakeOptional.Some!enumelt.1, %2 : $Cls
  cond_br undef, bb1(%3 : $FakeOptional<Cls>), bb2

bb2:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @dont_strip_phi_nodes_over_backedges_multibb1 : $@thin () -> () {
// CHECK: retain_value
// CHECK: release_value
sil @dont_strip_phi_nodes_over_backedges_multibb1 : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional<Cls>, #FakeOptional.None!enumelt
  br bb1(%0 : $FakeOptional<Cls>)

bb1(%1 : $FakeOptional<Cls>):
  %2 = alloc_ref $Cls
  retain_value %2 : $Cls
  br bb2

bb2:
  release_value %1 : $FakeOptional<Cls>
  %3 = enum $FakeOptional<Cls>, #FakeOptional.Some!enumelt.1, %2 : $Cls
  br bb3

bb3:
  cond_br undef, bb1(%3 : $FakeOptional<Cls>), bb4

bb4:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @dont_strip_phi_nodes_over_backedges_multibb2 : $@thin () -> () {
// CHECK: retain_value
// CHECK: release_value
sil @dont_strip_phi_nodes_over_backedges_multibb2 : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional<Cls>, #FakeOptional.None!enumelt
  br bb1(%0 : $FakeOptional<Cls>)

bb1(%1 : $FakeOptional<Cls>):
  br bb2

bb2:
  %2 = alloc_ref $Cls
  retain_value %2 : $Cls
  release_value %1 : $FakeOptional<Cls>
  %3 = enum $FakeOptional<Cls>, #FakeOptional.Some!enumelt.1, %2 : $Cls
  br bb3

bb3:
  cond_br undef, bb1(%3 : $FakeOptional<Cls>), bb4

bb4:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @dont_strip_phi_nodes_over_backedges_multibb3 : $@thin () -> () {
// CHECK: retain_value
// CHECK: release_value
sil @dont_strip_phi_nodes_over_backedges_multibb3 : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional<Cls>, #FakeOptional.None!enumelt
  br bb1(%0 : $FakeOptional<Cls>)

bb1(%1 : $FakeOptional<Cls>):
  br bb2

bb2:
  %2 = alloc_ref $Cls
  retain_value %2 : $Cls
  br bb3

bb3:
  release_value %1 : $FakeOptional<Cls>
  %3 = enum $FakeOptional<Cls>, #FakeOptional.Some!enumelt.1, %2 : $Cls
  cond_br undef, bb1(%3 : $FakeOptional<Cls>), bb4

bb4:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @dont_strip_phi_nodes_over_backedges_multibb4 : $@thin () -> () {
// CHECK: retain_value
// CHECK: release_value
sil @dont_strip_phi_nodes_over_backedges_multibb4 : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional<Cls>, #FakeOptional.None!enumelt
  br bb1(%0 : $FakeOptional<Cls>)

bb1(%1 : $FakeOptional<Cls>):
  br bb2

bb2:
  br bb3

bb3:
  %2 = alloc_ref $Cls
  retain_value %2 : $Cls
  release_value %1 : $FakeOptional<Cls>
  %3 = enum $FakeOptional<Cls>, #FakeOptional.Some!enumelt.1, %2 : $Cls
  cond_br undef, bb1(%3 : $FakeOptional<Cls>), bb4

bb4:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @dont_strip_phi_nodes_over_backedges_multibb5 : $@thin () -> () {
// CHECK: retain_value
// CHECK: release_value
sil @dont_strip_phi_nodes_over_backedges_multibb5 : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional<Cls>, #FakeOptional.None!enumelt
  br bb1(%0 : $FakeOptional<Cls>)

bb1(%1 : $FakeOptional<Cls>):
  %2 = alloc_ref $Cls
  retain_value %2 : $Cls
  br bb2

bb2:
  br bb3

bb3:
  release_value %1 : $FakeOptional<Cls>
  %3 = enum $FakeOptional<Cls>, #FakeOptional.Some!enumelt.1, %2 : $Cls
  cond_br undef, bb1(%3 : $FakeOptional<Cls>), bb4

bb4:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @strip_off_structs_tuples_tuple_extracts : $@thin (Builtin.NativeObject, (Builtin.Int32, Builtin.NativeObject, Builtin.Int32)) -> () {
// CHECK-NOT: retain_value
// CHECK-NOT: release_value
sil @strip_off_structs_tuples_tuple_extracts : $@thin (Builtin.NativeObject, (Builtin.Int32, Builtin.NativeObject, Builtin.Int32)) -> () {
bb0(%0 : $Builtin.NativeObject, %1 : $(Builtin.Int32, Builtin.NativeObject, Builtin.Int32)):
  %2 = integer_literal $Builtin.Int32, 0
  %3 = struct $S2(%2 : $Builtin.Int32, %0 : $Builtin.NativeObject, %2 : $Builtin.Int32)
  retain_value %3 : $S2
  %4 = tuple(%2 : $Builtin.Int32, %0 : $Builtin.NativeObject, %2 : $Builtin.Int32)
  release_value %4 : $(Builtin.Int32, Builtin.NativeObject, Builtin.Int32)
  retain_value %1 : $(Builtin.Int32, Builtin.NativeObject, Builtin.Int32)
  %5 = tuple_extract %1 : $(Builtin.Int32, Builtin.NativeObject, Builtin.Int32), 1
  release_value %5 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @strip_off_initopen_existential_ref : $@thin (C) -> () {
// CHECK-NOT: strong_retain
// CHECK-NOT: strong_release
// CHECK-NOT: retain_value
// CHECK-NOT: release_value
sil @strip_off_initopen_existential_ref : $@thin (C) -> () {
bb0(%0 : $C):
  %1 = init_existential_ref %0 : $C : $C, $AnyObject
  %2 = open_existential_ref %1 : $AnyObject to $@opened("A2E21C52-6089-11E4-9866-3C0754723233") AnyObject
  strong_retain %0 : $C
  release_value %2 : $@opened("A2E21C52-6089-11E4-9866-3C0754723233") AnyObject
  %3 = tuple()
  return %3 : $()
}

// CHECK-LABEL: sil @strip_off_bridge_object
// CHECK-NOT: strong_retain
// CHECK-NOT: strong_release

sil @strip_off_bridge_object : $@thin (Builtin.BridgeObject, C) -> () {
bb0(%0 : $Builtin.BridgeObject, %5 : $C):
  %1 = bridge_object_to_ref %0 : $Builtin.BridgeObject to $C
  strong_retain %1 : $C
  strong_release %0 : $Builtin.BridgeObject
  %4 = integer_literal $Builtin.Word, 0
  %2 = ref_to_bridge_object %5 : $C, %4 : $Builtin.Word
  strong_retain %5 : $C
  strong_release %2 : $Builtin.BridgeObject
  %3 = tuple()
  return %3 : $()
}
