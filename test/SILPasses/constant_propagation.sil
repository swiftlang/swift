// RUN: %sil-opt %s -constant-propagation | FileCheck %s
import Builtin
import swift

// Compute an expression using a chain of arithmetic with overflow instructions: 2 * (2 + 3) - 3
sil @fold_arithmetic_with_overflow : $@thin () -> Builtin.Int64 {
bb0:
 %1 = builtin_function_ref #Builtin.int_sadd_with_overflow_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %2 = builtin_function_ref #Builtin.int_smul_with_overflow_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %3 = builtin_function_ref #Builtin.int_ssub_with_overflow_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %0 = integer_literal $Builtin.Int64, 2 
 %110 = integer_literal $Builtin.Int64, 3        
 %18 = apply %1(%0, %110) : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %19 = tuple_extract %18 : $(Builtin.Int64, Builtin.Int1), 0
 %20 = apply %2(%0, %19) : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %21 = tuple_extract %20 : $(Builtin.Int64, Builtin.Int1), 0
 %22 = apply %3(%21, %110) : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %23 = tuple_extract %22 : $(Builtin.Int64, Builtin.Int1), 0
 return %23 : $Builtin.Int64

// CHECK-LABEL: sil @fold_arithmetic_with_overflow
// CHECK-NOT: builtin_function_ref #Builtin.int_sadd_with_overflow_Int64
// CHECK-NOT: builtin_function_ref #Builtin.int_smul_with_overflow_Int64
// CHECK-NOT: builtin_function_ref #Builtin.int_ssub_with_overflow_Int64
// CHECK-NOT: integer_literal $Builtin.Int64, 2
// CHECK-NOT: integer_literal $Builtin.Int64, 3
// CHECK-NOT: integer_literal $Builtin.Int64, 0
// CHECK-NOT: apply
// CHECK: [[RES:%.*]] = integer_literal $Builtin.Int64, 7
// CHECK-NEXT: return [[RES:%.*]] : $Builtin.Int64
}

// Fold casts. (This test assumes that DCE does not run, otherwise the unreachable blocks will get removed.)
sil @fold_trunc : $@thin () -> Builtin.Int64 {
bb0:
 %0 = integer_literal $Builtin.Int128, 22
 %1 = builtin_function_ref #Builtin.trunc_Int128_Int64 : $@thin Builtin.Int128 -> Builtin.Int64
 %2 = apply %1(%0) : $@thin Builtin.Int128 -> Builtin.Int64
 br bb4(%2 : $Builtin.Int64)

bb1:
 %3 = integer_literal $Builtin.Int8, 23
 %4 = builtin_function_ref #Builtin.sext_Int8_Int64 : $@thin Builtin.Int8 -> Builtin.Int64
 %5 = apply %4(%3) : $@thin Builtin.Int8 -> Builtin.Int64
 br bb4(%5 : $Builtin.Int64)

bb2:
 %6 = integer_literal $Builtin.Int8, 24
 %7 = builtin_function_ref #Builtin.zext_Int8_Int64 : $@thin Builtin.Int8 -> Builtin.Int64
 %8 = apply %7(%6) : $@thin Builtin.Int8 -> Builtin.Int64
 br bb4(%8 : $Builtin.Int64)

bb4(%100 : $Builtin.Int64):
 return %100 : $Builtin.Int64
// CHECK-LABEL: sil @fold_trunc
// CHECK-NOT: integer_literal $Builtin.Int128, 22
// CHECK: integer_literal $Builtin.Int64, 22
// CHECK-NOT: integer_literal $Builtin.Int8, 23
// CHECK: integer_literal $Builtin.Int64, 23
// CHECK-NOT: integer_literal $Builtin.Int8, 24
// CHECK: integer_literal $Builtin.Int64, 24
}

sil @test_tuple_extract_folding : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 5
  %1 = integer_literal $Builtin.Int1, 0
  %2 = tuple (%0 : $Builtin.Int64, %1 : $Builtin.Int1)
  %3 = tuple_extract %2 : $(Builtin.Int64, Builtin.Int1), 0
  return %3 : $Builtin.Int64
// CHECK-LABEL: sil @test_tuple_extract_folding
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 5
// CHECK-NEXT: return %0 : $Builtin.Int64
// CHECK-NEXT: }
}

sil @test_struct_extract_folding_first : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 2
  %1 = struct $Int64 (%0 : $Builtin.Int64)
  %2 = struct_extract %1 : $Int64, #value
  return %2 : $Builtin.Int64
// CHECK-LABEL: sil @test_struct_extract_folding_first
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 2
// CHECK-NEXT: return %0 : $Builtin.Int64
// CHECK-NEXT: }
}

struct TwoValueStruct {
  var a : Builtin.Int64
  var b : Builtin.Int64
}

sil @test_struct_extract_folding_second : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 2
  %1 = integer_literal $Builtin.Int64, 20
  %2 = struct $TwoValueStruct (%0 : $Builtin.Int64, %1 : $Builtin.Int64)
  %3 = struct_extract %2 : $TwoValueStruct, #b
  return %3 : $Builtin.Int64
// CHECK-LABEL: sil @test_struct_extract_folding_second
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 20
// CHECK-NEXT: return %0 : $Builtin.Int64
// CHECK-NEXT: }
}

sil @test_struct_extract_folding_third : $() -> Bool {
bb0:
  %0 = integer_literal $Builtin.Int64, 200
  %a = integer_literal $Builtin.Int1, 1
  %1 = struct $Bool (%a : $Builtin.Int1)
  %2 = tuple (%0 : $Builtin.Int64, %1 : $Bool)
  %3 = tuple_extract %2 : $(Builtin.Int64, Bool), 1
  return %3 : $Bool

// CHECK-LABEL: sil @test_struct_extract_folding_third
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int1, -1
// CHECK-NEXT: %1 = struct $Bool
// CHECK-NEXT: return %1 : $Bool
// CHECK-NEXT: }
}

sil @testChainingCCP : $@thin () -> Builtin.Int1 {
bb0:
  %1 = builtin_function_ref #Builtin.trunc_Int64_Int1 : $@thin Builtin.Int64 -> Builtin.Int1
  %2 = integer_literal $Builtin.Int64, 0
  %3 = struct $Int64 (%2 : $Builtin.Int64)
  %4 = struct_extract %3 : $Int64, #value
  %5 = apply %1(%4) : $@thin Builtin.Int64 -> Builtin.Int1
  return %5 : $Builtin.Int1

// CHECK-LABEL: sil @testChainingCCP
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int1, 0
// CHECK-NEXT: return %0 : $Builtin.Int1
// CHECK-NEXT: }
}

sil @testDivision : $@thin () -> Builtin.Int8 {
bb0:
  %0 = builtin_function_ref #Builtin.sdiv_Int8 : $@thin (Builtin.Int8, Builtin.Int8) -> Builtin.Int8
  %1 = integer_literal $Builtin.Int8, 6
  %2 = integer_literal $Builtin.Int8, 3
  %3 = apply [transparent] %0(%1, %2) : $@thin (Builtin.Int8, Builtin.Int8) -> Builtin.Int8
  return %3 : $Builtin.Int8

// CHECK-LABEL: sil @testDivision
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int8, 2
// CHECK-NEXT: return %0 : $Builtin.Int8
// CHECK-NEXT: }
}

sil @testRem : $@thin () -> Builtin.Int64 {
bb0:
  %0 = builtin_function_ref #Builtin.urem_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  %1 = integer_literal $Builtin.Int64, 10
  %2 = integer_literal $Builtin.Int64, 2
  %3 = apply [transparent] %0(%1, %2) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  return %3 : $Builtin.Int64

// CHECK-LABEL: sil @testRem
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 0
// CHECK-NEXT: return %0 : $Builtin.Int64
// CHECK-NEXT: }
}

sil @testFoldingIntBinaryPredicates : $@thin () -> () {
bb0:
  %1 = integer_literal $Builtin.Int1, 1
  %2 = integer_literal $Builtin.Int1, 0
  %3 = builtin_function_ref #Builtin.cmp_eq_Int1 : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1
  %4 = apply %3(%1, %2) : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 
  %11 = integer_literal $Builtin.Int32, 21
  %12 = integer_literal $Builtin.Int32, 12
  %13 = builtin_function_ref #Builtin.cmp_ne_Int32 : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int1
  %14 = apply %13(%11, %12) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int1 
  %15 = builtin_function_ref #Builtin.cmp_sgt_Int32 : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int1
  %16 = apply %15(%12, %11) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int1 
  %17 = builtin_function_ref #Builtin.cmp_ult_Int32 : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int1
  %18 = apply %17(%12, %11) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int1 
  %5 = tuple ()
  return %5 : $()
// CHECK-LABEL: sil @testFoldingIntBinaryPredicates
// CHECK: bb
// CHECK-NEXT: integer_literal $Builtin.Int1, 0
// CHECK-NEXT: integer_literal $Builtin.Int1, -1
// CHECK-NEXT: integer_literal $Builtin.Int1, 0
// CHECK-NEXT: integer_literal $Builtin.Int1, -1
// CHECK-NEXT: tuple
// CHECK-NEXT: return
}

// fold_binary_bitwise
sil @fold_binary_bitwise : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 1          // users: %7, %6, %5
  %1 = integer_literal $Builtin.Int64, 0          // users: %7, %6, %5
  %2 = builtin_function_ref #Builtin.and_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // user: %5
  %3 = builtin_function_ref #Builtin.or_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // user: %6
  %4 = builtin_function_ref #Builtin.xor_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // user: %7
  %5 = apply %2(%0, %1) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  %6 = apply %3(%0, %1) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  %7 = apply %4(%0, %1) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // user: %8
  return %7 : $Builtin.Int64                      // id: %8

// CHECK-LABEL: sil @fold_binary_bitwise
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 0
// CHECK_NEXT: %1 = integer_literal $Builtin.Int64, 1
// CHECK_NEXT: %2 = integer_literal $Builtin.Int64, 1
// CHECK_NEXT: return %2 : $Builtin.Int64
}

// fold_shifts
sil @fold_shifts : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, -32        // users: %9, %8
  %1 = integer_literal $Builtin.Int64, 32         // users: %11, %10
  %2 = integer_literal $Builtin.Int64, 3          // users: %11, %10, %9, %8
  %3 = integer_literal $Builtin.Int64, 1          // user: %12
  %4 = integer_literal $Builtin.Int64, 5          // user: %12
  %5 = builtin_function_ref #Builtin.ashr_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // users: %10, %8
  %6 = builtin_function_ref #Builtin.lshr_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // users: %11, %9
  %7 = builtin_function_ref #Builtin.shl_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // user: %12
  %8 = apply %5(%0, %2) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  %9 = apply %6(%0, %2) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  %10 = apply %5(%1, %2) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  %11 = apply %6(%1, %2) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64
  %12 = apply %7(%3, %4) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64 // user: %13
  return %12 : $Builtin.Int64                     // id: %13

// CHECK-LABEL: sil @fold_shifts
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, -4
// CHECK-NEXT: %1 = integer_literal $Builtin.Int64, 2305843009213693948
// CHECK-NEXT: %2 = integer_literal $Builtin.Int64, 4
// CHECK-NEXT: %3 = integer_literal $Builtin.Int64, 4
// CHECK-NEXT: %4 = integer_literal $Builtin.Int64, 32
// CHECK-NEXT: return %4 : $Builtin.Int64
}

// fold_float_operations
sil @fold_float_operations : $@thin () -> Builtin.FPIEEE64 {
bb0:
  %4 = float_literal $Builtin.FPIEEE64, 0x402E4CCCCCCCCCCD // 15.15
  %11 = float_literal $Builtin.FPIEEE64, 0x400A666666666666 // 3.2999999999999998 // user: %12
  %0 = builtin_function_ref #Builtin.fadd_FPIEEE64 : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64 
  %1 = builtin_function_ref #Builtin.fdiv_FPIEEE64 : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64
  %2 = builtin_function_ref #Builtin.fsub_FPIEEE64 : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64
  %3 = builtin_function_ref #Builtin.fmul_FPIEEE64 : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64
  %8 = apply %0(%4, %11) : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64
  %9 = apply %1(%4, %11) : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64
  %10 = apply %2(%4, %11) : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64
  %13 = apply %3(%4, %11) : $@thin (Builtin.FPIEEE64, Builtin.FPIEEE64) -> Builtin.FPIEEE64
  return %13 : $Builtin.FPIEEE64                  

// CHECK-LABEL: sil @fold_float_operations
// CHECK: bb0:
// CHECK-NEXT: %0 = float_literal $Builtin.FPIEEE64, 0x4032733333333333
// CHECK-NEXT: %1 = float_literal $Builtin.FPIEEE64, 0x40125D1745D1745D
// CHECK-NEXT: %2 = float_literal $Builtin.FPIEEE64, 0x4027B33333333334
// CHECK-NEXT: %3 = float_literal $Builtin.FPIEEE64, 0x4048FF5C28F5C28F
// CHECK-NEXT: return %3 : $Builtin.FPIEEE64
}

