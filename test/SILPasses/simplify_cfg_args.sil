// RUN: %target-sil-opt %s -simplify-cfg | FileCheck %s
// RUN: %target-sil-opt %s -codemotion -simplify-cfg | FileCheck %s --check-prefix=CHECK_WITH_CODEMOTION

sil_stage raw

import Builtin
import Swift

sil_global private @globalinit_token11 : $Builtin.Word

sil_global private @globalinit_token120 : $Builtin.Word

sil @globalinit_func11 :  $@thin () -> ()

//CHECK: sil @a_method_to_simplify
sil @a_method_to_simplify : $@thin (Builtin.RawPointer, @owned Builtin.NativeObject, Builtin.Word) -> Builtin.RawPointer {
bb0(%0 : $Builtin.RawPointer, %1 : $Builtin.NativeObject, %2 : $Builtin.Word):
  %4 = struct $UnsafeMutablePointer<UInt8> (%0 : $Builtin.RawPointer) // user: %37
  strong_retain %1 : $Builtin.NativeObject       // id: %5
  strong_retain %1 : $Builtin.NativeObject       // id: %6
  strong_release %1 : $Builtin.NativeObject      // id: %7
  %8 = integer_literal $Builtin.Int1, 0           // user: %23
  %10 = global_addr @globalinit_token11 : $*Builtin.Word // user: %11
  %11 = address_to_pointer %10 : $*Builtin.Word to $Builtin.RawPointer // user: %14
  %12 = function_ref @globalinit_func11 : $@thin () -> () // users: %26, %13
  %13 = thin_to_thick_function %12 : $@thin () -> () to $@callee_owned () -> () // user: %14
  %14 = builtin "once"(%11 : $Builtin.RawPointer, %13 : $@callee_owned () -> ()) : $()
  %15 = alloc_stack $Int                          // users: %38, %40, %41
  %16 = struct_element_addr %15#1 : $*Int, #Int.value // users: %28, %17
  %17 = load %16 : $*Builtin.Word                 // user: %20
  %18 = integer_literal $Builtin.Word, -1         // user: %20
  %20 = builtin "xor_Word"(%17 : $Builtin.Word, %18 : $Builtin.Word) : $Builtin.Word // user: %22
  %22 = builtin "and_Word"(%2 : $Builtin.Word, %20 : $Builtin.Word) : $Builtin.Word // users: %30, %23
//CHECK-NOT: cond_br
  cond_br %8, bb1, bb2(%22 : $Builtin.Word)       // id: %23

bb1:                                              // Preds: bb0
  %24 = global_addr @globalinit_token11 : $*Builtin.Word // user: %25
  %25 = address_to_pointer %24 : $*Builtin.Word to $Builtin.RawPointer // user: %27
  %26 = thin_to_thick_function %12 : $@thin () -> () to $@callee_owned () -> () // user: %27
  %27 = builtin "once"(%25 : $Builtin.RawPointer, %26 : $@callee_owned () -> ()) : $()
  %28 = load %16 : $*Builtin.Word                 // user: %30
// CHECK: [[VAR_21:%[0-9]+]] = builtin "and_Word"
  %30 = builtin "or_Word"(%22 : $Builtin.Word, %28 : $Builtin.Word) : $Builtin.Word // user: %31
  br bb2(%30 : $Builtin.Word)                     // id: %31

bb2(%32 : $Builtin.Word):                         // Preds: bb0 bb1
//CHECK-NEXT: tuple ()
  %33 = tuple ()                                  // user: %34
  br bb3(%33 : $())                               // id: %34

bb3(%35 : $()):                                   // Preds: bb2
// CHECK-NEXT: struct $Int ([[VAR_21]] : $Builtin.Word)
  %36 = struct $Int (%32 : $Builtin.Word)         // user: %37
  strong_retain %1 : $Builtin.NativeObject       // id: %38
  strong_release %1 : $Builtin.NativeObject      // id: %39
  strong_release %1 : $Builtin.NativeObject      // id: %40
  dealloc_stack %15#0 : $*@local_storage Int      // id: %41
// CHECK: return
  return %0 : $Builtin.RawPointer
}


//CHECK-LABEL: remove_dead_args
//CHECK-NOT: br bb2([[VAR_21:%[0-9]+]] : $Bool)
//CHECK: bb2:
//CHECK-NEXT: tuple ()
//CHECK-NEXT: return
sil @remove_dead_args: $@thin (Int) -> () {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 37
  %3 = struct_extract %0 : $Int, #Int.value
  %4 = builtin "cmp_ne_Word"(%3 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %5 = struct $Bool (%4 : $Builtin.Int1)
  cond_br %4, bb1, bb3

bb1:
  %7 = integer_literal $Builtin.Word, 42
  %8 = builtin "cmp_ne_Word"(%3 : $Builtin.Word, %7 : $Builtin.Word) : $Builtin.Int1
  %9 = struct $Bool (%8 : $Builtin.Int1)
  br bb2(%9 : $Bool)

// Remove this ARG.
bb2(%11 : $Bool):                                 // Preds: bb1 bb3
  %12 = tuple ()                                  // user: %13
  return %12 : $()                                // id: %13

bb3:                                              // Preds: bb0
  br bb2(%5 : $Bool)                              // id: %14
}

class A {}

//CHECK-LABEL: no_remove_mandatory_dead_args
//CHECK: checked_cast_br {{%.*}} : $AnyObject to $A, bb1
//CHECK-NOT: bb1
//CHECK: bb1([[VAR:%[0-9]+]] : $A)
//CHECK-NOT: [[VAR]]
//CHECK: return
sil @no_remove_mandatory_dead_args : $@thin (@owned AnyObject) -> Int {
bb0(%0 : $AnyObject):
  checked_cast_br %0 : $AnyObject to $A, bb1, bb2 // id: %3

bb1(%1 : $A):
  %2 = integer_literal $Builtin.Word, 1
  br bb3(%2 : $Builtin.Word)

bb2:
  %3 = integer_literal $Builtin.Word, 0
  br bb3(%3 : $Builtin.Word)

bb3(%4 : $Builtin.Word):
  %5 = struct $Int (%4 : $Builtin.Word)
  strong_release %0 : $AnyObject
  return %5 : $Int
}

enum X {
  case A
  case B((Int, Int))
  case C(Int)
}

// CHECK-LABEL: simplify_switch_include_args
sil @simplify_switch_include_args : $@thin (Int, Int) -> Int {
bb0(%0 : $Int, %1 : $Int):
// CHECK: return %0 : $Int
  %2 = tuple (%0 : $Int, %1 : $Int)               // user: %3
  %3 = enum $X, #X.B!enumelt.1, %2 : $(Int, Int)  // user: %4
  switch_enum %3 : $X, case #X.A!enumelt: bb1, case #X.B!enumelt.1: bb3, case #X.C!enumelt.1: bb5 // id: %4

bb1:                                              // Preds: bb0
  br bb2                                          // id: %5

bb2:                                              // Preds: bb1
  %6 = integer_literal $Builtin.Word, 0           // user: %7
  %7 = struct $Int (%6 : $Builtin.Word)           // user: %8
  br bb7(%7 : $Int)                               // id: %8

bb3(%9 : $(Int, Int)):                            // Preds: bb0
  %10 = tuple_extract %9 : $(Int, Int), 0         // user: %12
  br bb4                                          // id: %11

bb4:                                              // Preds: bb3
  br bb7(%10 : $Int)                              // id: %12

bb5(%13 : $Int):                                  // Preds: bb0
  br bb6                                          // id: %14

bb6:                                              // Preds: bb5
  br bb7(%13 : $Int)                              // id: %15

bb7(%16 : $Int):                                  // Preds: bb2 bb4 bb6
  return %16 : $Int                               // id: %17
}

// CHECK-LABEL: simplify_switch_dont_include_args
sil @simplify_switch_dont_include_args : $@thin (Int, Int) -> Int {
bb0(%0 : $Int, %1 : $Int):
  %2 = tuple (%0 : $Int, %1 : $Int)               // user: %3
  %3 = enum $X, #X.B!enumelt.1, %2 : $(Int, Int)  // user: %4
  switch_enum %3 : $X, case #X.A!enumelt: bb1, case #X.B!enumelt.1: bb3, case #X.C!enumelt.1: bb5 // id: %4

bb1:                                              // Preds: bb0
  br bb2                                          // id: %5

bb2:                                              // Preds: bb1
  %6 = integer_literal $Builtin.Word, 0           // user: %7
  %7 = struct $Int (%6 : $Builtin.Word)           // user: %8
  br bb5

bb3(%9 : $(Int, Int)):                            // Preds: bb0
  %10 = tuple_extract %9 : $(Int, Int), 0         // user: %12
  br bb4                                          // id: %11

bb4:                                              // Preds: bb3
  br bb5                                          // id: %12

bb5:                                              // Preds: bb0
  return %0 : $Int                                // id: %17
}

// CHECK-LABEL: simplify_switch_dont_include_args_nested
sil @simplify_switch_dont_include_args_nested : $@thin (Int, Int, X) -> Int {
// CHECK: bb0
// CHECK: switch_enum %2
bb0(%0 : $Int, %1 : $Int, %2 : $X):
  switch_enum %2 : $X, case #X.A!enumelt: bb3, case #X.B!enumelt.1: bb1, case #X.C!enumelt.1: bb5

// CHECK: bb1
// CHECK-NOT: switch_enum
bb1(%12: $(Int, Int)):
  switch_enum %2 : $X, case #X.A!enumelt: bb6, case #X.B!enumelt.1: bb7, case #X.C!enumelt.1: bb8

bb2:
  %6 = integer_literal $Builtin.Word, 0
  %7 = struct $Int (%6 : $Builtin.Word)
  br bb5(%7 : $Int)

bb3:
  %9 = integer_literal $Builtin.Word, 1
  %10 = struct $Int (%9 : $Builtin.Word)
  br bb4(%10 : $Int)

bb4(%16 : $Int):
  br bb5(%16 : $Int)

bb5(%19 : $Int):
  return %19 : $Int

bb6:
  %14 = integer_literal $Builtin.Word, 2
  %15 = struct $Int (%14 : $Builtin.Word)
  br bb5(%15 : $Int)

bb7:
  %17 = integer_literal $Builtin.Word, 3
  %18 = struct $Int (%17 : $Builtin.Word)
  br bb5(%18 : $Int)

bb8(%20 : $Int):
  br bb5(%20 : $Int)
}

// CHECK-LABEL: simplify_switch_wrong_args
sil @simplify_switch_wrong_args : $@thin (Int, Int, X, Builtin.Int1) -> Int {
// CHECK: bb0
// CHECK: switch_enum %2
bb0(%0 : $Int, %1 : $Int, %2 : $X, %24 : $Builtin.Int1):
  switch_enum %2 : $X, case #X.A!enumelt: bb3, case #X.B!enumelt.1: bb9, case #X.C!enumelt.1: bb5

bb9(%21 : $(Int, Int)):
  %22 = tuple_extract %21 : $(Int, Int), 1
  cond_br %24, bb1(%22 : $Int), bb5(%22 : $Int)

// CHECK: bb1
// CHECK-NOT: switch_enum
bb1(%12: $Int):
  switch_enum %2 : $X, case #X.A!enumelt: bb6, case #X.B!enumelt.1: bb7, case #X.C!enumelt.1: bb8

bb2:
  %6 = integer_literal $Builtin.Word, 0
  %7 = struct $Int (%6 : $Builtin.Word)
  br bb5(%7 : $Int)

bb3:
  %9 = integer_literal $Builtin.Word, 1
  %10 = struct $Int (%9 : $Builtin.Word)
  br bb4(%10 : $Int)

bb4(%16 : $Int):
  br bb5(%16 : $Int)

bb5(%19 : $Int):
  return %19 : $Int

bb6:
  %14 = integer_literal $Builtin.Word, 2
  %15 = struct $Int (%14 : $Builtin.Word)
  br bb5(%15 : $Int)

bb7(%23 : $(Int, Int)):
  %17 = tuple_extract %21 : $(Int, Int), 0
  br bb5(%17 : $Int)

bb8(%20 : $Int):
  br bb5(%20 : $Int)
}

enum EA {
  case cA
  case cB(Int)
  case cC(Float)
}


// CHECK-LABEL: fold_unreachable_terminators1
sil @fold_unreachable_terminators1 : $@thin (EA) -> () {
// CHECK: bb0
// CHECK-NEXT: [[VAL:%[a-zA-Z0-9]+]] = tuple ()
// CHECK-NEXT: return [[VAL]]
bb0(%0 : $EA):
  switch_enum %0 : $EA, case #EA.cA!enumelt: bb1, case #EA.cB!enumelt.1: bb3, case #EA.cC!enumelt.1: bb5

bb1:
  br bb2

bb2:
  br bb7

bb3(%6 : $Int):
  br bb4

bb4:
  unreachable

bb5(%10 : $Float):
  br bb6

bb6:
  unreachable

bb7:
  %14 = tuple ()
  return %14 : $()
}

// CHECK-LABEL: fold_unreachable_terminators2
sil @fold_unreachable_terminators2 : $@thin (EA) -> Int {
// CHECK: bb0
bb0(%0 : $EA):
// CHECK-NEXT:  [[VAL:%[a-zA-Z0-9]+]] = unchecked_enum_data %0 : $EA, #EA.cB!enumelt.1 // user: %2
// CHECK-NEXT: return [[VAL]] : $Int
  switch_enum %0 : $EA, case #EA.cA!enumelt: bb1, case #EA.cB!enumelt.1: bb3, case #EA.cC!enumelt.1: bb5

bb1:
  br bb2

bb2:
  unreachable

bb3(%6 : $Int):
  br bb4

bb4:
  return %6 : $Int

bb5(%10 : $Float):
  br bb6

bb6:
  unreachable
}

// CHECK-LABEL: simplify_switch_to_select_enum
sil @simplify_switch_to_select_enum : $@thin (X) -> Bool {
bb0(%0 : $X):
// CHECK: bb0
// CHECK: [[TRUE:%.*]] = integer_literal {{.*}} -1
// CHECK: integer_literal {{.*}} 0
// CHECK: [[FALSE:%.*]] = integer_literal {{.*}} 0
// CHECK: [[VAL:%[a-zA-Z0-9]+]] = select_enum %0 : $X, case #X.A!enumelt: [[TRUE]], default [[FALSE]]
  %2 = integer_literal $Builtin.Int1, 0
  switch_enum %0 : $X, case #X.A!enumelt: bb1, case #X.B!enumelt.1: bb2, case #X.C!enumelt.1: bb3

bb1:                                              // Preds: bb0
  %10 = integer_literal $Builtin.Int1, -1
  br bb4(%10 : $Builtin.Int1)

bb2:                                              // Preds: bb0
  br bb4(%2 : $Builtin.Int1)

bb3:                                              // Preds: bb0
  br bb4(%2 : $Builtin.Int1)

bb4(%20 : $Builtin.Int1):                         // Preds: bb1 bb2 bb3
// CHECK: bb4
// CHECK: [[RETVAL:%[a-zA-Z0-9]+]] = struct $Bool ([[VAL]] : $Builtin.Int1)
// CHECK-NEXT: return [[RETVAL]] : $Bool
  %11 = struct $Bool (%20 : $Builtin.Int1)
  return %11 : $Bool
}

enum E {
  case Nope, Yup(Builtin.Int1)
}

// CHECK-LABEL: sil @simplify_switch_enum_pred_no_arg
sil @simplify_switch_enum_pred_no_arg : $@thin (E) -> Builtin.Int1 {
bb0(%0 : $E):
// CHECK-LABEL: bb0
// CHECK: switch_enum %0 : $E, case #E.Nope!enumelt: bb1, case #E.Yup!enumelt.1: bb2
  switch_enum %0 : $E, case #E.Nope!enumelt: bb1, case #E.Yup!enumelt.1: bb2

bb1:
  %1 = integer_literal $Builtin.Int1, -1
  br bb4(%1 : $Builtin.Int1)

bb2:
// CHECK: unchecked_enum_data %0 : $E, #E.Yup!enumelt.1
// CHECK-NOT: switch_enum
// CHECK: return
  switch_enum %0 : $E, case #E.Yup!enumelt.1: bb4, case #E.Nope!enumelt: bb3

bb3:
  %2 = integer_literal $Builtin.Int1, 0
  br bb4(%2 : $Builtin.Int1)

bb4(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

// CHECK-LABEL: sil @same_destination_unused_arg
sil @same_destination_unused_arg : $@thin (Optional<Int>) -> Optional<Int> {
bb0(%0 : $Optional<Int>):
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
// CHECK: select_enum
// CHECK-NEXT: return
  %1 = select_enum %0 : $Optional<Int>, case #Optional.Some!enumelt.1: %t, default %f : $Builtin.Int1
  cond_br %1, bb1(%0 : $Optional<Int>), bb2(%0 : $Optional<Int>)

bb1(%2 : $Optional<Int>):
  br bb2(%2 : $Optional<Int>)

bb2(%3 : $Optional<Int>):
  return %0 : $Optional<Int>
}

public enum Numbers {
  case First, Second, Third, Fourth, Fifth
  //var hashValue: Int { get }
}
    

// Check that one of the switch_enum instructions can be
// converted into select_enum instructions, even though
// the destination block is used as a target also by 
// another switch_enum instruction

// CHECK_WITH_CODEMOTION-LABEL: sil @FormSelectEnumFromTwoSelectSwitches
// CHECK_WITH_CODEMOTION: switch_enum %0 : $Numbers
// CHECK_WITH_CODEMOTION-NOT: switch_enum
// CHECK_WITH_CODEMOTION: select_enum
// CHECK_WITH_CODEMOTION: return
sil @FormSelectEnumFromTwoSelectSwitches : $@thin (Numbers) -> Int {
bb0(%0 : $Numbers):
  debug_value %0 : $Numbers  // let e             // id: %1
  switch_enum %0 : $Numbers, case #Numbers.First!enumelt: bb1, case #Numbers.Second!enumelt: bb3, case #Numbers.Third!enumelt: bb4, default bb6 // id: %2

bb1:                                              // Preds: bb0
  br bb2                                          // id: %3

bb2:                                              // Preds: bb1
  %4 = integer_literal $Builtin.Word, 42          // user: %5
  %5 = struct $Int (%4 : $Builtin.Word)           // user: %6
  br bb20(%5 : $Int)                              // id: %6

bb3:                                              // Preds: bb0
  br bb5                                          // id: %7

bb4:                                              // Preds: bb0
  br bb5                                          // id: %8

bb5:                                              // Preds: bb3 bb4
  %9 = integer_literal $Builtin.Word, 24          // user: %10
  %10 = struct $Int (%9 : $Builtin.Word)          // user: %11
  br bb20(%10 : $Int)                             // id: %11

bb6:                                              // Preds: bb0
  br bb7                                          // id: %12

bb7:                                              // Preds: bb6
  br bb8                                          // id: %13

bb8:                                              // Preds: bb7
  br bb9                                          // id: %14

bb9:                                              // Preds: bb8
  switch_enum %0 : $Numbers, case #Numbers.First!enumelt: bb10, case #Numbers.Second!enumelt: bb12, case #Numbers.Third!enumelt: bb13, case #Numbers.Fourth!enumelt: bb15, default bb17 // id: %15

bb10:                                             // Preds: bb9
  br bb11                                         // id: %16

bb11:                                             // Preds: bb10
  %17 = integer_literal $Builtin.Word, 42         // user: %18
  %18 = struct $Int (%17 : $Builtin.Word)         // user: %19
  br bb20(%18 : $Int)                             // id: %19

bb12:                                             // Preds: bb9
  br bb14                                         // id: %20

bb13:                                             // Preds: bb9
  br bb14                                         // id: %21

bb14:                                             // Preds: bb12 bb13
  %22 = integer_literal $Builtin.Word, 24         // user: %23
  %23 = struct $Int (%22 : $Builtin.Word)         // user: %24
  br bb20(%23 : $Int)                             // id: %24

bb15:                                             // Preds: bb9
  br bb16                                         // id: %25

bb16:                                             // Preds: bb15
  %26 = integer_literal $Builtin.Word, 100        // user: %27
  %27 = struct $Int (%26 : $Builtin.Word)         // user: %28
  br bb20(%27 : $Int)                             // id: %28

bb17:                                             // Preds: bb9
  br bb18                                         // id: %29

bb18:                                             // Preds: bb17
  br bb19                                         // id: %30

bb19:                                             // Preds: bb18
  %31 = integer_literal $Builtin.Word, 100        // user: %32
  %32 = struct $Int (%31 : $Builtin.Word)         // user: %33
  br bb20(%32 : $Int)                             // id: %33

bb20(%34 : $Int):                                 // Preds: bb2 bb5 bb11 bb14 bb16 bb19
  return %34 : $Int                               // id: %35
}

// CHECK_WITH_CODEMOTION-LABEL: sil @FormSelectEnumIntResult
// CHECK_WITH_CODEMOTION-NOT: switch_enum
// CHECK_WITH_CODEMOTION: select_enum
// CHECK_WITH_CODEMOTION: return
sil @FormSelectEnumIntResult : $@thin (Numbers) -> Int {
bb0(%0 : $Numbers):
  debug_value %0 : $Numbers  // let e             // id: %1
  switch_enum %0 : $Numbers, case #Numbers.First!enumelt: bb1, case #Numbers.Second!enumelt: bb3, case #Numbers.Third!enumelt: bb4, case #Numbers.Fourth!enumelt: bb6, default bb8 // id: %2

bb1:                                              // Preds: bb0
  br bb2                                          // id: %3

bb2:                                              // Preds: bb1
  %4 = integer_literal $Builtin.Word, 42          // user: %5
  %5 = struct $Int (%4 : $Builtin.Word)           // user: %6
  br bb11(%5 : $Int)                              // id: %6

bb3:                                              // Preds: bb0
  br bb5                                          // id: %7

bb4:                                              // Preds: bb0
  br bb5                                          // id: %8

bb5:                                              // Preds: bb3 bb4
  %9 = integer_literal $Builtin.Word, 24          // user: %10
  %10 = struct $Int (%9 : $Builtin.Word)          // user: %11
  br bb11(%10 : $Int)                             // id: %11

bb6:                                              // Preds: bb0
  br bb7                                          // id: %12

bb7:                                              // Preds: bb6
  %13 = integer_literal $Builtin.Word, 100        // user: %14
  %14 = struct $Int (%13 : $Builtin.Word)         // user: %15
  br bb11(%14 : $Int)                             // id: %15

bb8:                                              // Preds: bb0
  br bb9                                          // id: %16

bb9:                                              // Preds: bb8
  br bb10                                         // id: %17

bb10:                                             // Preds: bb9
  %18 = integer_literal $Builtin.Word, 100        // user: %19
  %19 = struct $Int (%18 : $Builtin.Word)         // user: %20
  br bb11(%19 : $Int)                             // id: %20

bb11(%21 : $Int):                                 // Preds: bb2 bb5 bb7 bb10
  return %21 : $Int                               // id: %22
}

// CHECK_WITH_CODEMOTION-LABEL: sil @FormSelectEnumBoolResult
// CHECK_WITH_CODEMOTION-NOT: switch_enum
// CHECK_WITH_CODEMOTION: select_enum
// CHECK_WITH_CODEMOTION: return
sil @FormSelectEnumBoolResult : $@thin (Numbers) -> Bool {
bb0(%0 : $Numbers):
  debug_value %0 : $Numbers  // let e             // id: %1
  switch_enum %0 : $Numbers, case #Numbers.First!enumelt: bb1, case #Numbers.Second!enumelt: bb3, case #Numbers.Third!enumelt: bb4, default bb6 // id: %2

bb1:                                              // Preds: bb0
  br bb2                                          // id: %3

bb2:                                              // Preds: bb1
  %4 = integer_literal $Builtin.Int1, -1          // user: %5
  %5 = struct $Bool (%4 : $Builtin.Int1)          // user: %6
  br bb9(%5 : $Bool)                              // id: %6

bb3:                                              // Preds: bb0
  br bb5                                          // id: %7

bb4:                                              // Preds: bb0
  br bb5                                          // id: %8

bb5:                                              // Preds: bb3 bb4
  %9 = integer_literal $Builtin.Int1, 0           // user: %10
  %10 = struct $Bool (%9 : $Builtin.Int1)         // user: %11
  br bb9(%10 : $Bool)                             // id: %11

bb6:                                              // Preds: bb0
  br bb7                                          // id: %12

bb7:                                              // Preds: bb6
  br bb8                                          // id: %13

bb8:                                              // Preds: bb7
  %14 = integer_literal $Builtin.Int1, -1         // user: %15
  %15 = struct $Bool (%14 : $Builtin.Int1)        // user: %16
  br bb9(%15 : $Bool)                             // id: %16

bb9(%17 : $Bool):                                 // Preds: bb2 bb5 bb8
  return %17 : $Bool                              // id: %18
}

// CHECK_WITH_CODEMOTION-LABEL: sil @DontFormSelectEnumBoolResult
// CHECK_WITH_CODEMOTION: switch_enum
// CHECK_WITH_CODEMOTION-NOT: select_enum
// CHECK_WITH_CODEMOTION: return
sil @DontFormSelectEnumBoolResult : $@thin (Numbers, Bool) -> Bool {
bb0(%0 : $Numbers, %1 : $Bool):
  debug_value %0 : $Numbers  // let e             // id: %2
  debug_value %1 : $Bool  // let b                // id: %3
  switch_enum %0 : $Numbers, case #Numbers.First!enumelt: bb1, case #Numbers.Second!enumelt: bb3, case #Numbers.Third!enumelt: bb4, default bb6 // id: %4

bb1:                                              // Preds: bb0
  br bb2                                          // id: %5

bb2:                                              // Preds: bb1
  %6 = integer_literal $Builtin.Int1, -1          // user: %7
  %7 = struct $Bool (%6 : $Builtin.Int1)          // user: %8
  br bb10(%7 : $Bool)                             // id: %8

bb3:                                              // Preds: bb0
  br bb5                                          // id: %9

bb4:                                              // Preds: bb0
  br bb5                                          // id: %10

bb5:                                              // Preds: bb3 bb4
  %11 = integer_literal $Builtin.Int1, 0          // user: %12
  %12 = struct $Bool (%11 : $Builtin.Int1)        // user: %13
  br bb10(%12 : $Bool)                            // id: %13

bb6:                                              // Preds: bb0
  br bb7                                          // id: %14

bb7:                                              // Preds: bb6
  br bb8                                          // id: %15

bb8:                                              // Preds: bb7
  br bb9                                          // id: %16

bb9:                                              // Preds: bb8
  br bb10(%1 : $Bool)                             // id: %17

bb10(%18 : $Bool):                                // Preds: bb2 bb5 bb9
  return %18 : $Bool                              // id: %19
}

