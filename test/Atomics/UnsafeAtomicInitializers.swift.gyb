// RUN: %empty-directory(%t)
// RUN: %gyb -DCMAKE_SIZEOF_VOID_P=%target-ptrsize %s -o %t/UnsafeAtomicInitializers.swift
// RUN: %line-directive %t/UnsafeAtomicInitializers.swift -- %target-swift-frontend -typecheck -verify %t/UnsafeAtomicInitializers.swift

%{
  types = [
    # id        type      initial
    ("Int",     "Int",    "0"),
    ("Int64",   "Int64",  "0"),
    ("Int32",   "Int32",  "0"),
    ("Int16",   "Int16",  "0"),
    ("Int8",    "Int8",   "0"),
    ("UInt",    "UInt",   "0"),
    ("UInt64",  "UInt64", "0"),
    ("UInt32",  "UInt32", "0"),
    ("UInt16",  "UInt16", "0"),
    ("UInt8",   "UInt8",  "0"),

    # id             type                          initial
    ("URP",          "UnsafeRawPointer",           "UnsafeRawPointer(UnsafeMutableRawPointer.allocate(byteCount: 8, alignment: 8))"),
    ("UP",           "UnsafePointer<Bar>",         "UnsafePointer(UnsafeMutablePointer<Bar>.allocate(capacity: 1))"),
    ("UMRP",         "UnsafeMutableRawPointer",    ".allocate(byteCount: 8, alignment: 8)"),
    ("UMP",          "UnsafeMutablePointer<Bar>",  ".allocate(capacity: 1)"),
    ("Unmanaged",    "Unmanaged<Foo>",             "Unmanaged.passRetained(Foo())"),

    # id             type                          initial
    ("URPOpt",       "UnsafeRawPointer?",          "nil"),
    ("UPOpt",        "UnsafePointer<Bar>?",        "nil"),
    ("UMRPOpt",      "UnsafeMutableRawPointer?",   "nil"),
    ("UMPOpt",       "UnsafeMutablePointer<Bar>?", "nil"),
    ("UnmanagedOpt", "Unmanaged<Foo>?",            "nil"),
  ]
}%

import Atomics

class Foo {
  var value = 0
}
struct Bar {
  var value = 0
}

% for (id, type, initial) in types:
@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_${id}() -> UnsafeAtomic<${type}> {
  var storage = UnsafeAtomic<${type}>.Storage(${initial})
  let atomic = UnsafeAtomic<${type}>(at: &storage) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'UnsafeAtomic<${type}>.Storage' to 'UnsafeMutablePointer<UnsafeAtomic<${type}>.Storage>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}
% end

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_UnsafeAtomicLazyReference() -> UnsafeAtomicLazyReference<Foo> {
  var value = UnsafeAtomicLazyReference<Foo>.Storage()
  let atomic = UnsafeAtomicLazyReference(at: &value) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'UnsafeAtomicLazyReference<Foo>.Storage' to 'UnsafeMutablePointer<UnsafeAtomicLazyReference<Foo>.Storage>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
class BrokenAtomicCounter { // THIS IS BROKEN; DO NOT USE
  private var _storage = UnsafeAtomic<Int>.Storage(0)
  private var _value: UnsafeAtomic<Int>?

  init() {
    // This escapes the ephemeral pointer generated by the inout expression,
    // so it leads to undefined behavior when the pointer gets dereferenced
    // in the atomic operations below. DO NOT DO THIS.
    _value = UnsafeAtomic(at: &_storage) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
    // expected-note@-1 {{implicit argument conversion from 'UnsafeAtomic<Int>.Storage' to 'UnsafeMutablePointer<UnsafeAtomic<Int>.Storage>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
    // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  }

  func increment() {
    _value!.wrappingIncrement(by: 1, ordering: .relaxed)
  }

  func get() -> Int {
    _value!.load(ordering: .relaxed)
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
struct AtomicCounter {
  typealias Value = Int
  typealias Header = UnsafeAtomic<Value>.Storage

  class Buffer: ManagedBuffer<Header, Void> {
    deinit {
      withUnsafeMutablePointerToHeader { header in
        _ = header.pointee.dispose()
      }
    }
  }

  let buffer: Buffer

  init() {
    buffer = Buffer.create(minimumCapacity: 0) { _ in
      Header(0)
    } as! Buffer
  }

  private func _withAtomicPointer<R>(
    _ body: (UnsafeAtomic<Int>) throws -> R
  ) rethrows -> R {
    try buffer.withUnsafeMutablePointerToHeader { header in
      try body(UnsafeAtomic<Int>(at: header))
    }
  }

  func increment() {
    _withAtomicPointer { $0.wrappingIncrement(ordering: .relaxed) }
  }

  func load() -> Int {
    _withAtomicPointer { $0.load(ordering: .relaxed) }
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
struct AtomicUnmanagedRef<Instance: AnyObject> {
  typealias Value = Unmanaged<Instance>?
  typealias Header = UnsafeAtomic<Value>.Storage

  class Buffer: ManagedBuffer<Header, Void> {
    deinit {
      withUnsafeMutablePointerToHeader { header in
        _ = header.pointee.dispose()
      }
    }
  }

  let buffer: Buffer

  init() {
    buffer = Buffer.create(minimumCapacity: 0) { _ in
      Header(nil)
    } as! Buffer
  }

  private func _withAtomicPointer<R>(
    _ body: (UnsafeAtomic<Value>) throws -> R
  ) rethrows -> R {
    try buffer.withUnsafeMutablePointerToHeader { header in
      try body(UnsafeAtomic<Value>(at: header))
    }
  }

  func store(_ desired: Value) {
    _withAtomicPointer { $0.store(desired, ordering: .sequentiallyConsistent) }
  }

  func load() -> Value {
    _withAtomicPointer { $0.load(ordering: .sequentiallyConsistent) }
  }
}
