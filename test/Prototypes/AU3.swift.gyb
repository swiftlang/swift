//===--- AU3.swift.gyb ----------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %line-directive %t/out.swift -- %target-build-swift %t/out.swift -o %t/a.out -Onone
// RUN: %line-directive %t/out.swift -- %target-run %t/a.out
// REQUIRES: executable_test

%{
  import gyb
}%

import StdlibUnittest

//===--- Unicode ----------------------------------------------------------===//
/// Collections of `Character` that are also `_UnicodeContent`.
public protocol Unicode : BidirectionalCollection
// where Iterator.Element == Character
{
  // poor man's constraint on Iterator.Element
  subscript(i: Index) -> Character { get }
  
  associatedtype Content : _UnicodeContent
  var content: Content { get }
}

class UnicodeContentBox : FactoryInitializable {
  var utf16: AnyUInt16UnicodeView { fatalError("override me!") }
  var unicodeScalars: AnyUnicodeScalarUnicodeView { fatalError("override me!") }
  var fccNormalizedUTF16: AnyUInt16UnicodeView { fatalError("override me!") }
#if false
  var utf32: AnyUInt32UnicodeView { fatalError("override me!") }
#endif
  
#if false
  // FIXME: Can this be Random Access?  If all encodings use a single code unit
  // per ASCII character and can statelessly identify a code unit that
  // represents ASCII, then yes.  Look into, e.g. shift-JIS.
  var extendedASCII: UnicodeBidirectionalUInt32 { fatalError("override me!") }
#endif
  var characters: AnyCharacterUnicodeView { fatalError("override me!") }
  var isKnownLatin1: Bool { fatalError("override me!") }
  var isKnownASCII: Bool { fatalError("override me!") }
  var isKnownFCCNormalized: Bool { fatalError("override me!") }
  var isKnownFCDForm: Bool { fatalError("override me!") }
  var isKnownNFDNormalized: Bool { fatalError("override me!") }
  var isKnownNFCNormalized: Bool { fatalError("override me!") }

  func isLatin1() -> Bool  { fatalError("override me!") }
  func isASCII() -> Bool { fatalError("override me!") }

  class Instance<Base: _UnicodeContent> : UnicodeContentBox
  where Base.UTF16View.Iterator.Element == UTF16.CodeUnit,
  Base.UnicodeScalarView.Iterator.Element == UnicodeScalar
  {
    var base: Base
    
    override var utf16: AnyUInt16UnicodeView {
      return AnyUInt16UnicodeView(base.utf16)
    }
    override var unicodeScalars: AnyUnicodeScalarUnicodeView {
      return AnyUnicodeScalarUnicodeView(base.unicodeScalars)
    }
#if false
    override var utf32: AnyUInt32UnicodeView {
      return AnyUInt32UnicodeView(base.utf32)
    }
    override var fccNormalizedUTF16: AnyUInt16UnicodeView {
      return AnyUInt16UnicodeView(base.fccNormalizedUTF16)
    }
    override var extendedASCII: UnicodeBidirectionalUInt32 {
      return base.extendedASCII
    }
    override var characters: AnyCharacters { return base.characters }
#endif
    override var isKnownLatin1: Bool { return base.isKnownLatin1 }
    override var isKnownASCII: Bool { return base.isKnownASCII }
    override var isKnownFCCNormalized: Bool { return base.isKnownFCCNormalized }
    override var isKnownFCDForm: Bool { return base.isKnownFCDForm }
    override var isKnownNFDNormalized: Bool { return base.isKnownNFDNormalized }
    override var isKnownNFCNormalized: Bool { return base.isKnownNFCNormalized }
    override func isLatin1() -> Bool  { return base.isLatin1() }
    override func isASCII() -> Bool  { return base.isASCII() }
    init(_ x: Base) {
      base = x
      super.init(fromSubclass: ())
    }
  }

  convenience init<Base: _UnicodeContent>(wrapping x: Base)
  where Base.UTF16View.Iterator.Element == UTF16.CodeUnit,
  Base.UnicodeScalarView.Iterator.Element == UnicodeScalar
  {
    self.init(Instance(x))
  }
  
  init(fromSubclass: ()) {}
}

//===--- Counted ----------------------------------------------------------===//
% for Bidirectional in '', 'Bidirectional':
/// Adds a stored `count` to the given `Base` collection so that the cost of
/// counting it is not repeated.
public struct ${Bidirectional}Counted<Base_: ${Bidirectional}Collection> {
  public let base: Base_
  public let count: Base.IndexDistance
}

extension ${Bidirectional}Counted : ${Bidirectional}CollectionWrapper {
  public typealias Base = Base_
  public typealias Index = Base.Index
  public typealias IndexDistance = Base.IndexDistance
}

extension ${Bidirectional}Counted : ${Bidirectional}Collection {
  public init(_ base: Base) {
    self.base = base
    self.count = base.count
  }
  
  public init(_ base: Base, count: Base.IndexDistance) {
    _debugPrecondition(
      count == base.count, "misstated count of base collection")
    self.base = base
    self.count = count
  }
  
  public var underestimatedCount: Int {
    return numericCast(count)
  }
}
% end

//===--- String -----------------------------------------------------------===//
public struct String {
  public struct Content {
    internal enum Representation {
    case utf16(_UTF16StringStorage)
    case latin1(_Latin1StringStorage)
    case any(UnicodeContentBox)
    }
    internal var _rep: Representation
  }
  var content: Content
}

extension String : BidirectionalCollection, BidirectionalCollectionWrapper {
  public typealias Base = AnyCharacterUnicodeView
  public typealias Index = AnyCharacterUnicodeView.Index
  public typealias IndexDistance = AnyCharacterUnicodeView.IndexDistance
  
  public var base: Base {
    return content.characters
  }
}

%{
def switch(s):
  return """switch _rep {
    case .utf16(let x):
      %(s)s
    case .latin1(let x):
      %(s)s
    case .any(let x):
      %(s)s
    }""" % locals()
  
}%

extension String.Content : _UnicodeContent {
  public typealias UTF16View = AnyUInt16UnicodeView
  public var utf16: UTF16View {
    ${switch('return UTF16View(x.utf16)')}
  }

  public typealias FCCNormalizedUTF16View = AnyUInt16UnicodeView
  public var fccNormalizedUTF16: FCCNormalizedUTF16View {
    ${switch('return FCCNormalizedUTF16View(x.fccNormalizedUTF16)')}
  }

  public typealias UnicodeScalarView = AnyUnicodeScalarUnicodeView
  public var unicodeScalars: UnicodeScalarView {
    ${switch('return UnicodeScalarView(x.unicodeScalars)')}
  }

  public typealias CharacterView = AnyCharacterUnicodeView
  public var characters: CharacterView {
    ${switch('return CharacterView(x.characters)')}
  }
  
  public func isLatin1() -> Bool { ${switch('return x.isLatin1()')} }
  public func isASCII() -> Bool { ${switch('return x.isASCII()')} }
  public var isKnownLatin1: Bool { ${switch('return x.isKnownLatin1')} }
  public var isKnownASCII: Bool {  ${switch('return x.isKnownASCII')} }
  public var isKnownFCCNormalized: Bool {
    ${switch('return x.isKnownFCCNormalized')}
  }
  public var isKnownFCDForm: Bool { ${switch('return x.isKnownFCDForm')} }
  public var isKnownNFDNormalized: Bool {
    ${switch('return x.isKnownNFDNormalized')}
  }
  public var isKnownNFCNormalized: Bool {
    ${switch('return x.isKnownNFCNormalized')}
  }
}

extension _BoundedBufferReference {
  /// Construct the concatenation of head, middle, and tail
  init<Head : Collection, Middle : Collection, Tail : Collection>(
    joining head: Head, _ middle: Middle, _ tail: Tail
  )
  where
    Head.Iterator.Element == Iterator.Element,
    Middle.Iterator.Element == Iterator.Element,
    Tail.Iterator.Element == Iterator.Element
  {
    let newCount = numericCast(head.count) as IndexDistance
      + numericCast(middle.count) as IndexDistance
      + numericCast(tail.count) as IndexDistance

    self.init(_uninitializedCount: numericCast(newCount))
    
    self.withUnsafeMutableBufferPointer { b0 in

      let (_, i0) = head._copyContents(initializing: b0)
      
      let b1 = UnsafeMutableBufferPointer(
        start: b0.baseAddress + i0, count: b0.count - b0[..<i0].count)
      let (_, i1) = middle._copyContents(initializing: b1)

      let b2 = UnsafeMutableBufferPointer(
        start: b1.baseAddress + i1, count: b1.count - b1[..<i1].count)
      let (_, i2) = tail._copyContents(initializing: b2)
      
      assert(i2 == b2.endIndex, "Failed to consume input")
    }
  }
}

extension _BoundedBufferReference
where Index == Int, IndexDistance == Int, SubSequence.IndexDistance == Int {
  /// If there is sufficient capacity, replaces the elements bounded by `target`
  /// with the contents of `replacement` and returns true.
  ///
  /// Returns `false` otherwise.
  public func tryToReplaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) -> Bool
  where C.Iterator.Element == Iterator.Element {
    let r = Counted(replacement)
    let delta = numericCast(r.count) - self[target].count
    if _fastPath(capacity >= self.count + delta) {
      replaceSubrange(target, with: r)
      return true
    }
    return false
  }
}

extension Collection where Iterator.Element == UTF16.CodeUnit {
  internal func _isLatin1() -> Bool {
    return self.max() ?? 0 <= 0xFF
  }
  internal var _low8Bits : LazyMapCollection<Self, UInt8> {
    return self.lazy.map { UInt8(truncatingBitPattern: $0) }
  }
}

// TODO:
//
// - Move Any*UnicodeView into the standard library
//
extension String.Content {
  public init() { _rep = .utf16(._emptyInstance()) }

  internal var _storageID: ObjectIdentifier? {
    switch _rep {
    case .utf16(let storage):
      return ObjectIdentifier(storage)
    case .latin1(let storage):
      return ObjectIdentifier(storage)
    case .any(let storage):
      return ObjectIdentifier(storage)
    }
  }
}

extension String : RangeReplaceableCollection {
  
  public init() { content = Content() }
  
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Iterator.Element == Character {
    // TODO:
    //
    // - Create an existential-able protocol that can be used to extract
    //   underlying UTF16 (including normalized)
    //
    // - Optimize this so we're not working from Characters
    let uncountedUTF16 = replacement.lazy.flatMap { $0.utf16 }
    replaceUTF16(target, with: uncountedUTF16)
  }

  /// Replaces the `target` subrange with the given UTF-16 encoded content.
  internal mutating func replaceUTF16<C: Collection>(
    _ target: Range<Index>, with replacement_: C
  )  
  where C.Iterator.Element == UTF16.CodeUnit {
    // Pre-count replacement, once.
    let replacement = Counted(replacement_)

    // Try to do in-place replacement
    if _fastPath(replaceUTF16InPlace(target, with: replacement)) {
      return
    }
    // Otherwise, we need to allocate new storage
    
    let head = content.utf16[..<target.lowerBound]
    let tail = content.utf16[target.upperBound...]

    // See if we can use 8-bit code units
    if replacement._isLatin1() && (
      content.isKnownLatin1 || head._isLatin1() && tail._isLatin1()
    ) {
      content._rep = .latin1(
        _Latin1StringStorage(
          joining: head._low8Bits, replacement._low8Bits, tail._low8Bits))
    }
    else {
      content._rep = .utf16(_UTF16StringStorage(joining: head, replacement, tail))
    }
  }
  
  internal var isMutable: Bool {
    mutating get {
      defer { _fixLifetime(self) }
      return content._storageID?._liveObjectIsUniquelyReferenced() ?? true
    }
  }
  
  internal mutating func replaceUTF16InPlace<C>(
    _ target: Range<Index>, with replacement: Counted<C>
  ) -> Bool 
  where C.Iterator.Element == UTF16.CodeUnit {
    if !isMutable { return false }

    let t: Range<Int> = numericCast(target.lowerBound.encodedOffset)
      ..< numericCast(target.upperBound.encodedOffset)

    switch content._rep {
    case .utf16(let storage):
      return storage.tryToReplaceSubrange(t, with: replacement)
    case .latin1(let storage):
      return storage.tryToReplaceSubrange(
        t, with: replacement.lazy.map { UInt8(truncatingBitPattern: $0) })
    case .any(_):
      return false
    }
  }
}

extension ObjectIdentifier {
  /// Returns true if the object identified by `self` is uniquely referenced.
  ///
  /// - Requires: the object identified by `self` exists.
  /// - Note: will only work when called from a mutating method
  internal func _liveObjectIsUniquelyReferenced() -> Bool {
    var me = self
    return withUnsafeMutablePointer(to: &me) {
      $0.withMemoryRebound(to: AnyObject.self, capacity: 1) {
        _isUnique(&$0.pointee)
      }
    }    
  }
}

//===----------------------------------------------------------------------===//
//===--- Tests ------------------------------------------------------------===//
//===----------------------------------------------------------------------===//


var suite = TestSuite("AnyUnicode")

let sample = "abcdefghijklmnopqrstuvwxyz\n"
  + "ğŸ‡¸ğŸ‡¸ğŸ‡¬ğŸ‡±ğŸ‡±ğŸ‡¸ğŸ‡©ğŸ‡¯ğŸ‡ºğŸ‡¸\n"
  + "Î£á½² ğŸ‘¥ğŸ¥“Î³Î½Ï‰ÏÎ¯Î¶Ï‰ á¼€Ï€á½¸ Ï„á½´Î½ ÎºÏŒÏˆÎ· Ï‡Î±á¿–ÏÎµ, á½¦ Ï‡Î±á¿–ÏÎµ, á¾¿Î•Î»ÎµÏ…Î¸ÎµÏÎ¹Î¬!\n"
  + "ÎŸá½Ï‡á½¶ Ï„Î±á½Ï„á½° Ï€Î±ÏÎ¯ÏƒÏ„Î±Ï„Î±Î¯ Î¼Î¿Î¹ Î³Î¹Î³Î½ÏÏƒÎºÎµÎ¹Î½, á½¦ á¼„Î½Î´ÏÎµÏ‚ á¾¿Î‘Î¸Î·Î½Î±á¿–Î¿Î¹,\n"
  + "áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒáƒ®áƒšáƒáƒ•áƒ” áƒ’áƒáƒ˜áƒáƒ áƒáƒ— áƒ áƒ”áƒ’áƒ˜áƒ¡áƒ¢áƒ áƒáƒªáƒ˜áƒ Unicode-áƒ˜áƒ¡ áƒ›áƒ”áƒáƒ—áƒ” áƒ¡áƒáƒ”áƒ áƒ—áƒáƒ¨áƒáƒ áƒ˜áƒ¡áƒ\n"
  + "Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞ¹Ñ‚ĞµÑÑŒ ÑĞµĞ¹Ñ‡Ğ°Ñ Ğ½Ğ° Ğ”ĞµÑÑÑ‚ÑƒÑ ĞœĞµĞ¶Ğ´ÑƒĞ½Ğ°Ñ€Ğ¾Ğ´Ğ½ÑƒÑ ĞšĞ¾Ğ½Ñ„ĞµÑ€ĞµĞ½Ñ†Ğ¸Ñ Ğ¿Ğ¾\n"
  + "  à¹ à¹à¸œà¹ˆà¸™à¸”à¸´à¸™à¸®à¸±à¹ˆà¸™à¹€à¸ªà¸·à¹ˆà¸­à¸¡à¹‚à¸—à¸£à¸¡à¹à¸ªà¸™à¸ªà¸±à¸‡à¹€à¸§à¸Š  à¸à¸£à¸°à¸›à¸à¹€à¸à¸¨à¸à¸­à¸‡à¸šà¸¹à¹Šà¸à¸¹à¹‰à¸‚à¸¶à¹‰à¸™à¹ƒà¸«à¸¡à¹ˆ\n"
  + "áš»á›– áš³áš¹áš«áš¦ áš¦áš«á› áš»á›– á›’áš¢á›á›– áš©áš¾ áš¦áš«á›— á›šášªáš¾á›á›– áš¾áš©áš±áš¦áš¹á›–ášªáš±á›áš¢á›— áš¹á›áš¦ áš¦ášª áš¹á›–á›¥áš«"

suite.test("MemoryLayout") {
  expectEqual(8, MemoryLayout<String>.size)
  expectEqual(8, MemoryLayout<String>.stride)
}

suite.test("Latin1.smoke") {
  var latin1Sample = String(
    sample.unicodeScalars.lazy.filter { $0.value < 0x100 }.map {
      Character($0)
    })
  
  latin1Sample.replaceSubrange(
    latin1Sample.index(atOffset: 3)..<latin1Sample.index(atOffset: 10),
    with: "BRAK"
  )
  
  let s1 = latin1Sample
  
  latin1Sample.replaceSubrange(
    latin1Sample.index(atOffset: 5)..<latin1Sample.index(atOffset: 6),
    with: "---bloog---"
  )
  expectEqualSequence(
    "abcBRAKklmnopqrstuvw", Swift.String(s1[..<s1.index(atOffset: 20)]))

  expectEqualSequence(
    "abcBR---bloog---Kklmnopqr",
    Swift.String(latin1Sample[..<latin1Sample.index(atOffset: 25)]))
}

suite.test("Bidirectional/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeView(
    _UnicodeViews(Array(sample.utf16), ValidUTF16.self).scalars)
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedOffset = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedOffset
    expectLT(lastEncodedOffset, o)
    lastEncodedOffset = o
  }
}

suite.test("RandomAccess/UnicodeScalar") {
  let a = AnyUnicodeScalarUnicodeView(
    RandomAccessUnicodeView(Array(sample.unicodeScalars)))
  expectEqualSequence(sample.unicodeScalars, a)
  var lastEncodedOffset = Int64.min
  // Make sure it works as a collection, too.
  for (s, i) in zip(sample.unicodeScalars, a.indices) {
    expectEqual(s, a[i])
    let o = i.encodedOffset
    expectLT(lastEncodedOffset, o)
    lastEncodedOffset = o
  }
}
runAllTests()
